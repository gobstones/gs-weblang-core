{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 39d3373981835bf586b9","webpack:///./lib/public.js","webpack:///./lib/grammar.js","webpack:///./lib/parser.js","webpack:///./lib/lexer.js","webpack:///./lib/gobstones-tokens-en.js","webpack:///./lib/interpreter.js","webpack:///./lib/execution-context.js","webpack:///./lib/model.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACPA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA,mBAAkB,EAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB,EAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAiC;AACjC;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA,4C;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa;AACb,iBAAgB,aAAa;AAC7B,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,4B;AACA;AACA,qBAAoB;AACpB;AACA,eAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,kCAAiC;AACjC;AACA;AACA;AACA,qBAAoB;AACpB;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL,cAAa;AACb;AACA,qBAAoB;AACpB;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;;;;;;;AC3SA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0BAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,mBAAkB,EAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAuB;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,EAAE;AAChB,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACjVA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAoC,OAAO;;AAE3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAY;AACZ;;AAEA;AACA,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC7BA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA,oBAAmB,mCAAmC;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACxPA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;AClDA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,QAAQ;AACxC,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"./index.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gsWeblangCore\"] = factory();\n\telse\n\t\troot[\"gsWeblangCore\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 39d3373981835bf586b9\n **/","module.exports = {\n    grammar: require('../lib/grammar'),\n    parser: require('../lib/parser'),\n    lexer: require('../lib/lexer'),\n    tokens: require('../lib/gobstones-tokens-en'),\n    interpreter: require('../lib/interpreter'),\n    context: require('../lib/execution-context')\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/public.js\n ** module id = 0\n ** module chunks = 0\n **/","function Grammar(Parser, lexer, names, behaviour) {\n    'use strict';\n\n    var n = names;\n    var b = behaviour;\n    var g = new Parser(lexer);\n\n    function operator(op, bp, f) {\n        g.infix(op, bp, function (left) {\n            var self = this;\n            this.left = left;\n            this.right = g.expression(bp);\n            this.arity = 'binary';\n            this.eval = function (context) {\n                return f(self.right.eval(context), self.left.eval(context));\n            };\n            return this;\n        });\n    }\n\n    function parameterListCall() {\n        var parameters = [];\n        if (g.token.id !== ')') {\n            for (; ;) {\n                parameters.push(g.expression(0));\n                if (g.token.id !== ',') {\n                    break;\n                }\n                g.advance(',');\n            }\n        }\n        g.advance(')');\n        return parameters;\n    }\n\n    function parameterDeclarationList() {\n        var parameters = [];\n        g.advance('(');\n        if (g.token.id !== ')') {\n            for (; ;) {\n                if (g.token.arity !== 'name') {\n                    g.error(g.token, 'Expected a parameter name.');\n                }\n                g.scope.define(g.token);\n                parameters.push(g.token);\n                g.advance();\n                if (g.token.id !== ',') {\n                    break;\n                }\n                g.advance(',');\n            }\n        }\n        g.advance(')');\n        return parameters;\n    }\n\n    function parenthesisExpression() {\n        'use strict';\n        g.advance('(');\n        var p = g.expression(0);\n        g.advance(')');\n        return p;\n    }\n\n    function bodyStatement() {\n        return (g.token.id === '{') ? g.block() : [g.statement()];\n    }\n\n    operator('<', 40, function (x, y) {\n        return x < y;\n    });\n    operator('<=', 40, function (x, y) {\n        return x <= y;\n    });\n    operator('>', 40, function (x, y) {\n        return x > y;\n    });\n    operator('>=', 40, function (x, y) {\n        return x >= y;\n    });\n    operator('!=', 40, function (x, y) {\n        return x !== y;\n    });\n    operator('==', 40, function (x, y) {\n        return x === y;\n    });\n    operator('||', 20, function (x, y) {\n        return x || y;\n    });\n    operator('&&', 20, function (x, y) {\n        return x && y;\n    });\n    operator('+', 50, function (x, y) {\n        return x + y;\n    });\n    operator('-', 50, function (x, y) {\n        return x - y;\n    });\n    operator('*', 60, function (x, y) {\n        return x * y;\n    });\n    operator('/', 60, function (x, y) {\n        return x / y;\n    });\n    \n    g.prefix(n.NOT, function (x) {\n       return b.negation(g.expression(60)); \n    });\n\n    g.symbol('(end)');\n\n    g.symbol(':');\n    g.symbol(')');\n    g.symbol('(');\n    g.symbol(']');\n    g.symbol('}');\n    g.symbol(',');\n    g.symbol('->');\n    g.symbol(n.ELSE);\n    g.symbol(n.TO);\n\n    g.constant(n.FALSE, false);\n    g.constant(n.TRUE, true);\n    g.constant(n.BLUE, 0);\n    g.constant(n.RED, 1);\n    g.constant(n.BLACK, 2);\n    g.constant(n.GREEN, 3);\n    g.constant(n.NORTH, [0, 1]);\n    g.constant(n.SOUTH, [0, -1]);\n    g.constant(n.EAST, [1, 0]);\n    g.constant(n.WEST, [-1, 0]);\n\n    g.stmt(';', function () {\n        return {separator: ';'};\n    });\n\n    g.infix('(', 80, function (left) {\n        if (left.arity !== 'name') {\n            g.error(left, left.value + ' is not a routine');\n        }\n        var parameters = parameterListCall();\n        var node;\n        if (left.value[0].toUpperCase() === left.value[0]) {\n            node = b.procedureCall(left.value, function () {\n                return g.scope.find(left.value);\n            }, parameters);\n        } else {\n            node = b.functionCall(left.value, function () {\n                return g.scope.find(left.value);\n            }, parameters);\n        }\n        return node;\n    });\n\n    g.infixr(':=', 10, function (left) {\n        if (left.id !== '.' && left.id !== '[' && left.arity !== 'name') {\n            g.error(left, 'Bad lvalue.');\n        }\n        return b.assignment(left, g.expression(9));\n    });\n\n    g.stmt(n.PUT, function () {\n        return b.putStone(parenthesisExpression());\n    });\n    g.stmt(n.REMOVE, function () {\n        return b.removeStone(parenthesisExpression());\n    });\n    g.stmt(n.MOVE, function () {\n        return b.moveClaw(parenthesisExpression());\n    });\n    g.prefix(n.HAS_STONES, function () {\n        return b.hasStone(parenthesisExpression());\n    });\n    g.prefix(n.CAN_MOVE, function () {\n        return b.canMove(parenthesisExpression());\n    });\n\n    g.symbol('(literal)').nud = b.literal();\n    g.symbol('(name)').nud = b.variable();\n\n    g.stmt(n.IF, function () {\n        g.advance('(');\n        var condition = g.expression(0);\n        g.advance(')');\n        var trueBranch = bodyStatement();\n        var falseBranch = null;\n        if (g.token.id === n.ELSE) {\n            g.scope.reserve(g.token);\n            g.advance(n.ELSE);\n            falseBranch = bodyStatement();\n        }\n        return b.conditional(condition, trueBranch, falseBranch);\n    });\n\n    g.stmt(n.SWITCH, function () {\n        var condition = parenthesisExpression();\n        if (g.token.id === n.TO) {\n           g.advance(n.TO); \n        }\n        g.advance('{');\n        var cases = [];\n        for (; ;) {\n            var exp = g.expression(0);\n            g.advance('->');\n            var body = bodyStatement();\n            cases.push({\n                case: exp,\n                body: body\n            });\n            if (g.token.id === '}' || !g.tokens.hasNext()) {\n                break;\n            }\n        }\n        g.advance('}');\n        return b.switch(condition, cases);\n    });\n\n    g.stmt(n.WHILE, function () {\n        var condition = parenthesisExpression();\n        var body = bodyStatement();\n        return b.conditionalRepetition(condition, body);\n    });\n\n    g.stmt(n.REPEAT, function () {\n        var numericExpression = parenthesisExpression();\n        var body = bodyStatement();\n        return b.numericRepetition(numericExpression, body);\n    });\n\n    g.stmt('{', function () {\n        var a = g.statements();\n        g.advance('}');\n        return a;\n    });\n\n    g.stmt('(', function () {\n        var a = g.statements();\n        g.advance(')');\n        return a;\n    });\n\n    g.root(n.PROGRAM, function () {\n        return b.programDeclaration(g.block());\n    });\n\n    g.root(n.FUNCTION, function () {\n        g.newScope();\n        var token = g.token;\n        if (g.token.arity === 'name') {\n            g.scope.define(g.token);\n            g.advance();\n        }\n        var parameters = parameterDeclarationList();\n        var body = bodyStatement();\n        var ret = body.pop();\n        if (!ret || ret.alias !== 'return' || !ret.expression) {\n            g.error(token, 'La función ' + token.value + ' debe terminar con un ' + n.RETURN);\n        }\n        g.scope.pop();\n        var declaration = b.functionDeclaration(token, parameters, body, ret.expression);\n        declaration.std = function () {\n            return declaration;\n        };\n        return declaration;\n    });\n\n    g.root(n.PROCEDURE, function () {\n        /**\n         * Bind scope to token\n         * Bind declaration to token\n         */\n\n        g.newScope();\n        var token = g.token;\n        if (g.token.arity === 'name') {\n            g.scope.define(g.token);\n            g.advance();\n        }\n        var parameters = parameterDeclarationList();\n        var body = bodyStatement();\n        g.scope.pop();\n        var declaration = b.procedureDeclaration(token, parameters, body);\n        declaration.std = function () {\n            return declaration;\n        };\n        return declaration;\n    });\n\n    g.stmt(n.RETURN, function () {\n        if (g.token.id !== ';') {\n            this.alias = 'return';\n            this.expression = parenthesisExpression();\n        }\n        return this;\n    });\n\n    return b.rootProgram(g);\n}\n\nmodule.exports = Grammar;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/grammar.js\n ** module id = 1\n ** module chunks = 0\n **/","function Parser(lexer) {\n    this.scope = null;\n    this.token = null;\n    this.tokens = lexer;\n    var self = this;\n\n    var symbolTable = {};\n\n    this.error = function (token, description) {\n        var someError = {error: description, on: token};\n        throw someError;\n    };\n\n    var OriginalSymbol = {\n        nud: function () {\n            self.error(this, 'Undefined.');\n        },\n        led: function () {\n            self.error(this, 'Missing operator.');\n        }\n    };\n\n    var itself = function () {\n        return this;\n    };\n\n    var originalScope = {\n        define: function (name) {\n            var t = this.def[name.value];\n            if (typeof t === 'object') {\n                self.error(name, t.reserved ? 'Already reserved.' : 'Already defined.');\n            }\n            this.def[name.value] = name;\n            name.reserved = false;\n            name.nud = itself;\n            name.led = null;\n            name.std = null;\n            name.lbp = 0;\n            name.scope = self.scope;\n            return name;\n        },\n        find: function (name) {\n            var e = this;\n            var targetToken;\n            for (; ;) {\n                targetToken = e.def[name];\n                if (targetToken && typeof targetToken !== 'function') {\n                    return e.def[name];\n                }\n                e = e.parent;\n                if (!e) {\n                    targetToken = symbolTable[name];\n                    return targetToken && typeof targetToken !== 'function' ? targetToken : symbolTable['(name)'];\n                }\n            }\n        },\n        pop: function () {\n            this.scope = this.parent;\n        },\n        reserve: function (name) {\n            if (name.arity !== 'name' || name.reserved) {\n                return;\n            }\n            var t = this.def[name.value];\n            if (t) {\n                if (t.reserved) {\n                    return;\n                }\n                if (t.arity === 'name') {\n                    name.error('Already defined.');\n                }\n            }\n            this.def[name.value] = name;\n            name.reserved = true;\n        }\n    };\n\n    this.newScope = function () {\n        var s = self.scope;\n        self.scope = Object.create(originalScope);\n        self.scope.def = {};\n        self.scope.parent = s;\n        return self.scope;\n    };\n\n    this.symbol = function (id, bindingPower) {\n        var s = symbolTable[id];\n        bindingPower = bindingPower || 0;\n        if (s) {\n            if (bindingPower >= s.lbp) {\n                s.lbp = bindingPower;\n            }\n        } else {\n            s = Object.create(OriginalSymbol);\n            s.id = s.value = id;\n            s.lbp = bindingPower;\n            symbolTable[id] = s;\n        }\n        return s;\n    };\n\n    this.expression = function (rightBindingPower) {\n        var left;\n        var t = self.token;\n        this.advance();\n        left = t.nud();\n        while (rightBindingPower < self.token.lbp) {\n            t = self.token;\n            this.advance();\n            left = t.led(left);\n        }\n        return left;\n    };\n\n    this.constant = function (symbol, value) {\n        var x = this.symbol(symbol);\n        x.nud = function () {\n            self.scope.reserve(this);\n            this.value = symbolTable[this.id].value;\n            this.arity = 'literal';\n            this.eval = function () {\n                return value;\n            };\n            return this;\n        };\n        x.value = value;\n        return x;\n    };\n\n    this.infix = function (id, bp, led) {\n        var s = this.symbol(id, bp);\n        s.led = led || function (left) {\n            this.left = left;\n            this.right = self.expression(bp);\n            this.arity = 'binary';\n            return this;\n        };\n        return s;\n    };\n\n    this.infixr = function (id, bp, led) {\n        var s = this.symbol(id, bp);\n        s.led = led || function (left) {\n            this.left = left;\n            this.right = self.expression(bp - 1);\n            this.arity = 'binary';\n            return this;\n        };\n        return s;\n    };\n\n    this.prefix = function (id, nud) {\n        var s = this.symbol(id);\n        s.nud = nud || function () {\n            scope.reserve(this);\n            this.left = self.expression(70);\n            this.arity = 'unary';\n            return this;\n        };\n        return s;\n    };\n\n    this.stmt = function (symbol, f) {\n        var x = this.symbol(symbol);\n        x.std = f;\n        return x;\n    };\n\n    this.root = function (symbol, f) {\n        var x = this.symbol(symbol);\n        x.root = f;\n        return x;\n    };\n\n    /**\n     * The advance function fetches the next token,\n     * generating the corresponding symbol from the definitions on symbolTable\n     *\n     * @param id. Token ID\n     * @returns Token\n     */\n    this.advance = function (id) {\n        var a;\n        var o;\n        var t;\n        var v;\n        var tokens = this.tokens;\n        if (id && this.token.id !== id) {\n            this.error(this.token, 'Se esperaba \"' + id + '\" pero se encontró ' + this.token.value);\n        }\n        if (!tokens.hasNext()) {\n            this.token = symbolTable['(end)'];\n            return this.token;\n        }\n        t = tokens.next();\n        v = t.value;\n        a = t.type;\n        if (a === 'name') {\n            o = this.scope.find(v);\n        } else if (a === 'operator') {\n            o = symbolTable[v];\n            if (!o) {\n                this.error(t, 'Unknown operator.');\n            }\n        } else if (a === 'number') {\n            o = symbolTable['(literal)'];\n            a = 'literal';\n            v = parseInt(v, 10);\n        } else {\n            this.error(t, 'Unexpected token.');\n        }\n\n        var token = Object.create(o);\n        token.from = t.from;\n        token.row = t.row;\n        token.to = t.to;\n        token.value = v;\n        token.arity = a;\n        this.token = token;\n        return token;\n    };\n\n    this.block = function () {\n        var t = this.token;\n        this.advance('{');\n        return t.std();\n    };\n\n    this.statement = function () {\n        var n = this.token;\n        var v;\n\n        if (n.std) {\n            this.advance();\n            self.scope.reserve(n);\n            return n.std();\n        }\n        v = this.expression(0);\n        if (!v.assignment && v.id !== '(' && v.arity !== 'routine') {\n            this.error(v, 'Bad expression statement.');\n        }\n        return v;\n    };\n\n    this.rootDeclaration = function () {\n        var n = this.token;\n        var v;\n\n        if (n.root) {\n            this.advance();\n            self.scope.reserve(n);\n            return n.root();\n        }\n        v = this.expression(0);\n        if (!v.assignment && v.id !== '(' && v.arity !== 'routine') {\n            this.error(v, 'Bad expression statement.');\n        }\n        return v;\n    };\n\n    this.statements = function () {\n        var statementsList = [];\n        var symbol;\n        for (; ;) {\n            if (this.token.id === '}' || this.token.id === '(end)') {\n                break;\n            }\n            var from = this.token.from;\n            symbol = this.statement();\n            if (symbol) {\n                symbol.from = from;\n                if (this.token.from) {\n                    symbol.to = this.token.from;\n                }\n                statementsList.push(symbol);\n            }\n        }\n        if (statementsList.length === 0) {\n            return null;\n        }\n        return statementsList;\n    };\n\n    this.roots = function () {\n        var roots = [];\n        var symbol;\n        for (; ;) {\n            if (this.token.id === '(end)') {\n                break;\n            }\n            var from = this.token.from;\n            symbol = this.rootDeclaration();\n            if (symbol) {\n                symbol.from = from;\n                if (this.token.from) {\n                    symbol.to = this.token.from;\n                }\n                roots.push(symbol);\n            }\n        }\n        if (roots.length === 0) {\n            return null;\n        }\n        return roots;\n    };\n\n    this.parseProgram = function (input) {\n        this.tokens.input(input);\n        this.newScope();\n        this.advance();\n        var s = this.roots();\n        this.advance('(end)');\n        this.scope.pop();\n        return s;\n    };\n\n    this.parse = function (input) {\n        this.tokens.input(input);\n        this.newScope();\n        this.advance();\n        var s = this.statements();\n        this.advance('(end)');\n        this.scope.pop();\n        return s;\n    };\n\n    this.parseExpression = function (input) {\n        this.tokens.input(input);\n        this.newScope();\n        this.advance();\n        var s = this.expression(0);\n        this.advance('(end)');\n        this.scope.pop();\n        return s;\n    };\n}\n\nmodule.exports = Parser;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/parser.js\n ** module id = 2\n ** module chunks = 0\n **/","/**\n * LEXER\n *\n * The lexer class is an iterator that takes a String as input in Lexer.input\n * and returns a token each time Lexer.next is called, or null otherwise.\n * Characters used for multi character operators can be configured on instantiation.\n */\n\n// PUBLIC\n\nfunction Lexer(prefix, suffix) {\n    // Current reading position\n    this.from = 0;\n    this.row = 0;\n    this.prefix = prefix || '!=-<>:|&';\n    this.suffix = suffix || '=|&>';\n\n    this.punctuators = '+-*.:%|!?#&;,()<>{}[]=';\n\n    // Look ahead position\n    this.i = 0;\n\n    this.buf = null;\n    this.buflen = 0;\n}\n\nLexer.prototype.hasNext = function () {\n    this._skipNonTokens();\n    return this.from < this.buflen;\n};\n\nLexer.prototype.input = function (buf) {\n    this.from = 0;\n    this.i = 0;\n    this.row = 0;\n    this.buf = buf;\n    this.buflen = buf.length;\n    this.current = null;\n    this.nextChar = null;\n};\n\nvar TokenTypes = {\n    IDENTIFIER: 'name',\n    OPERATOR: 'operator',\n    EOF: 'eof',\n    COMMENT: 'comment',\n    NUMBER: 'number',\n    NEWLINE: 'newline'\n};\n\n/**\n * This method is highly procedural for performance reasons.\n * There is no need for the lexer to be too flexible, since the\n * semantics will be associated to identifiers on the parser.\n *\n * @returns Token. The next token on the buffer, or null if the buffer is empty.\n */\nLexer.prototype.next = function () {\n    this._skipNonTokens();\n    this._refreshCurrentAndNextChars();\n\n    if (this.from >= this.buflen) {\n        return null;\n    }\n\n    // Always add cases in descending order of occurrence probability\n    if (this._processIdentifier()) {\n        return this._consume(TokenTypes.IDENTIFIER);\n    } else if (this._processOperator()) {\n        return this._consume(TokenTypes.OPERATOR);\n    } else if (this._processNumber()) {\n        return this._consume(TokenTypes.NUMBER);\n    } else if (this._processComment()) {\n        return this._consume(TokenTypes.COMMENT);\n    }\n\n    return this._processError();\n};\n\n// PRIVATE\n\nfunction error(token, description) {\n    return {error: description, on: token};\n}\n\nLexer.prototype._make = function (type, value) {\n    return {type: type, value: value, from: this.from, to: this.i, row: this.row};\n};\n\nLexer.prototype._consume = function (type) {\n    var text = this.buf.substring(this.from, this.i);\n    var newToken = this._make(type, text);\n    this.from = this.i;\n    return newToken;\n};\n\nLexer.prototype._refreshCurrentAndNextChars = function () {\n    this.current = this.buf.charAt(this.from);\n    this.nextChar = this.buf.charAt(this.from + 1);\n};\n\nLexer.prototype._processOperator = function () {\n    if (this.punctuators.indexOf(this.current) >= 0) {\n        this.i = this.from + 1;\n        this._processMultiCharOperator();\n        return true;\n    }\n    return false;\n};\n\nLexer.prototype._processMultiCharOperator = function () {\n    if (this.prefix.indexOf(this.current) >= 0 && this.suffix.indexOf(this.nextChar) >= 0) {\n        this.i++;\n    }\n};\n\nLexer.prototype._processNumber = function () {\n    if (_isDigit(this.current)) {\n        this.i = this.from + 1;\n        while (this.i < this.buflen && _isDigit(this.buf.charAt(this.i))) {\n            this.i++;\n        }\n        return true;\n    }\n    return false;\n};\n\nLexer.prototype._processError = function () {\n    this.i = this.from + 1;\n    return error('Unmatched token', this._consume('UNMATCHED'));\n};\n\nLexer.prototype._processIdentifier = function () {\n    if (_isAlpha(this.current)) {\n        this.i = this.from + 1;\n        while (this.i < this.buflen && _isAlphanum(this.buf.charAt(this.i))) {\n            this.i++;\n        }\n        return true;\n    }\n    return false;\n};\n\nLexer.prototype._skipNonTokens = function () {\n    while (this.from < this.buflen) {\n        var c = this.buf.charAt(this.from);\n        if (c === ' ' || c === '\\t' || c === '\\r' || c === '\\n') {\n            if (c === '\\n') {\n                this.row += 1;\n            }\n            this.from++;\n            this.i = this.from;\n        } else {\n            break;\n        }\n    }\n};\n\nLexer.prototype._processComment = function () {\n    var chars = this.current + this.nextChar;\n    return this._processSingleLineComment(chars) || this._processMultiLineComment(chars);\n};\n\nLexer.prototype._processSingleLineComment = function (chars) {\n    if (chars === '//') {\n        while (this.i < this.buflen && !_isNewline(this.buf.charAt(this.i))) {\n            this.i++;\n        }\n        return true;\n    }\n};\n\nLexer.prototype._processMultiLineComment = function (chars) {\n    if (chars === '/*') {\n        this.i = this.i + 2;\n        while (this.i < this.buflen && this.buf.charAt(this.i) !== '*' && this.buf.charAt(this.i + 1) !== '/') {\n            this.i++;\n        }\n        this.i = this.i + 2;\n        return true;\n    }\n    return false;\n};\n\nfunction _isNewline(c) {\n    return c === '\\r' || c === '\\n';\n}\n\nfunction _isDigit(c) {\n    return c >= '0' && c <= '9';\n}\n\nfunction _isAlpha(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '_' || c === '$';\n}\n\nfunction _isAlphanum(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c === '_' || c === '$';\n}\n\nmodule.exports = Lexer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/lexer.js\n ** module id = 3\n ** module chunks = 0\n **/","var TOKEN_NAMES = {\n    WHILE: 'while',\n    IF: 'if',\n    ELSE: 'else',\n    SWITCH: 'switch',\n    REPEAT: 'repeat',\n    FUNCTION: 'function',\n    PROCEDURE: 'procedure',\n    PROGRAM: 'program',\n    PUT: 'Poner',\n    REMOVE: 'Sacar',\n    HAS_STONES: 'hayBolitas',\n    CAN_MOVE: 'puedeMover',\n    MOVE: 'Mover',\n    RETURN: 'return',\n    RED: 'Rojo',\n    BLUE: 'Azul',\n    BLACK: 'Negro',\n    GREEN: 'Verde',\n    TRUE: 'True',\n    NOT: 'not',\n    TO: 'to',\n    FALSE: 'False',\n    NORTH: 'Norte',\n    SOUTH: 'Sur',\n    EAST: 'Este',\n    WEST: 'Oeste'\n};\n\nmodule.exports = TOKEN_NAMES;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/gobstones-tokens-en.js\n ** module id = 4\n ** module chunks = 0\n **/","var Context = require('./execution-context');\n\nvar Statement = {\n    arity: 'statement'\n};\n\nfunction interpretBlock(block, context) {\n    block = block || [];\n    for (var i = 0; i < block.length; i++) {\n        block[i].interpret(context);\n    }\n}\n\nfunction fillParameters(context, parameters, declaration) {\n    for (var i = 0; i < declaration.parameters.length; i++) {\n        context.put(declaration.parameters[i].value, parameters[i].eval(context));\n    }\n}\n\nvar behaviours = {\n    conditional: function (condition, left, right) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'conditional';\n        stmt.condition = condition;\n        stmt.left = left;\n        stmt.right = right;\n        stmt.interpret = function (context) {\n            interpretBlock(condition.eval(context) ? left : right, context);\n            return context;\n        };\n        return stmt;\n    },\n    literal: function () {\n        return function () {\n            var self = this;\n            this.eval = function () {\n                return self.value;\n            };\n            return this;\n        };\n    },\n    variable: function () {\n        return function () {\n            var self = this;\n            this.eval = function (context) {\n                return context.get(self.value);\n            };\n            return this;\n        };\n    },\n    conditionalRepetition: function (condition, body) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'while';\n        stmt.expression = condition;\n        stmt.body = body;\n        stmt.interpret = function (context) {\n            while (condition.eval(context)) {\n                interpretBlock(body, context);\n            }\n            return context;\n        };\n        return stmt;\n    },\n    numericRepetition: function (numericExpression, body) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'repeat';\n        stmt.expression = numericExpression;\n        stmt.body = body;\n        stmt.interpret = function (context) {\n            var times = numericExpression.eval(context);\n            for (var i = 0; i <= times; i++) {\n                interpretBlock(body, context);\n            }\n            return context;\n        };\n        return stmt;\n    },\n    assignment: function (left, right) {\n        var stmt = Object.create(Statement);\n        stmt.alias = ':=';\n        stmt.arity = 'binary';\n        stmt.variable = left;\n        stmt.expression = right;\n        stmt.assignment = true;\n        stmt.interpret = function (context) {\n            context.put(left.value, right.eval(context));\n        };\n        return stmt;\n    },\n    switch: function (condition, cases) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'switch';\n        stmt.value = condition;\n        stmt.cases = cases;\n        stmt.interpret = function (context) {\n            var value = condition.eval(context);\n            \n            for (var i = 0; i < cases.length; i++) {\n                console.log(value, \"   ---   \",cases[i].case.eval(context), value == cases[i].case.eval(context), value === cases[i].case.eval(context));\n                if (cases[i].case.eval(context) === value) {\n                    console.log(cases[i].body, \" <<<<<< \");\n                    interpretBlock(cases[i].body, context);\n                }\n            }\n            return context;\n        };\n        return stmt;\n    },\n    procedureCall: function (name, declaration, parameters) {\n        var stmt = Object.create(Statement);\n        stmt.arity = 'routine';\n        stmt.alias = 'ProcedureCall';\n        stmt.name = name;\n        stmt.parameters = parameters;\n\n        stmt.interpret = function (context) {\n            context.startContext();\n            fillParameters(context, parameters, declaration);\n            interpretBlock(declaration.body, context);\n            context.stopContext();\n            return context;\n        };\n        return stmt;\n    },\n    functionCall: function (name, declarationProvider, parameters) {\n        var stmt = {};\n        stmt.alias = 'functionCall';\n        stmt.name = name;\n        stmt.eval = function (context) {\n            var declaration = declarationProvider();\n            context.startContext();\n            context.pushBoard();\n            if (declaration.parameters) {\n                fillParameters(context, parameters, declaration);\n            }\n            interpretBlock(declaration.body, context);\n            var result = declaration.return.eval(context);\n            context.popBoard();\n            context.stopContext();\n            return result;\n        };\n        return stmt;\n    },\n    putStone: function (expression) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'PutStone';\n        stmt.color = expression;\n        stmt.interpret = function (context) {\n            context.board().putStone(expression.eval(context));\n            return context;\n        };\n        return stmt;\n    },\n    negation: function(expression) {\n        var exp = {arity: 'unary'};\n        exp.alias = 'not';\n        exp.expression = expression;\n        exp.eval = function (context) {\n            return !expression.eval(context);\n        };\n        return this;\n    },\n    removeStone: function (expression) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'RemoveStone';\n        stmt.parameters = [expression];\n        stmt.interpret = function (context) {\n            context.board().removeStone(expression.eval(context));\n            return context;\n        };\n        return stmt;\n    },\n    moveClaw: function (expression) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'MoveClaw';\n        stmt.paramters = [expression];\n        stmt.interpret = function (context) {\n            context.board().move(expression.eval(context));\n            return context;\n        };\n        return stmt;\n    },\n    hasStone: function (expression) {\n        var fun = {};\n        fun.eval = function (context) {\n            return context.board().hasStone(expression.eval(context));\n        };\n        return fun;\n    },\n    canMove: function (expression) {\n        var fun = {};\n        fun.eval = function (context) {\n            return context.board().canMove(expression.eval(context));\n        };\n        return fun;\n    },\n    programDeclaration: function (body) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'program';\n        stmt.body = body;\n        stmt.interpret = function (context) {\n            interpretBlock(body, context);\n            return context;\n        };\n        return stmt;\n    },\n    procedureDeclaration: function (token, parameters, body) {\n        token.name = token.value;\n        token.arity = 'routine';\n        token.alias = 'procedureDeclaration';\n        token.parameters = parameters;\n        token.body = body;\n        token.interpret = function (context) {\n            return context;\n        };\n        return token;\n    },\n    functionDeclaration: function (token, parameters, body, returnExpression) {\n        token.interpret = function (context) {\n            return context;\n        };\n        token.name = token.value;\n        token.arity = 'routine';\n        token.alias = 'functionDeclaration';\n        token.parameters = parameters;\n        token.body = body;\n        token.return = returnExpression;\n        return token;\n    },\n    rootProgram: function (grammar) {\n        grammar.interpret = function (root, context) {\n            var main;\n            var declarations = [];\n            context = context || new Context();\n            for (var i = 0; i < root.length; i++) {\n                if (root[i].alias === 'program') {\n                    main = root[i];\n                } else {\n                    declarations.push(root[i]);\n                }\n            }\n            interpretBlock(declarations, context);\n            main.interpret(context);\n        };\n        return grammar;\n    }\n};\n\nmodule.exports = behaviours;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/interpreter.js\n ** module id = 5\n ** module chunks = 0\n **/","var Board = require('./model');\n\nvar Context = function () {\n    var variablesStack = [];\n    var boardsStack = [];\n    var currentBoard = new Board(9, 9);\n    var currentVariables = {};\n\n    this.init = function () {\n        currentBoard.init();\n    };\n\n    this.board = function () {\n        return currentBoard;\n    };\n\n    this.put = function (key, value) {\n        console.log('VARIABLE SET: ', key, '   ', value);\n        currentVariables[key] = value;\n    };\n\n    this.get = function (id) {\n        return currentVariables[id];\n    };\n\n    this.all = function () {\n        return currentVariables;\n    };\n\n    this.startContext = function () {\n        variablesStack.push(currentVariables);\n        currentVariables = {};\n    };\n\n    this.stopContext = function () {\n        currentVariables = variablesStack.pop();\n    };\n\n    this.pushBoard = function () {\n        boardsStack.push(currentBoard);\n        currentBoard = currentBoard.clone();\n    };\n\n    this.popBoard = function () {\n        currentBoard = boardsStack.pop();\n    };\n\n    this.init();\n};\n\nmodule.exports = Context;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/execution-context.js\n ** module id = 6\n ** module chunks = 0\n **/","function Board(sizeX, sizeY) {\n    this.x = 0;\n    this.y = 0;\n\n    this.sizeX = sizeX;\n    this.sizeY = sizeY;\n}\n\nBoard.blue = 0;\nBoard.red = 1;\nBoard.black = 2;\nBoard.green = 3;\n\nBoard.prototype.init = function () {\n    this.table = [[], [], [], []];\n    for (var i = 0; i < this.sizeX; i++) {\n        this.table[0][i] = [];\n        this.table[1][i] = [];\n        this.table[2][i] = [];\n        this.table[3][i] = [];\n        for (var j = 0; j < this.sizeY; j++) {\n            this.table[0][i][j] = 0;\n            this.table[1][i][j] = 0;\n            this.table[2][i][j] = 0;\n            this.table[3][i][j] = 0;\n        }\n    }\n};\n\nBoard.prototype.clone = function () {\n    var c = new Board(this.sizeX, this.sizeY);\n    c.init();\n    for (var i = 0; i < this.table.length; i++) {\n        c.table[i] = this.table[i].slice();\n    }\n    c.x = this.x;\n    c.y = this.y;\n    return c;\n};\n\nBoard.prototype.putStone = function (color) {\n    this.table[color][this.x][this.y] += 1;\n};\n\nBoard.prototype.removeStone = function (color) {\n    this.table[color][this.x][this.y] -= 1;\n};\n\nBoard.prototype.hasStone = function (color) {\n    return this.table[color][this.x][this.y];\n};\n\nBoard.prototype.canMove = function (vec) {\n    var nextX = this.x + vec[0];\n    var nextY = this.y + vec[1];\n    return nextX < this.sizeX && nextX >= 0 && nextY < this.sizeY && nextY >= 0;\n};\n\nBoard.prototype.move = function (vec) {\n    this.x += vec[0];\n    this.y += vec[1];\n};\n\nBoard.prototype.printAscii = function () {\n    var out = this.sizeX + 'x' + this.sizeY + '\\n';\n    var az = this.table[0];\n    var ro = this.table[1];\n    var ne = this.table[2];\n    var ve = this.table[3];\n    for (var j = this.sizeY - 1; j >= 0; j--) {\n        for (var i = 0; i < this.sizeX; i++) {\n            out += (az[i][j] || ro[i][j] || ne[i][j] || ve[i][j]) ? '#' : '.';\n        }\n        out += '\\n';\n    }\n    return out;\n};\n\nmodule.exports = Board;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/model.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}