{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.umd.min.js","webpack:///webpack/bootstrap 419180ba5493e0a1ed6f","webpack:///./lib/gbs.js","webpack:///./lib/utils/errors.js","webpack:///./lib/grammar/grammar.js","webpack:///./lib/grammar/parser.js","webpack:///./lib/grammar/reserved-words.js","webpack:///./lib/grammar/scope.js","webpack:///./lib/lexer/lexer.js","webpack:///./lib/nodes/assignment.js","webpack:///./lib/nodes/binary-operations.js","webpack:///./lib/nodes/conditional-statements.js","webpack:///./lib/nodes/constant.js","webpack:///./lib/nodes/literals.js","webpack:///./lib/nodes/nodes.js","webpack:///./lib/nodes/primitive-functions.js","webpack:///./lib/nodes/primitive-procedures.js","webpack:///./lib/nodes/program-root.js","webpack:///./lib/nodes/repetition-statements.js","webpack:///./lib/nodes/routine-calls.js","webpack:///./lib/nodes/routine-declarations.js","webpack:///./lib/nodes/unary-operations.js","webpack:///./lib/nodes/variable.js","webpack:///./lib/utils/logger.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","gbs","Parser","Lexer","node","errors","grammar","log","throwParserError","token","description","someError","error","on","throwInterpreterError","message","InterpreterException","prototype","Error","TOKEN_NAMES","commaSeparatedArguments","parser","parameters","push","expression","advance","parameterListCall","parameterDeclarationList","g","arity","parenthesisExpression","bodyStatement","block","bodyStatementWithOptionalMultiline","statement","defineConstant","symbol","alias","value","type","nud","Constant","NumericLiteral","Variable","op","OrOperation","AndOperation","SumOperation","DiffOperation","MulOperation","DIV","DivOperation","MOD","ModOperation","infixr","left","ExpOperation","prefix","NOT","NotOperation","SubstractionOperation","EqOperation","NotEqualOperation","LessOperation","GraterOperation","LessEqualOperation","GreaterEqualOperation","FALSE","BOOLEAN","TRUE","BLUE","COLOR","RED","BLACK","GREEN","NORTH","DIRECTION","SOUTH","EAST","WEST","IN","ELSE","TO","separator","stmt","infix","toUpperCase","ProcedureCall","scope","find","FunctionCall","Assignment","DROP","PutStone","GRAB","RemoveStone","MOVE","MoveClaw","MOVE_TO_EDGE","MoveToEdge","CLEAN_BOARD","CleanBoard","BOOM","Boom","HAS_STONES","HasStones","NUM_STONES","NumStones","MAX_COLOR","MaxColor","MIN_COLOR","MinColor","MAX_DIR","MaxDir","MIN_DIR","MinDir","MAX_BOOL","MaxBool","MIN_BOOL","MinBool","CAN_MOVE","CanMove","IF","condition","trueBranch","falseBranch","reserve","If","SWITCH","cases","exp","body","case","tokens","hasNext","Switch","WHILE","While","REPEAT","Repeat","FOR_EACH","iterator","rangeLeft","rangeRight","ForEach","a","statements","PROGRAM","Program","FUNCTION","newScope","toLowerCase","ret","pop","RETURN","declaration","FunctionDeclaration","ReturnStatement","PROCEDURE","ProcedureDeclaration","parse","input","main","declarations","roots","parseProgram","i","length","Root","throwUndefinedSymbolError","throwMissingOperatorError","Scope","OriginalSymbol","led","lexer","symbolTable","bindingPower","s","lbp","rightBindingPower","t","parent","o","v","lastToken","range","start","lastRange","next","parseInt","Object","create","bp","OpDefinition","n","std","statementsList","_currentRange","_applyRangeToSymbol","end","rootDeclaration","f","x","self","right","_parseContextAwareNode","nodeParser","parseExpression","parseStatements","THEN","OPPOSITE","NEXT","PREVIOUS","NUMBER","itself","def","identifier","reserved","name","targetToken","e","suffix","from","startColumn","endColumn","row","punctuators","buf","buflen","_isNewline","_isDigit","_isAlpha","_isAlphanum","_skipNonTokens","current","nextChar","TokenTypes","IDENTIFIER","OPERATOR","EOF","COMMENT","NEWLINE","_refreshCurrentAndNextChars","_processComment","_processIdentifier","_consume","_processOperator","_processNumber","_processError","_make","column","text","substring","newToken","charAt","indexOf","_increaseFrom","_processMultiCharOperator","_incrementStep","_resetColumnCount","chars","_processSingleLineComment","_processMultiLineComment","constants","STM","interpret","context","put","eval","defineBinaryOperation","className","BinaryOperation","BINARY","Math","floor","pow","interpretBlock","EXPRESSION","board","amountStones","canMove","nativeRepresentations","minDir","maxDir","maxColor","minColor","move","err","removeStone","putStone","moveToEdge","clear","boom","program","values","items","north","east","south","west","blue","red","black","green","evalArguments","results","fillParameters","declarationProvider","target","parameterValues","startContext","stopContext","pushBoard","result","return","popBoard","returnExpression","get","doNothing","console"],"mappings":"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","file":"index.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gsWeblangCore\"] = factory();\n\telse\n\t\troot[\"gsWeblangCore\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gsWeblangCore\"] = factory();\n\telse\n\t\troot[\"gsWeblangCore\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar gbs = {};\n\t\n\tgbs.Parser = __webpack_require__(3);\n\tgbs.Lexer = __webpack_require__(6);\n\tgbs.node = __webpack_require__(12);\n\tgbs.errors = __webpack_require__(1);\n\t\n\tvar grammar = __webpack_require__(2)(gbs);\n\t\n\tmodule.exports = grammar;\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar log = __webpack_require__(21);\n\t\n\tvar errors = {};\n\t\n\terrors.throwParserError = function (token, description) {\n\t    var someError = {error: description, on: token};\n\t    log('PARSER ERROR: ', someError);\n\t    throw someError;\n\t};\n\t\n\terrors.throwInterpreterError = function (token, message) {\n\t    throw new errors.InterpreterException(message, token);\n\t};\n\t\n\terrors.InterpreterException = function (message, on) {\n\t    this.message = message;\n\t    this.on = on;\n\t};\n\terrors.InterpreterException.prototype = new Error();\n\t\n\tmodule.exports = errors;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar TOKEN_NAMES = __webpack_require__(4);\n\t\n\tmodule.exports = function (gbs) {\n\t    var g = new gbs.Parser(new gbs.Lexer());\n\t    var define = g;\n\t\n\t    function commaSeparatedArguments(parser) {\n\t        var parameters = [];\n\t        if (parser.token.id !== ')') {\n\t            for (; ;) {\n\t                parameters.push(parser.expression(0));\n\t                if (parser.token.id !== ',') {\n\t                    break;\n\t                }\n\t                parser.advance(',');\n\t            }\n\t        }\n\t        return parameters;\n\t    }\n\t\n\t    function parameterListCall(parser) {\n\t        parser.advance('(');\n\t        var parameters = commaSeparatedArguments(parser);\n\t        parser.advance(')');\n\t        return parameters;\n\t    }\n\t\n\t    function parameterDeclarationList() {\n\t        var parameters = [];\n\t        g.advance('(');\n\t        if (g.token.id !== ')') {\n\t            for (; ;) {\n\t                if (g.token.arity !== 'name') {\n\t                    g.error(g.token, 'Se esperaba un nombre de parámetro.');\n\t                }\n\t                parameters.push(g.token);\n\t                g.advance();\n\t                if (g.token.id !== ',') {\n\t                    break;\n\t                }\n\t                g.advance(',');\n\t            }\n\t        }\n\t        g.advance(')');\n\t        return parameters;\n\t    }\n\t\n\t    function parenthesisExpression() {\n\t        g.advance('(');\n\t        var p = g.expression(0);\n\t        g.advance(')');\n\t        return p;\n\t    }\n\t\n\t    function bodyStatement() {\n\t        return g.block() || [];\n\t    }\n\t\n\t    function bodyStatementWithOptionalMultiline() {\n\t        return (g.token.id === '{') ? bodyStatement() : [g.statement()];\n\t    }\n\t\n\t    function defineConstant(symbol, alias, value, type) {\n\t        var token = g.symbol(symbol);\n\t        token.nud = function () {\n\t            return new gbs.node.Constant(token, alias, value, type);\n\t        };\n\t    }\n\t\n\t    define.symbol('(end)');\n\t    define.symbol('(literal)').nud = function () {\n\t        return new gbs.node.NumericLiteral(this, this.value);\n\t    };\n\t\n\t    define.symbol('(name)').nud = function () {\n\t        return new gbs.node.Variable(this, this.value);\n\t    };\n\t\n\t    define.op('||', 20, gbs.node.OrOperation);\n\t    define.op('&&', 25, gbs.node.AndOperation);\n\t\n\t    define.op('+', 50, gbs.node.SumOperation);\n\t    define.op('-', 50, gbs.node.DiffOperation);\n\t    define.op('*', 60, gbs.node.MulOperation);\n\t    // TODO: chequear que efectivamente sean no asociativos\n\t    define.op(TOKEN_NAMES.DIV, 70, gbs.node.DivOperation);\n\t    define.op(TOKEN_NAMES.MOD, 70, gbs.node.ModOperation);\n\t\n\t    define.infixr('^', 80, function (left) {\n\t        return new gbs.node.ExpOperation(g.token, left, g.expression(80));\n\t    });\n\t    // TODO: chequear cómo se comporta el NOT\n\t    define.prefix(TOKEN_NAMES.NOT, function () {\n\t        return new gbs.node.NotOperation(g.token, g.expression(70));\n\t    });\n\t    define.prefix('-', function () {\n\t        return new gbs.node.SubstractionOperation(g.token, g.expression(70));\n\t    });\n\t\n\t    define.op('==', 40, gbs.node.EqOperation);\n\t    define.op('/=', 40, gbs.node.NotEqualOperation);\n\t    define.op('<', 40, gbs.node.LessOperation);\n\t    define.op('>', 40, gbs.node.GraterOperation);\n\t    define.op('<=', 40, gbs.node.LessEqualOperation);\n\t    define.op('>=', 40, gbs.node.GreaterEqualOperation);\n\t\n\t    defineConstant(TOKEN_NAMES.FALSE, 'False', false, TOKEN_NAMES.BOOLEAN);\n\t    defineConstant(TOKEN_NAMES.TRUE, 'True', true, TOKEN_NAMES.BOOLEAN);\n\t    defineConstant(TOKEN_NAMES.BLUE, 'Blue', 0, TOKEN_NAMES.COLOR);\n\t    defineConstant(TOKEN_NAMES.RED, 'Red', 1, TOKEN_NAMES.COLOR);\n\t    defineConstant(TOKEN_NAMES.BLACK, 'Black', 2, TOKEN_NAMES.COLOR);\n\t    defineConstant(TOKEN_NAMES.GREEN, 'Green', 3, TOKEN_NAMES.COLOR);\n\t    defineConstant(TOKEN_NAMES.NORTH, 'North', [0, 1], TOKEN_NAMES.DIRECTION);\n\t    defineConstant(TOKEN_NAMES.SOUTH, 'South', [0, -1], TOKEN_NAMES.DIRECTION);\n\t    defineConstant(TOKEN_NAMES.EAST, 'East', [1, 0], TOKEN_NAMES.DIRECTION);\n\t    defineConstant(TOKEN_NAMES.WEST, 'West', [-1, 0], TOKEN_NAMES.DIRECTION);\n\t\n\t    define.symbol(':');\n\t    define.symbol(')');\n\t    define.symbol('(');\n\t    define.symbol('[');\n\t    define.symbol(']');\n\t    define.symbol('}');\n\t    define.symbol(',');\n\t    define.symbol('->');\n\t    define.symbol('..');\n\t    define.symbol(TOKEN_NAMES.IN);\n\t    define.symbol(TOKEN_NAMES.ELSE);\n\t    define.symbol(TOKEN_NAMES.TO);\n\t\n\t    var separator = {separator: ';'};\n\t    define.stmt(';', function () {\n\t        return separator;\n\t    });\n\t\n\t    define.infix('(', 80, function (left) {\n\t        if (left.token.arity !== 'name') {\n\t            gbs.errors.throwParserError(left, left.token.value + ' no es una función o procedimiento');\n\t        }\n\t        var parameters = commaSeparatedArguments(g);\n\t        g.advance(')');\n\t        var node;\n\t        if (left.token.value[0].toUpperCase() === left.token.value[0]) {\n\t            node = new gbs.node.ProcedureCall(left.token, function () {\n\t                return g.scope.find(left.token.value);\n\t            }, parameters);\n\t        } else {\n\t            node = new gbs.node.FunctionCall(left.token, function () {\n\t                return g.scope.find(left.token.value);\n\t            }, parameters);\n\t        }\n\t        return node;\n\t    });\n\t\n\t    define.infixr(':=', 10, function (left) {\n\t        if (left.id !== '.' && left.id !== '[' && (!left.token || left.token.arity !== 'name')) {\n\t            g.error(left, 'Del lado izquierdo de la asignación sólo pueden usarse identificadores');\n\t        }\n\t        return new gbs.node.Assignment({}, left, g.expression(9));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.DROP, function () {\n\t        return new gbs.node.PutStone(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.GRAB, function () {\n\t        return new gbs.node.RemoveStone(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.MOVE, function () {\n\t        return new gbs.node.MoveClaw(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.MOVE_TO_EDGE, function () {\n\t        return new gbs.node.MoveToEdge(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.CLEAN_BOARD, function () {\n\t        return new gbs.node.CleanBoard(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.BOOM, function () {\n\t        var token = g.token;\n\t        if (parenthesisExpression(g)) {\n\t            gbs.errors.throwParserError(token, 'BOOM no lleva parámetros');\n\t        }\n\t        return new gbs.node.Boom(token);\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.HAS_STONES, function () {\n\t        return new gbs.node.HasStones(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.NUM_STONES, function () {\n\t        return new gbs.node.NumStones(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.MAX_COLOR, function () {\n\t        return new gbs.node.MaxColor(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.MIN_COLOR, function () {\n\t        return new gbs.node.MinColor(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.MAX_DIR, function () {\n\t        return new gbs.node.MaxDir(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.MIN_DIR, function () {\n\t        return new gbs.node.MinDir(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.MAX_BOOL, function () {\n\t        return new gbs.node.MaxBool(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.MIN_BOOL, function () {\n\t        return new gbs.node.MinBool(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.CAN_MOVE, function () {\n\t        var id = g.token;\n\t        var parameters = parameterListCall(g);\n\t        return new gbs.node.CanMove(id, parameters);\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.IF, function () {\n\t        var token = g.token;\n\t        g.advance('(');\n\t        var condition = g.expression(0);\n\t        g.advance(')');\n\t        var trueBranch = bodyStatement(g);\n\t        var falseBranch = null;\n\t        if (g.token.id === TOKEN_NAMES.ELSE) {\n\t            g.scope.reserve(g.token);\n\t            g.advance(TOKEN_NAMES.ELSE);\n\t            falseBranch = bodyStatement(g);\n\t        }\n\t        return new gbs.node.If(token, condition, trueBranch, falseBranch);\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.SWITCH, function () {\n\t        var token = g.token;\n\t        var condition = parenthesisExpression(g);\n\t        if (g.token.id === TOKEN_NAMES.TO) {\n\t            g.advance(TOKEN_NAMES.TO);\n\t        }\n\t        g.advance('{');\n\t        var cases = [];\n\t        for (; ;) {\n\t            var exp = g.expression(0);\n\t            g.advance('->');\n\t            var body = bodyStatementWithOptionalMultiline(g);\n\t            cases.push({\n\t                case: exp,\n\t                body: body\n\t            });\n\t            if (g.token.id === '}' || !g.tokens.hasNext()) {\n\t                break;\n\t            }\n\t        }\n\t        g.advance('}');\n\t        return new gbs.node.Switch(token, condition, cases);\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.WHILE, function () {\n\t        return new gbs.node.While(g.token, parenthesisExpression(g), bodyStatement(g));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.REPEAT, function () {\n\t        return new gbs.node.Repeat(g.token, parenthesisExpression(g), bodyStatement(g));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.FOR_EACH, function () {\n\t        // foreach dir in [minDir() .. maxDir()]\n\t        var iterator = g.expression();\n\t        if (iterator.token.arity !== 'name') {\n\t            g.error(iterator.token, 'El foreach espera un identificador sobre el cual iterar');\n\t        }\n\t        g.advance(TOKEN_NAMES.IN);\n\t        g.advance('[');\n\t        var rangeLeft = g.expression();\n\t        g.advance('..');\n\t        var rangeRight = g.expression();\n\t        g.advance(']');\n\t        return new gbs.node.ForEach(g.token, iterator, rangeLeft, rangeRight, g.block());\n\t    });\n\t\n\t    define.stmt('{', function () {\n\t        var a = g.statements();\n\t        g.advance('}');\n\t        return a;\n\t    });\n\t\n\t    define.stmt('(', function () {\n\t        var a = g.statements();\n\t        g.advance(')');\n\t        return a;\n\t    });\n\t\n\t    define.prefix('(', function () {\n\t        var expression = g.expression(0);\n\t        g.advance(')');\n\t        return expression;\n\t    });\n\t\n\t    define.root(TOKEN_NAMES.PROGRAM, function () {\n\t        return new gbs.node.Program(g.token, g.block());\n\t    });\n\t\n\t    define.root(TOKEN_NAMES.FUNCTION, function () {\n\t        g.newScope();\n\t        var token = g.token;\n\t        if (g.token.arity === 'name') {\n\t            if (g.token.value[0] !== g.token.value[0].toLowerCase()) {\n\t                g.error(token, 'El nombre de la función ' + token.value + ' debe emepzar con minúscula');\n\t            }\n\t            g.scope.define(token);\n\t            g.advance();\n\t        } else {\n\t            g.error(token, 'Se esperaba un nombre de función');\n\t        }\n\t        var parameters = parameterDeclarationList(g);\n\t        var body = bodyStatement(g);\n\t\n\t        var ret = body.pop();\n\t        if (!ret || ret.alias !== 'return' || !ret.expression) {\n\t            g.error(token, 'La función ' + token.value + ' debe terminar con un ' + TOKEN_NAMES.RETURN);\n\t        }\n\t        g.scope.pop();\n\t        var declaration = new gbs.node.FunctionDeclaration(token, parameters, body, ret);\n\t        token.declaration = declaration;\n\t        return declaration;\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.RETURN, function () {\n\t        return new gbs.node.ReturnStatement(g.token, parenthesisExpression(g));\n\t    });\n\t\n\t    define.root(TOKEN_NAMES.PROCEDURE, function () {\n\t        g.newScope();\n\t        var token = g.token;\n\t        if (g.token.arity === 'name') {\n\t            if (g.token.value[0] !== g.token.value[0].toUpperCase()) {\n\t                g.error(token, 'El nombre del procedimiento ' + token.value + ' debe emepzar con mayúscula');\n\t            }\n\t            g.scope.define(token);\n\t            g.advance();\n\t        } else {\n\t            g.error(token, 'Se esperaba un nombre de procedimiento');\n\t        }\n\t        var parameters = parameterDeclarationList(g);\n\t        var body = bodyStatement();\n\t        g.scope.pop();\n\t        var declaration = new gbs.node.ProcedureDeclaration(token, parameters, body);\n\t        token.declaration = declaration;\n\t        return declaration;\n\t    });\n\t\n\t    define.parse = function (input) {\n\t        var main;\n\t        var declarations = [];\n\t        var roots = g.parseProgram(input);\n\t        for (var i = 0; i < roots.length; i++) {\n\t            if (roots[i].alias === 'program') {\n\t                main = roots[i];\n\t            } else {\n\t                declarations.push(roots[i]);\n\t            }\n\t        }\n\t        return new gbs.node.Root(main, declarations);\n\t    };\n\t\n\t    return g;\n\t};\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar errors = __webpack_require__(1);\n\tvar Scope = __webpack_require__(5);\n\t\n\tfunction throwUndefinedSymbolError() {\n\t    errors.throwParserError(this, 'No definido');\n\t}\n\t\n\tfunction throwMissingOperatorError() {\n\t    errors.throwParserError(this, 'No se encontró el operador');\n\t}\n\t\n\tvar OriginalSymbol = function () {\n\t    this.nud = throwUndefinedSymbolError;\n\t    this.led = throwMissingOperatorError;\n\t};\n\t\n\tvar Parser = function (lexer) {\n\t    this.scope = null;\n\t    this.token = null;\n\t    this.tokens = lexer;\n\t    this.symbolTable = {};\n\t};\n\t\n\tParser.prototype.symbol = function (id, bindingPower) {\n\t    var s = this.symbolTable[id];\n\t    bindingPower = bindingPower || 0;\n\t    if (s) {\n\t        if (bindingPower > s.lbp) {\n\t            s.lbp = bindingPower;\n\t        }\n\t    } else {\n\t        s = new OriginalSymbol();\n\t        s.id = s.value = id;\n\t        s.lbp = bindingPower;\n\t        this.symbolTable[id] = s;\n\t    }\n\t    return s;\n\t};\n\t\n\tParser.prototype.expression = function (rightBindingPower) {\n\t    rightBindingPower = rightBindingPower || 0;\n\t    var left;\n\t    var t = this.token;\n\t    this.advance();\n\t    left = t.nud();\n\t    while (rightBindingPower < this.token.lbp) {\n\t        t = this.token;\n\t        this.advance();\n\t        left = t.led(left);\n\t    }\n\t    return left;\n\t};\n\t\n\tParser.prototype.error = function (token, message) {\n\t    errors.throwParserError(token, message);\n\t};\n\t\n\tParser.prototype.newScope = function () {\n\t    var s = this.scope;\n\t    this.scope = new Scope(this);\n\t    this.scope.parent = s;\n\t    return this.scope;\n\t};\n\t\n\tParser.prototype.advance = function (id) {\n\t    var a;\n\t    var o;\n\t    var t;\n\t    var v;\n\t    var tokens = this.tokens;\n\t    if (id && this.token.id !== id) {\n\t        if (this.lastToken && this.lastToken.range && this.token.range) {\n\t            this.token.range.start = this.lastToken.range.start;\n\t        }\n\t        errors.throwParserError(this.token, 'Se esperaba \"' + id + '\" pero se encontró \"' + this.token.value + '\"');\n\t    }\n\t    if (!tokens.hasNext()) {\n\t        var lastRange = this.token.range;\n\t        this.token = this.symbolTable['(end)'];\n\t        this.token.range = lastRange;\n\t        return this.token;\n\t    }\n\t    t = tokens.next();\n\t    v = t.value;\n\t    a = t.type;\n\t    if (a === 'name') {\n\t        o = this.scope.find(v);\n\t        if (o.arity === 'routine') {\n\t            // force late binding\n\t            o = this.symbolTable['(name)'];\n\t        }\n\t    } else if (a === 'operator') {\n\t        o = this.symbolTable[v];\n\t        if (!o) {\n\t            errors.throwParserError(t, 'Unknown operator.');\n\t        }\n\t    } else if (a === 'number') {\n\t        o = this.symbolTable['(literal)'];\n\t        a = 'literal';\n\t        v = parseInt(v, 10);\n\t    } else {\n\t        errors.throwParserError(t, 'Unexpected token.');\n\t    }\n\t\n\t    var token = Object.create(o);\n\t    token.range = t.range;\n\t    token.value = v;\n\t    token.arity = a;\n\t    this.lastToken = this.token;\n\t    this.token = token;\n\t    return token;\n\t};\n\t\n\tParser.prototype.op = function (id, bp, OpDefinition) {\n\t    var parser = this;\n\t    var s = this.symbol(id, bp);\n\t    s.led = function (left) {\n\t        return new OpDefinition(this, left, parser.expression(bp));\n\t    };\n\t    return s;\n\t};\n\t\n\tParser.prototype.statement = function () {\n\t    var n = this.token;\n\t    var v;\n\t    if (n.std) {\n\t        this.advance();\n\t        this.scope.reserve(n);\n\t        return n.std();\n\t    }\n\t    v = this.expression(0);\n\t    if (v.alias !== ':=' && v.id !== '(' && v.arity !== 'routine') {\n\t        errors.throwParserError(v, 'Bad expression statement.');\n\t    }\n\t    return v;\n\t};\n\t\n\tParser.prototype.statements = function () {\n\t    var statementsList = [];\n\t    var symbol;\n\t    for (; ;) {\n\t        if (this.token.id === '}' || this.token.id === '(end)') {\n\t            break;\n\t        }\n\t        var range = this._currentRange();\n\t        symbol = this.statement();\n\t        if (symbol && !symbol.separator) {\n\t            this._applyRangeToSymbol(range, symbol);\n\t            statementsList.push(symbol);\n\t        }\n\t    }\n\t    if (statementsList.length === 0) {\n\t        return null;\n\t    }\n\t    return statementsList;\n\t};\n\t\n\tParser.prototype._applyRangeToSymbol = function (range, symbol) {\n\t    symbol.range = range;\n\t    if (this.token.range && this.token.range.end) {\n\t        range.end = this.token.range.end;\n\t    }\n\t};\n\t\n\tParser.prototype.rootDeclaration = function () {\n\t    var n = this.token;\n\t    if (!n.root) {\n\t        errors.throwParserError(n, 'Se esperaba una definición de programa, función o procedimiento.');\n\t    }\n\t    this.advance();\n\t    this.scope.reserve(n);\n\t    return n.root();\n\t};\n\t\n\tParser.prototype.stmt = function (symbol, f) {\n\t    var x = this.symbol(symbol);\n\t    x.std = f;\n\t    return x;\n\t};\n\t\n\tParser.prototype.infix = function (id, bp, led) {\n\t    var s = this.symbol(id, bp);\n\t    var self = this;\n\t    s.led = led || function (left) {\n\t        this.left = left;\n\t        this.right = self.expression(bp);\n\t        this.arity = 'binary';\n\t        return this;\n\t    };\n\t    return s;\n\t};\n\t\n\tParser.prototype.infixr = function (id, bp, led) {\n\t    var s = this.symbol(id, bp);\n\t    var self = this;\n\t    s.led = led || function (left) {\n\t        this.left = left;\n\t        this.right = self.expression(bp - 1);\n\t        this.arity = 'binary';\n\t        return this;\n\t    };\n\t    return s;\n\t};\n\t\n\tParser.prototype.prefix = function (id, nud) {\n\t    var s = this.symbol(id);\n\t    var self = this;\n\t    s.nud = nud || function () {\n\t        self.scope.reserve(this);\n\t        this.left = self.expression(70);\n\t        this.arity = 'unary';\n\t        return this;\n\t    };\n\t    return s;\n\t};\n\t\n\tParser.prototype.root = function (symbol, f) {\n\t    var x = this.symbol(symbol);\n\t    x.root = f;\n\t    return x;\n\t};\n\t\n\tParser.prototype.block = function () {\n\t    var t = this.token;\n\t    this.advance('{');\n\t    return t.std();\n\t};\n\t\n\tParser.prototype._currentRange = function () {\n\t    return {start: this.token.range.start, end: this.token.range.end};\n\t};\n\t\n\tParser.prototype.roots = function () {\n\t    var roots = [];\n\t    var symbol;\n\t    for (; ;) {\n\t        if (this.token.id === '(end)') {\n\t            break;\n\t        }\n\t        var range = this._currentRange();\n\t        symbol = this.rootDeclaration();\n\t        if (symbol) {\n\t            this._applyRangeToSymbol(range, symbol);\n\t            roots.push(symbol);\n\t        }\n\t    }\n\t    if (roots.length === 0) {\n\t        return null;\n\t    }\n\t    return roots;\n\t};\n\t\n\tParser.prototype._parseContextAwareNode = function (input, nodeParser) {\n\t    this.tokens.input(input);\n\t    this.newScope();\n\t    this.advance();\n\t    var s = nodeParser();\n\t    this.advance('(end)');\n\t    this.scope.pop();\n\t    return s;\n\t};\n\t\n\tParser.prototype.parseExpression = function (input) {\n\t    var self = this;\n\t    return this._parseContextAwareNode(input, function () {\n\t        return self.expression(0);\n\t    });\n\t};\n\t\n\tParser.prototype.parseProgram = function (input) {\n\t    var self = this;\n\t    return this._parseContextAwareNode(input, function () {\n\t        return self.roots();\n\t    });\n\t};\n\t\n\tParser.prototype.parseStatements = function (input) {\n\t    var self = this;\n\t    return this._parseContextAwareNode(input, function () {\n\t        return self.statements();\n\t    });\n\t};\n\t\n\tmodule.exports = Parser;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tvar TOKEN_NAMES = {\n\t    PROGRAM: 'program',\n\t    PROCEDURE: 'procedure',\n\t    FUNCTION: 'function',\n\t    RETURN: 'return',\n\t    DROP: 'Poner',\n\t    MOVE: 'Mover',\n\t    GRAB: 'Sacar',\n\t    BOOM: 'BOOM',\n\t    MOVE_TO_EDGE: 'IrAlBorde',\n\t    CLEAN_BOARD: 'VaciarTablero',\n\t    REPEAT: 'repeat',\n\t    WHILE: 'while',\n\t    FOR_EACH: 'foreach',\n\t    IN: 'in',\n\t    IF: 'if',\n\t    THEN: 'then',\n\t    ELSE: 'else',\n\t    SWITCH: 'switch',\n\t    TO: 'to',\n\t    OPPOSITE: 'opuesto',\n\t    NEXT: 'siguiente',\n\t    PREVIOUS: 'previo',\n\t    DIV: 'div',\n\t    MOD: 'mod',\n\t    NOT: 'not',\n\t    HAS_STONES: 'hayBolitas',\n\t    CAN_MOVE: 'puedeMover',\n\t    NUM_STONES: 'nroBolitas',\n\t    MIN_DIR: 'minDir',\n\t    MAX_DIR: 'maxDir',\n\t    MIN_COLOR: 'minColor',\n\t    MAX_COLOR: 'maxColor',\n\t    MIN_BOOL: 'minBool',\n\t    MAX_BOOL: 'maxBool',\n\t    RED: 'Rojo',\n\t    BLUE: 'Azul',\n\t    BLACK: 'Negro',\n\t    GREEN: 'Verde',\n\t    TRUE: 'True',\n\t    FALSE: 'False',\n\t    NORTH: 'Norte',\n\t    SOUTH: 'Sur',\n\t    EAST: 'Este',\n\t    WEST: 'Oeste',\n\t    BOOLEAN: 'Booleano',\n\t    COLOR: 'Color',\n\t    DIRECTION: 'Dirección',\n\t    NUMBER: 'Número'\n\t};\n\t\n\tmodule.exports = TOKEN_NAMES;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar errors = __webpack_require__(1);\n\t\n\tfunction itself() {\n\t    return this;\n\t}\n\t\n\tvar Scope = function (parser) {\n\t    this.parser = parser;\n\t    this.def = {};\n\t};\n\t\n\tScope.prototype.define = function (identifier) {\n\t    var t = this.def[identifier.value];\n\t    if (typeof t === 'object') {\n\t        errors.throwParserError(identifier, t.reserved ? 'Already reserved.' : 'Already defined.');\n\t    }\n\t    this.def[identifier.value] = identifier;\n\t    identifier.reserved = false;\n\t    identifier.nud = itself;\n\t    identifier.led = null;\n\t    identifier.std = null;\n\t    identifier.lbp = 0;\n\t    identifier.scope = this.parser.scope;\n\t    return identifier;\n\t};\n\t\n\tScope.prototype.find = function (name) {\n\t    var e = this;\n\t    var targetToken;\n\t    for (; ;) {\n\t        targetToken = e.def[name];\n\t        if (targetToken && typeof targetToken !== 'function') {\n\t            return e.def[name];\n\t        }\n\t        e = e.parent;\n\t        if (!e) {\n\t            targetToken = this.parser.symbolTable[name];\n\t            return targetToken && typeof targetToken !== 'function' ? targetToken : this.parser.symbolTable['(name)'];\n\t        }\n\t    }\n\t};\n\t\n\tScope.prototype.pop = function () {\n\t    this.scope = this.parent;\n\t};\n\t\n\tScope.prototype.reserve = function (name) {\n\t    if (name.arity !== 'name' || name.reserved) {\n\t        return;\n\t    }\n\t    var t = this.def[name.value];\n\t    if (t) {\n\t        if (t.reserved) {\n\t            return;\n\t        }\n\t        if (t.arity === 'name') {\n\t            name.error('Already defined.');\n\t        }\n\t    }\n\t    this.def[name.value] = name;\n\t    name.reserved = true;\n\t};\n\t\n\tmodule.exports = Scope;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tfunction Lexer(prefix, suffix) {\n\t    // Current reading position\n\t    this.from = 0;\n\t    this.startColumn = 0;\n\t    this.endColumn = 0;\n\t    this.row = 0;\n\t    this.prefix = prefix || '/=-<>:|&.';\n\t    this.suffix = suffix || '=|&>.';\n\t\n\t    this.punctuators = '/+-*^.:|&;,()<>{}[]=';\n\t\n\t    // Look ahead position\n\t    this.i = 0;\n\t\n\t    this.buf = null;\n\t    this.buflen = 0;\n\t}\n\t\n\tLexer.prototype.hasNext = function () {\n\t    this._skipNonTokens();\n\t    return this.from < this.buflen;\n\t};\n\t\n\tLexer.prototype.input = function (buf) {\n\t    this.from = 0;\n\t    this.i = 0;\n\t    this.startColumn = 0;\n\t    this.endColumn = 0;\n\t    this.row = 0;\n\t    this.buf = buf;\n\t    this.buflen = buf.length;\n\t    this.current = null;\n\t    this.nextChar = null;\n\t};\n\t\n\tvar TokenTypes = {\n\t    IDENTIFIER: 'name',\n\t    OPERATOR: 'operator',\n\t    EOF: 'eof',\n\t    COMMENT: 'comment',\n\t    NUMBER: 'number',\n\t    NEWLINE: 'newline'\n\t};\n\t\n\t/**\n\t * This method is highly procedural for performance reasons.\n\t * There is no need for the lexer to be too flexible, since the\n\t * semantics will be associated to identifiers on the parser.\n\t *\n\t * @returns Token. The next token on the buffer, or null if the buffer is empty.\n\t */\n\tLexer.prototype.next = function () {\n\t    do {\n\t        this._skipNonTokens();\n\t        this._refreshCurrentAndNextChars();\n\t\n\t        if (this.from >= this.buflen) {\n\t            return null;\n\t        }\n\t    } while (this._processComment());\n\t\n\t    // Always add cases in descending order of occurrence probability\n\t    if (this._processIdentifier()) {\n\t        return this._consume(TokenTypes.IDENTIFIER);\n\t    } else if (this._processOperator()) {\n\t        return this._consume(TokenTypes.OPERATOR);\n\t    } else if (this._processNumber()) {\n\t        return this._consume(TokenTypes.NUMBER);\n\t    }\n\t    return this._processError();\n\t};\n\t\n\t// PRIVATE\n\t\n\tfunction error(token, description) {\n\t    return {error: description, on: token};\n\t}\n\t\n\tLexer.prototype._make = function (type, value) {\n\t    return {\n\t        type: type,\n\t        value: value,\n\t        range: {\n\t            start: {row: this.row, column: this.startColumn},\n\t            end: {row: this.row, column: this.endColumn}\n\t        }\n\t    };\n\t};\n\t\n\tLexer.prototype._consume = function (type) {\n\t    var text = this.buf.substring(this.from, this.i);\n\t    var newToken = this._make(type, text);\n\t    this.from = this.i;\n\t    this.startColumn = this.endColumn;\n\t    return newToken;\n\t};\n\t\n\tLexer.prototype._refreshCurrentAndNextChars = function () {\n\t    this.current = this.buf.charAt(this.from);\n\t    this.nextChar = this.buf.charAt(this.from + 1);\n\t};\n\t\n\tLexer.prototype._processOperator = function () {\n\t    if (this.punctuators.indexOf(this.current) >= 0) {\n\t        this._increaseFrom();\n\t        this._processMultiCharOperator();\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\tLexer.prototype._processMultiCharOperator = function () {\n\t    if (this.prefix.indexOf(this.current) >= 0 && this.suffix.indexOf(this.nextChar) >= 0) {\n\t        this._incrementStep();\n\t    }\n\t};\n\t\n\tLexer.prototype._processNumber = function () {\n\t    if (_isDigit(this.current)) {\n\t        this._increaseFrom();\n\t        while (this.i < this.buflen && _isDigit(this.buf.charAt(this.i))) {\n\t            this._incrementStep();\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\tLexer.prototype._processError = function () {\n\t    this._increaseFrom();\n\t    return error('Unmatched token', this._consume('UNMATCHED'));\n\t};\n\t\n\tLexer.prototype._resetColumnCount = function () {\n\t    this.startColumn = this.endColumn;\n\t};\n\t\n\tLexer.prototype._increaseFrom = function () {\n\t    this.i = this.from + 1;\n\t    this.startColumn = this.startColumn + 1;\n\t    this.endColumn = this.startColumn;\n\t};\n\t\n\tLexer.prototype._incrementStep = function () {\n\t    this.i++;\n\t    this.endColumn++;\n\t};\n\t\n\tLexer.prototype._processIdentifier = function () {\n\t    if (_isAlpha(this.current)) {\n\t        this._increaseFrom();\n\t        while (this.i < this.buflen && _isAlphanum(this.buf.charAt(this.i))) {\n\t            this._incrementStep();\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\tLexer.prototype._skipNonTokens = function () {\n\t    while (this.from < this.buflen) {\n\t        var c = this.buf.charAt(this.from);\n\t        if (c === ' ' || c === '\\t' || c === '\\r' || c === '\\n') {\n\t            if (_isNewline(c)) {\n\t                this.row += 1;\n\t                this.endColumn = 0;\n\t                this.startColumn = 0;\n\t            } else {\n\t                this.startColumn++;\n\t                this.endColumn = this.startColumn;\n\t            }\n\t            this.from++;\n\t            this.i = this.from;\n\t        } else {\n\t            break;\n\t        }\n\t    }\n\t};\n\t\n\tLexer.prototype._processComment = function () {\n\t    var chars = this.current + this.nextChar;\n\t    return this._processSingleLineComment(chars) || this._processMultiLineComment(chars);\n\t};\n\t\n\tLexer.prototype._processSingleLineComment = function (chars) {\n\t    if (chars === '//') {\n\t        while (this.i < this.buflen && !_isNewline(this.buf.charAt(this.i))) {\n\t            this._incrementStep();\n\t        }\n\t        this.from = this.i;\n\t        this.row++;\n\t        this.startColumn = 0;\n\t        this.endColumn = 0;\n\t        return true;\n\t    }\n\t};\n\t\n\tLexer.prototype._processMultiLineComment = function (chars) {\n\t    if (chars === '/*') {\n\t        this._incrementStep();\n\t        this._incrementStep();\n\t        while (this.i < this.buflen && this.buf.charAt(this.i) !== '*' && this.buf.charAt(this.i + 1) !== '/') {\n\t            this._incrementStep();\n\t            if (_isNewline(this.buf.charAt(this.i))) {\n\t                this.endColumn = 0;\n\t            }\n\t        }\n\t        this._incrementStep();\n\t        this._incrementStep();\n\t        this.from = this.i;\n\t        this.endColumn = this.startColumn;\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\tfunction _isNewline(c) {\n\t    return c === '\\r' || c === '\\n';\n\t}\n\t\n\tfunction _isDigit(c) {\n\t    return c >= '0' && c <= '9';\n\t}\n\t\n\tfunction _isAlpha(c) {\n\t    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '_' || c === '\\'';\n\t}\n\t\n\tfunction _isAlphanum(c) {\n\t    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c === '_' || c === '$';\n\t}\n\t\n\tmodule.exports = Lexer;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node, constants) {\n\t    node.Assignment = function (token, left, right) {\n\t        this.token = token;\n\t        this.arity = constants.STM;\n\t        this.alias = ':=';\n\t        this.left = left;\n\t        this.right = right;\n\t    };\n\t\n\t    node.Assignment.prototype.interpret = function (context) {\n\t        context.put(this.left.token.value, this.right.eval(context));\n\t    };\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node, constants) {\n\t    var BinaryOperation = function (token, left, right) {\n\t        this.token = token;\n\t        this.left = left;\n\t        this.right = right;\n\t        this.arity = constants.BINARY;\n\t    };\n\t\n\t    function defineBinaryOperation(className) {\n\t        node[className] = function (token, left, right) {\n\t            BinaryOperation.call(this, token, left, right);\n\t        };\n\t        node[className].prototype = new BinaryOperation();\n\t    }\n\t\n\t    defineBinaryOperation('SumOperation');\n\t    node.SumOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) + this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('DiffOperation');\n\t    node.DiffOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) - this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('MulOperation');\n\t    node.MulOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) * this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('DivOperation');\n\t    node.DivOperation.prototype.eval = function (context) {\n\t        return Math.floor(this.left.eval(context) / this.right.eval(context));\n\t    };\n\t\n\t    defineBinaryOperation('ModOperation');\n\t    node.ModOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) % this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('ExpOperation');\n\t    node.ExpOperation.prototype.eval = function (context) {\n\t        return Math.pow(this.left.eval(context), this.right.eval(context));\n\t    };\n\t\n\t    defineBinaryOperation('AndOperation');\n\t    node.AndOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) && this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('OrOperation');\n\t    node.OrOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) || this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('NotEqualOperation');\n\t    node.NotEqualOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) !== this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('EqOperation');\n\t    node.EqOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) === this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('LessOperation');\n\t    node.LessOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) < this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('GraterOperation');\n\t    node.GraterOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) > this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('LessEqualOperation');\n\t    node.LessEqualOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) <= this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('GreaterEqualOperation');\n\t    node.GreaterEqualOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) >= this.right.eval(context);\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.If = function (token, condition, trueBranch, falseBranch) {\n\t        this.token = token;\n\t        this.condition = condition;\n\t        this.trueBranch = trueBranch;\n\t        this.falseBranch = falseBranch;\n\t    };\n\t\n\t    node.If.prototype.interpret = function (context) {\n\t        return node.interpretBlock(this.condition.eval(context) ? this.trueBranch : this.falseBranch, context);\n\t    };\n\t\n\t    node.Switch = function (token, expression, cases) {\n\t        this.token = token;\n\t        this.expression = expression;\n\t        this.cases = cases;\n\t    };\n\t\n\t    node.Switch.prototype.interpret = function (context) {\n\t        var value = this.expression.eval(context);\n\t        for (var i = 0; i < this.cases.length; i++) {\n\t            if (this.cases[i].case.eval(context) === value) {\n\t                node.interpretBlock(this.cases[i].body, context);\n\t                break;\n\t            }\n\t        }\n\t        return context;\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.Constant = function (token, alias, value, type) {\n\t        this.token = token;\n\t        this.value = value;\n\t        this.alias = alias;\n\t        this.type = type;\n\t    };\n\t\n\t    node.Constant.prototype.eval = function () {\n\t        return this.value;\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.NumericLiteral = function (token, value) {\n\t        this.token = token;\n\t        this.value = value;\n\t    };\n\t    node.NumericLiteral.prototype.type = 'number';\n\t\n\t    node.NumericLiteral.prototype.eval = function () {\n\t        return this.value;\n\t    };\n\t};\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar node = {};\n\tnode.errors = __webpack_require__(1);\n\t\n\tvar constants = {\n\t    STM: 'statement',\n\t    BINARY: 'binary',\n\t    EXPRESSION: 'binary'\n\t};\n\t\n\tnode.interpretBlock = function (block, context) {\n\t    block = block || [];\n\t    for (var i = 0; i < block.length; i++) {\n\t        block[i].interpret(context);\n\t    }\n\t    return context;\n\t};\n\t\n\t__webpack_require__(11)(node, constants);\n\t__webpack_require__(10)(node, constants);\n\t__webpack_require__(20)(node, constants);\n\t__webpack_require__(7)(node, constants);\n\t__webpack_require__(9)(node, constants);\n\t__webpack_require__(8)(node, constants);\n\t__webpack_require__(19)(node, constants);\n\t__webpack_require__(13)(node, constants);\n\t__webpack_require__(14)(node, constants);\n\t__webpack_require__(17)(node, constants);\n\t__webpack_require__(18)(node, constants);\n\t__webpack_require__(16)(node, constants);\n\t__webpack_require__(15)(node, constants);\n\t\n\tmodule.exports = node;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node, constants) {\n\t    node.HasStones = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'hasStones';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.HasStones.prototype.eval = function (context) {\n\t        return context.board().amountStones(this.parameters[0].eval(context)) > 0;\n\t    };\n\t\n\t    node.CanMove = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'canMove';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.CanMove.prototype.eval = function (context) {\n\t        return context.board().canMove(this.parameters[0].eval(context));\n\t    };\n\t\n\t    node.NumStones = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'numStones';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.NumStones.prototype.eval = function (context) {\n\t        return context.board().amountStones(this.parameters[0].eval(context));\n\t    };\n\t\n\t    node.MinDir = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'minDir';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MinDir.prototype.eval = function (context) {\n\t        return context.nativeRepresentations().minDir;\n\t    };\n\t\n\t    node.MaxDir = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'maxDir';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MaxDir.prototype.eval = function (context) {\n\t        return context.nativeRepresentations().maxDir;\n\t    };\n\t\n\t    node.MaxColor = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'maxColor';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MaxColor.prototype.eval = function (context) {\n\t        return context.nativeRepresentations().maxColor;\n\t    };\n\t\n\t    node.MinColor = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'minColor';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MinColor.prototype.eval = function (context) {\n\t        return context.nativeRepresentations().minColor;\n\t    };\n\t\n\t    node.MinBool = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'minBool';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MinBool.prototype.eval = function () {\n\t        return false;\n\t    };\n\t\n\t    node.MaxBool = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'maxBool';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MaxBool.prototype.eval = function () {\n\t        return true;\n\t    };\n\t};\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node, constants) {\n\t    node.MoveClaw = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.STM;\n\t        this.name = 'MoveClaw';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MoveClaw.prototype.interpret = function (context) {\n\t        try {\n\t            context.board().move(this.parameters[0].eval(context));\n\t        } catch (err) {\n\t            err.on = this.token;\n\t            throw err;\n\t        }\n\t        return context;\n\t    };\n\t\n\t    node.RemoveStone = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.STM;\n\t        this.name = 'Grab';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.RemoveStone.prototype.interpret = function (context) {\n\t        try {\n\t            context.board().removeStone(this.parameters[0].eval(context));\n\t        } catch (err) {\n\t            err.on = this.token;\n\t            throw err;\n\t        }\n\t        return context;\n\t    };\n\t\n\t    node.PutStone = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.STM;\n\t        this.name = 'Drop';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.PutStone.prototype.interpret = function (context) {\n\t        context.board().putStone(this.parameters[0].eval(context));\n\t        return context;\n\t    };\n\t\n\t    node.MoveToEdge = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.STM;\n\t        this.name = 'MoveToEdge';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MoveToEdge.prototype.interpret = function (context) {\n\t        context.board().moveToEdge(this.parameters[0].eval(context));\n\t        return context;\n\t    };\n\t\n\t    node.CleanBoard = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.STM;\n\t        this.name = 'MoveToEdge';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.CleanBoard.prototype.interpret = function (context) {\n\t        context.board().clear();\n\t        return context;\n\t    };\n\t\n\t    node.Boom = function (token) {\n\t        this.token = token;\n\t        this.arity = constants.STM;\n\t        this.name = 'BOOM';\n\t    };\n\t\n\t    node.Boom.prototype.interpret = function (context) {\n\t        try {\n\t            context.board().boom();\n\t        } catch (err) {\n\t            err.on = node;\n\t            throw err;\n\t        }\n\t        return context;\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.Program = function (token, body) {\n\t        this.token = token;\n\t        this.alias = 'program';\n\t        this.body = body || [];\n\t    };\n\t\n\t    node.Program.prototype.interpret = function (context) {\n\t        node.interpretBlock(this.body, context);\n\t        return context;\n\t    };\n\t\n\t    node.Root = function (program, declarations) {\n\t        this.alias = 'root';\n\t        this.program = program;\n\t        this.declarations = declarations;\n\t    };\n\t\n\t    node.Root.prototype.interpret = function (context) {\n\t        this.program.interpret(context);\n\t        return context;\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.While = function (token, expression, body) {\n\t        this.alias = 'while';\n\t        this.token = token;\n\t        this.expression = expression;\n\t        this.body = body;\n\t    };\n\t\n\t    node.While.prototype.interpret = function (context) {\n\t        while (this.expression.eval(context)) {\n\t            node.interpretBlock(this.body, context);\n\t        }\n\t        return context;\n\t    };\n\t\n\t    node.Repeat = function (token, expression, body) {\n\t        this.alias = 'repeat';\n\t        this.token = token;\n\t        this.expression = expression;\n\t        this.body = body;\n\t    };\n\t\n\t    node.Repeat.prototype.interpret = function (context) {\n\t        var value = this.expression.eval(context);\n\t        for (var i = 0; i < value; i++) {\n\t            node.interpretBlock(this.body, context);\n\t        }\n\t        return context;\n\t    };\n\t\n\t    node.ForEach = function (token, iterator, rangeLeft, rangeRight, body) {\n\t        this.alias = 'foreach';\n\t        this.token = token;\n\t        this.iterator = iterator;\n\t        this.rangeLeft = rangeLeft;\n\t        this.rangeRight = rangeRight;\n\t        this.body = body;\n\t    };\n\t\n\t    node.ForEach.prototype.interpret = function (context) {\n\t        var rangeLeft = this.rangeLeft.eval(context);\n\t        var rangeRight = this.rangeRight.eval(context);\n\t\n\t        if (typeof rangeLeft !== typeof rangeRight) {\n\t            node.errors.throwInterpreterError(this.token, 'El rando del foreach debe ser mismos tipos de datos');\n\t        }\n\t\n\t        var values = context.nativeRepresentations();\n\t        var items = [];\n\t        if (typeof rangeLeft === 'object') {\n\t            if (rangeLeft[0] === values.minDir[0] && rangeLeft[1] === values.minDir[1]) {\n\t                items = [values.north, values.east, values.south, values.west];\n\t            } else {\n\t                items = [values.west, values.south, values.east, values.north];\n\t            }\n\t        } else if (typeof rangeLeft === 'boolean') {\n\t            if (rangeLeft) {\n\t                items = [true, false];\n\t            } else {\n\t                items = [false, true];\n\t            }\n\t        } else if (typeof rangeLeft === 'number' && rangeLeft >= values.minColor && rangeLeft <= values.maxColor) {\n\t            if (rangeLeft === values.minColor) {\n\t                items = [values.blue, values.red, values.black, values.green];\n\t            } else {\n\t                items = [values.green, values.black, values.red, values.blue];\n\t            }\n\t        }\n\t\n\t        for (var i = 0; i < items.length; i++) {\n\t            context.put(this.iterator.token.value, items[i]);\n\t            node.interpretBlock(this.body, context);\n\t        }\n\t\n\t        return context;\n\t    };\n\t};\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    function evalArguments(context, parameters) {\n\t        var results = [];\n\t        if (parameters) {\n\t            for (var i = 0; i < parameters.length; i++) {\n\t                results.push(parameters[i].eval(context));\n\t            }\n\t        }\n\t        return results;\n\t    }\n\t\n\t    function fillParameters(context, parameters, declaration) {\n\t        // TODO: no se pueden reasignar valores a los parámetros\n\t        if (declaration.parameters) {\n\t            for (var i = 0; i < declaration.parameters.length; i++) {\n\t                context.put(declaration.parameters[i].value, parameters[i]);\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO: el mundo de las variables, índices y parámetros debe ser disjunto por body!!\n\t\n\t    node.ProcedureCall = function (token, declarationProvider, parameters) {\n\t        this.token = token;\n\t        this.arity = 'routine';\n\t        this.alias = 'ProcedureCall';\n\t        this.name = token.value;\n\t        this.parameters = parameters;\n\t        this.declarationProvider = declarationProvider;\n\t    };\n\t\n\t    node.ProcedureCall.prototype.interpret = function (context) {\n\t        var target = this.declarationProvider();\n\t        if (!target.declaration) {\n\t            throw new node.errors.InterpreterException('El procedimiento ' + this.name + ' no se encuentra definido.', this.node);\n\t        }\n\t        var declaration = target.declaration;\n\t        var parameterValues = evalArguments(context, this.parameters);\n\t        context.startContext();\n\t        fillParameters(context, parameterValues, declaration);\n\t        node.interpretBlock(declaration.body, context);\n\t        context.stopContext();\n\t        return context;\n\t    };\n\t\n\t    node.FunctionCall = function (token, declarationProvider, parameters) {\n\t        this.token = token;\n\t        this.arity = 'routine';\n\t        this.alias = 'FunctionCall';\n\t        this.name = token.value;\n\t        this.parameters = parameters;\n\t        this.declarationProvider = declarationProvider;\n\t    };\n\t\n\t    node.FunctionCall.prototype.eval = function (context) {\n\t        var target = this.declarationProvider();\n\t        if (!target.declaration) {\n\t            throw new node.errors.InterpreterException('La función \"' + this.name + '\" no se encuentra definida.', this.node);\n\t        }\n\t        var declaration = target.declaration;\n\t        var parameterValues = evalArguments(context, this.parameters);\n\t        context.startContext();\n\t        context.pushBoard();\n\t        fillParameters(context, parameterValues, declaration);\n\t        node.interpretBlock(target.body, context);\n\t        var result = declaration.return.expression.eval(context);\n\t        context.popBoard();\n\t        context.stopContext();\n\t        return result;\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.ProcedureDeclaration = function (token, parameters, body) {\n\t        this.token = token;\n\t        this.name = token.value;\n\t        this.arity = 'routine';\n\t        this.alias = 'procedureDeclaration';\n\t        this.parameters = parameters || [];\n\t        this.body = body || [];\n\t    };\n\t\n\t    node.FunctionDeclaration = function (token, parameters, body, returnExpression) {\n\t        this.token = token;\n\t        this.name = token.value;\n\t        this.arity = 'routine';\n\t        this.alias = 'functionDeclaration';\n\t        this.parameters = parameters || [];\n\t        this.body = body || [];\n\t        this.return = returnExpression;\n\t    };\n\t\n\t    node.ReturnStatement = function (token, expression) {\n\t        this.token = token;\n\t        this.alias = 'return';\n\t        this.expression = expression;\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.NotOperation = function (token, expression) {\n\t        this.token = token;\n\t        this.expression = expression;\n\t    };\n\t\n\t    node.NotOperation.prototype.eval = function (context) {\n\t        return !this.expression.eval(context);\n\t    };\n\t\n\t    node.SubstractionOperation = function (token, expression) {\n\t        this.token = token;\n\t        this.expression = expression;\n\t    };\n\t\n\t    node.SubstractionOperation.prototype.eval = function (context) {\n\t        return -this.expression.eval(context);\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.Variable = function (token, id) {\n\t        this.token = token;\n\t        this.id = id;\n\t    };\n\t\n\t    node.Variable.prototype.eval = function (context) {\n\t        return context.get(this.id);\n\t    };\n\t\n\t    return node;\n\t};\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tvar doNothing = function () {\n\t};\n\t\n\tmodule.exports = (console && console.log) ? console.log : doNothing;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// index.umd.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 419180ba5493e0a1ed6f","var gbs = {};\n\ngbs.Parser = require('./grammar/parser');\ngbs.Lexer = require('./lexer/lexer');\ngbs.node = require('./nodes/nodes');\ngbs.errors = require('./utils/errors');\n\nvar grammar = require('./grammar/grammar')(gbs);\n\nmodule.exports = grammar;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/gbs.js\n// module id = 0\n// module chunks = 0","var log = require('./logger');\n\nvar errors = {};\n\nerrors.throwParserError = function (token, description) {\n    var someError = {error: description, on: token};\n    log('PARSER ERROR: ', someError);\n    throw someError;\n};\n\nerrors.throwInterpreterError = function (token, message) {\n    throw new errors.InterpreterException(message, token);\n};\n\nerrors.InterpreterException = function (message, on) {\n    this.message = message;\n    this.on = on;\n};\nerrors.InterpreterException.prototype = new Error();\n\nmodule.exports = errors;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/utils/errors.js\n// module id = 1\n// module chunks = 0","var TOKEN_NAMES = require('./reserved-words');\n\nmodule.exports = function (gbs) {\n    var g = new gbs.Parser(new gbs.Lexer());\n    var define = g;\n\n    function commaSeparatedArguments(parser) {\n        var parameters = [];\n        if (parser.token.id !== ')') {\n            for (; ;) {\n                parameters.push(parser.expression(0));\n                if (parser.token.id !== ',') {\n                    break;\n                }\n                parser.advance(',');\n            }\n        }\n        return parameters;\n    }\n\n    function parameterListCall(parser) {\n        parser.advance('(');\n        var parameters = commaSeparatedArguments(parser);\n        parser.advance(')');\n        return parameters;\n    }\n\n    function parameterDeclarationList() {\n        var parameters = [];\n        g.advance('(');\n        if (g.token.id !== ')') {\n            for (; ;) {\n                if (g.token.arity !== 'name') {\n                    g.error(g.token, 'Se esperaba un nombre de parámetro.');\n                }\n                parameters.push(g.token);\n                g.advance();\n                if (g.token.id !== ',') {\n                    break;\n                }\n                g.advance(',');\n            }\n        }\n        g.advance(')');\n        return parameters;\n    }\n\n    function parenthesisExpression() {\n        g.advance('(');\n        var p = g.expression(0);\n        g.advance(')');\n        return p;\n    }\n\n    function bodyStatement() {\n        return g.block() || [];\n    }\n\n    function bodyStatementWithOptionalMultiline() {\n        return (g.token.id === '{') ? bodyStatement() : [g.statement()];\n    }\n\n    function defineConstant(symbol, alias, value, type) {\n        var token = g.symbol(symbol);\n        token.nud = function () {\n            return new gbs.node.Constant(token, alias, value, type);\n        };\n    }\n\n    define.symbol('(end)');\n    define.symbol('(literal)').nud = function () {\n        return new gbs.node.NumericLiteral(this, this.value);\n    };\n\n    define.symbol('(name)').nud = function () {\n        return new gbs.node.Variable(this, this.value);\n    };\n\n    define.op('||', 20, gbs.node.OrOperation);\n    define.op('&&', 25, gbs.node.AndOperation);\n\n    define.op('+', 50, gbs.node.SumOperation);\n    define.op('-', 50, gbs.node.DiffOperation);\n    define.op('*', 60, gbs.node.MulOperation);\n    // TODO: chequear que efectivamente sean no asociativos\n    define.op(TOKEN_NAMES.DIV, 70, gbs.node.DivOperation);\n    define.op(TOKEN_NAMES.MOD, 70, gbs.node.ModOperation);\n\n    define.infixr('^', 80, function (left) {\n        return new gbs.node.ExpOperation(g.token, left, g.expression(80));\n    });\n    // TODO: chequear cómo se comporta el NOT\n    define.prefix(TOKEN_NAMES.NOT, function () {\n        return new gbs.node.NotOperation(g.token, g.expression(70));\n    });\n    define.prefix('-', function () {\n        return new gbs.node.SubstractionOperation(g.token, g.expression(70));\n    });\n\n    define.op('==', 40, gbs.node.EqOperation);\n    define.op('/=', 40, gbs.node.NotEqualOperation);\n    define.op('<', 40, gbs.node.LessOperation);\n    define.op('>', 40, gbs.node.GraterOperation);\n    define.op('<=', 40, gbs.node.LessEqualOperation);\n    define.op('>=', 40, gbs.node.GreaterEqualOperation);\n\n    defineConstant(TOKEN_NAMES.FALSE, 'False', false, TOKEN_NAMES.BOOLEAN);\n    defineConstant(TOKEN_NAMES.TRUE, 'True', true, TOKEN_NAMES.BOOLEAN);\n    defineConstant(TOKEN_NAMES.BLUE, 'Blue', 0, TOKEN_NAMES.COLOR);\n    defineConstant(TOKEN_NAMES.RED, 'Red', 1, TOKEN_NAMES.COLOR);\n    defineConstant(TOKEN_NAMES.BLACK, 'Black', 2, TOKEN_NAMES.COLOR);\n    defineConstant(TOKEN_NAMES.GREEN, 'Green', 3, TOKEN_NAMES.COLOR);\n    defineConstant(TOKEN_NAMES.NORTH, 'North', [0, 1], TOKEN_NAMES.DIRECTION);\n    defineConstant(TOKEN_NAMES.SOUTH, 'South', [0, -1], TOKEN_NAMES.DIRECTION);\n    defineConstant(TOKEN_NAMES.EAST, 'East', [1, 0], TOKEN_NAMES.DIRECTION);\n    defineConstant(TOKEN_NAMES.WEST, 'West', [-1, 0], TOKEN_NAMES.DIRECTION);\n\n    define.symbol(':');\n    define.symbol(')');\n    define.symbol('(');\n    define.symbol('[');\n    define.symbol(']');\n    define.symbol('}');\n    define.symbol(',');\n    define.symbol('->');\n    define.symbol('..');\n    define.symbol(TOKEN_NAMES.IN);\n    define.symbol(TOKEN_NAMES.ELSE);\n    define.symbol(TOKEN_NAMES.TO);\n\n    var separator = {separator: ';'};\n    define.stmt(';', function () {\n        return separator;\n    });\n\n    define.infix('(', 80, function (left) {\n        if (left.token.arity !== 'name') {\n            gbs.errors.throwParserError(left, left.token.value + ' no es una función o procedimiento');\n        }\n        var parameters = commaSeparatedArguments(g);\n        g.advance(')');\n        var node;\n        if (left.token.value[0].toUpperCase() === left.token.value[0]) {\n            node = new gbs.node.ProcedureCall(left.token, function () {\n                return g.scope.find(left.token.value);\n            }, parameters);\n        } else {\n            node = new gbs.node.FunctionCall(left.token, function () {\n                return g.scope.find(left.token.value);\n            }, parameters);\n        }\n        return node;\n    });\n\n    define.infixr(':=', 10, function (left) {\n        if (left.id !== '.' && left.id !== '[' && (!left.token || left.token.arity !== 'name')) {\n            g.error(left, 'Del lado izquierdo de la asignación sólo pueden usarse identificadores');\n        }\n        return new gbs.node.Assignment({}, left, g.expression(9));\n    });\n\n    define.stmt(TOKEN_NAMES.DROP, function () {\n        return new gbs.node.PutStone(g.token, parameterListCall(g));\n    });\n\n    define.stmt(TOKEN_NAMES.GRAB, function () {\n        return new gbs.node.RemoveStone(g.token, parameterListCall(g));\n    });\n\n    define.stmt(TOKEN_NAMES.MOVE, function () {\n        return new gbs.node.MoveClaw(g.token, parameterListCall(g));\n    });\n\n    define.stmt(TOKEN_NAMES.MOVE_TO_EDGE, function () {\n        return new gbs.node.MoveToEdge(g.token, parameterListCall(g));\n    });\n\n    define.stmt(TOKEN_NAMES.CLEAN_BOARD, function () {\n        return new gbs.node.CleanBoard(g.token, parameterListCall(g));\n    });\n\n    define.stmt(TOKEN_NAMES.BOOM, function () {\n        var token = g.token;\n        if (parenthesisExpression(g)) {\n            gbs.errors.throwParserError(token, 'BOOM no lleva parámetros');\n        }\n        return new gbs.node.Boom(token);\n    });\n\n    define.prefix(TOKEN_NAMES.HAS_STONES, function () {\n        return new gbs.node.HasStones(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.NUM_STONES, function () {\n        return new gbs.node.NumStones(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.MAX_COLOR, function () {\n        return new gbs.node.MaxColor(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.MIN_COLOR, function () {\n        return new gbs.node.MinColor(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.MAX_DIR, function () {\n        return new gbs.node.MaxDir(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.MIN_DIR, function () {\n        return new gbs.node.MinDir(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.MAX_BOOL, function () {\n        return new gbs.node.MaxBool(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.MIN_BOOL, function () {\n        return new gbs.node.MinBool(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.CAN_MOVE, function () {\n        var id = g.token;\n        var parameters = parameterListCall(g);\n        return new gbs.node.CanMove(id, parameters);\n    });\n\n    define.stmt(TOKEN_NAMES.IF, function () {\n        var token = g.token;\n        g.advance('(');\n        var condition = g.expression(0);\n        g.advance(')');\n        var trueBranch = bodyStatement(g);\n        var falseBranch = null;\n        if (g.token.id === TOKEN_NAMES.ELSE) {\n            g.scope.reserve(g.token);\n            g.advance(TOKEN_NAMES.ELSE);\n            falseBranch = bodyStatement(g);\n        }\n        return new gbs.node.If(token, condition, trueBranch, falseBranch);\n    });\n\n    define.stmt(TOKEN_NAMES.SWITCH, function () {\n        var token = g.token;\n        var condition = parenthesisExpression(g);\n        if (g.token.id === TOKEN_NAMES.TO) {\n            g.advance(TOKEN_NAMES.TO);\n        }\n        g.advance('{');\n        var cases = [];\n        for (; ;) {\n            var exp = g.expression(0);\n            g.advance('->');\n            var body = bodyStatementWithOptionalMultiline(g);\n            cases.push({\n                case: exp,\n                body: body\n            });\n            if (g.token.id === '}' || !g.tokens.hasNext()) {\n                break;\n            }\n        }\n        g.advance('}');\n        return new gbs.node.Switch(token, condition, cases);\n    });\n\n    define.stmt(TOKEN_NAMES.WHILE, function () {\n        return new gbs.node.While(g.token, parenthesisExpression(g), bodyStatement(g));\n    });\n\n    define.stmt(TOKEN_NAMES.REPEAT, function () {\n        return new gbs.node.Repeat(g.token, parenthesisExpression(g), bodyStatement(g));\n    });\n\n    define.stmt(TOKEN_NAMES.FOR_EACH, function () {\n        // foreach dir in [minDir() .. maxDir()]\n        var iterator = g.expression();\n        if (iterator.token.arity !== 'name') {\n            g.error(iterator.token, 'El foreach espera un identificador sobre el cual iterar');\n        }\n        g.advance(TOKEN_NAMES.IN);\n        g.advance('[');\n        var rangeLeft = g.expression();\n        g.advance('..');\n        var rangeRight = g.expression();\n        g.advance(']');\n        return new gbs.node.ForEach(g.token, iterator, rangeLeft, rangeRight, g.block());\n    });\n\n    define.stmt('{', function () {\n        var a = g.statements();\n        g.advance('}');\n        return a;\n    });\n\n    define.stmt('(', function () {\n        var a = g.statements();\n        g.advance(')');\n        return a;\n    });\n\n    define.prefix('(', function () {\n        var expression = g.expression(0);\n        g.advance(')');\n        return expression;\n    });\n\n    define.root(TOKEN_NAMES.PROGRAM, function () {\n        return new gbs.node.Program(g.token, g.block());\n    });\n\n    define.root(TOKEN_NAMES.FUNCTION, function () {\n        g.newScope();\n        var token = g.token;\n        if (g.token.arity === 'name') {\n            if (g.token.value[0] !== g.token.value[0].toLowerCase()) {\n                g.error(token, 'El nombre de la función ' + token.value + ' debe emepzar con minúscula');\n            }\n            g.scope.define(token);\n            g.advance();\n        } else {\n            g.error(token, 'Se esperaba un nombre de función');\n        }\n        var parameters = parameterDeclarationList(g);\n        var body = bodyStatement(g);\n\n        var ret = body.pop();\n        if (!ret || ret.alias !== 'return' || !ret.expression) {\n            g.error(token, 'La función ' + token.value + ' debe terminar con un ' + TOKEN_NAMES.RETURN);\n        }\n        g.scope.pop();\n        var declaration = new gbs.node.FunctionDeclaration(token, parameters, body, ret);\n        token.declaration = declaration;\n        return declaration;\n    });\n\n    define.stmt(TOKEN_NAMES.RETURN, function () {\n        return new gbs.node.ReturnStatement(g.token, parenthesisExpression(g));\n    });\n\n    define.root(TOKEN_NAMES.PROCEDURE, function () {\n        g.newScope();\n        var token = g.token;\n        if (g.token.arity === 'name') {\n            if (g.token.value[0] !== g.token.value[0].toUpperCase()) {\n                g.error(token, 'El nombre del procedimiento ' + token.value + ' debe emepzar con mayúscula');\n            }\n            g.scope.define(token);\n            g.advance();\n        } else {\n            g.error(token, 'Se esperaba un nombre de procedimiento');\n        }\n        var parameters = parameterDeclarationList(g);\n        var body = bodyStatement();\n        g.scope.pop();\n        var declaration = new gbs.node.ProcedureDeclaration(token, parameters, body);\n        token.declaration = declaration;\n        return declaration;\n    });\n\n    define.parse = function (input) {\n        var main;\n        var declarations = [];\n        var roots = g.parseProgram(input);\n        for (var i = 0; i < roots.length; i++) {\n            if (roots[i].alias === 'program') {\n                main = roots[i];\n            } else {\n                declarations.push(roots[i]);\n            }\n        }\n        return new gbs.node.Root(main, declarations);\n    };\n\n    return g;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/grammar/grammar.js\n// module id = 2\n// module chunks = 0","var errors = require('../utils/errors');\nvar Scope = require('./scope');\n\nfunction throwUndefinedSymbolError() {\n    errors.throwParserError(this, 'No definido');\n}\n\nfunction throwMissingOperatorError() {\n    errors.throwParserError(this, 'No se encontró el operador');\n}\n\nvar OriginalSymbol = function () {\n    this.nud = throwUndefinedSymbolError;\n    this.led = throwMissingOperatorError;\n};\n\nvar Parser = function (lexer) {\n    this.scope = null;\n    this.token = null;\n    this.tokens = lexer;\n    this.symbolTable = {};\n};\n\nParser.prototype.symbol = function (id, bindingPower) {\n    var s = this.symbolTable[id];\n    bindingPower = bindingPower || 0;\n    if (s) {\n        if (bindingPower > s.lbp) {\n            s.lbp = bindingPower;\n        }\n    } else {\n        s = new OriginalSymbol();\n        s.id = s.value = id;\n        s.lbp = bindingPower;\n        this.symbolTable[id] = s;\n    }\n    return s;\n};\n\nParser.prototype.expression = function (rightBindingPower) {\n    rightBindingPower = rightBindingPower || 0;\n    var left;\n    var t = this.token;\n    this.advance();\n    left = t.nud();\n    while (rightBindingPower < this.token.lbp) {\n        t = this.token;\n        this.advance();\n        left = t.led(left);\n    }\n    return left;\n};\n\nParser.prototype.error = function (token, message) {\n    errors.throwParserError(token, message);\n};\n\nParser.prototype.newScope = function () {\n    var s = this.scope;\n    this.scope = new Scope(this);\n    this.scope.parent = s;\n    return this.scope;\n};\n\nParser.prototype.advance = function (id) {\n    var a;\n    var o;\n    var t;\n    var v;\n    var tokens = this.tokens;\n    if (id && this.token.id !== id) {\n        if (this.lastToken && this.lastToken.range && this.token.range) {\n            this.token.range.start = this.lastToken.range.start;\n        }\n        errors.throwParserError(this.token, 'Se esperaba \"' + id + '\" pero se encontró \"' + this.token.value + '\"');\n    }\n    if (!tokens.hasNext()) {\n        var lastRange = this.token.range;\n        this.token = this.symbolTable['(end)'];\n        this.token.range = lastRange;\n        return this.token;\n    }\n    t = tokens.next();\n    v = t.value;\n    a = t.type;\n    if (a === 'name') {\n        o = this.scope.find(v);\n        if (o.arity === 'routine') {\n            // force late binding\n            o = this.symbolTable['(name)'];\n        }\n    } else if (a === 'operator') {\n        o = this.symbolTable[v];\n        if (!o) {\n            errors.throwParserError(t, 'Unknown operator.');\n        }\n    } else if (a === 'number') {\n        o = this.symbolTable['(literal)'];\n        a = 'literal';\n        v = parseInt(v, 10);\n    } else {\n        errors.throwParserError(t, 'Unexpected token.');\n    }\n\n    var token = Object.create(o);\n    token.range = t.range;\n    token.value = v;\n    token.arity = a;\n    this.lastToken = this.token;\n    this.token = token;\n    return token;\n};\n\nParser.prototype.op = function (id, bp, OpDefinition) {\n    var parser = this;\n    var s = this.symbol(id, bp);\n    s.led = function (left) {\n        return new OpDefinition(this, left, parser.expression(bp));\n    };\n    return s;\n};\n\nParser.prototype.statement = function () {\n    var n = this.token;\n    var v;\n    if (n.std) {\n        this.advance();\n        this.scope.reserve(n);\n        return n.std();\n    }\n    v = this.expression(0);\n    if (v.alias !== ':=' && v.id !== '(' && v.arity !== 'routine') {\n        errors.throwParserError(v, 'Bad expression statement.');\n    }\n    return v;\n};\n\nParser.prototype.statements = function () {\n    var statementsList = [];\n    var symbol;\n    for (; ;) {\n        if (this.token.id === '}' || this.token.id === '(end)') {\n            break;\n        }\n        var range = this._currentRange();\n        symbol = this.statement();\n        if (symbol && !symbol.separator) {\n            this._applyRangeToSymbol(range, symbol);\n            statementsList.push(symbol);\n        }\n    }\n    if (statementsList.length === 0) {\n        return null;\n    }\n    return statementsList;\n};\n\nParser.prototype._applyRangeToSymbol = function (range, symbol) {\n    symbol.range = range;\n    if (this.token.range && this.token.range.end) {\n        range.end = this.token.range.end;\n    }\n};\n\nParser.prototype.rootDeclaration = function () {\n    var n = this.token;\n    if (!n.root) {\n        errors.throwParserError(n, 'Se esperaba una definición de programa, función o procedimiento.');\n    }\n    this.advance();\n    this.scope.reserve(n);\n    return n.root();\n};\n\nParser.prototype.stmt = function (symbol, f) {\n    var x = this.symbol(symbol);\n    x.std = f;\n    return x;\n};\n\nParser.prototype.infix = function (id, bp, led) {\n    var s = this.symbol(id, bp);\n    var self = this;\n    s.led = led || function (left) {\n        this.left = left;\n        this.right = self.expression(bp);\n        this.arity = 'binary';\n        return this;\n    };\n    return s;\n};\n\nParser.prototype.infixr = function (id, bp, led) {\n    var s = this.symbol(id, bp);\n    var self = this;\n    s.led = led || function (left) {\n        this.left = left;\n        this.right = self.expression(bp - 1);\n        this.arity = 'binary';\n        return this;\n    };\n    return s;\n};\n\nParser.prototype.prefix = function (id, nud) {\n    var s = this.symbol(id);\n    var self = this;\n    s.nud = nud || function () {\n        self.scope.reserve(this);\n        this.left = self.expression(70);\n        this.arity = 'unary';\n        return this;\n    };\n    return s;\n};\n\nParser.prototype.root = function (symbol, f) {\n    var x = this.symbol(symbol);\n    x.root = f;\n    return x;\n};\n\nParser.prototype.block = function () {\n    var t = this.token;\n    this.advance('{');\n    return t.std();\n};\n\nParser.prototype._currentRange = function () {\n    return {start: this.token.range.start, end: this.token.range.end};\n};\n\nParser.prototype.roots = function () {\n    var roots = [];\n    var symbol;\n    for (; ;) {\n        if (this.token.id === '(end)') {\n            break;\n        }\n        var range = this._currentRange();\n        symbol = this.rootDeclaration();\n        if (symbol) {\n            this._applyRangeToSymbol(range, symbol);\n            roots.push(symbol);\n        }\n    }\n    if (roots.length === 0) {\n        return null;\n    }\n    return roots;\n};\n\nParser.prototype._parseContextAwareNode = function (input, nodeParser) {\n    this.tokens.input(input);\n    this.newScope();\n    this.advance();\n    var s = nodeParser();\n    this.advance('(end)');\n    this.scope.pop();\n    return s;\n};\n\nParser.prototype.parseExpression = function (input) {\n    var self = this;\n    return this._parseContextAwareNode(input, function () {\n        return self.expression(0);\n    });\n};\n\nParser.prototype.parseProgram = function (input) {\n    var self = this;\n    return this._parseContextAwareNode(input, function () {\n        return self.roots();\n    });\n};\n\nParser.prototype.parseStatements = function (input) {\n    var self = this;\n    return this._parseContextAwareNode(input, function () {\n        return self.statements();\n    });\n};\n\nmodule.exports = Parser;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/grammar/parser.js\n// module id = 3\n// module chunks = 0","var TOKEN_NAMES = {\n    PROGRAM: 'program',\n    PROCEDURE: 'procedure',\n    FUNCTION: 'function',\n    RETURN: 'return',\n    DROP: 'Poner',\n    MOVE: 'Mover',\n    GRAB: 'Sacar',\n    BOOM: 'BOOM',\n    MOVE_TO_EDGE: 'IrAlBorde',\n    CLEAN_BOARD: 'VaciarTablero',\n    REPEAT: 'repeat',\n    WHILE: 'while',\n    FOR_EACH: 'foreach',\n    IN: 'in',\n    IF: 'if',\n    THEN: 'then',\n    ELSE: 'else',\n    SWITCH: 'switch',\n    TO: 'to',\n    OPPOSITE: 'opuesto',\n    NEXT: 'siguiente',\n    PREVIOUS: 'previo',\n    DIV: 'div',\n    MOD: 'mod',\n    NOT: 'not',\n    HAS_STONES: 'hayBolitas',\n    CAN_MOVE: 'puedeMover',\n    NUM_STONES: 'nroBolitas',\n    MIN_DIR: 'minDir',\n    MAX_DIR: 'maxDir',\n    MIN_COLOR: 'minColor',\n    MAX_COLOR: 'maxColor',\n    MIN_BOOL: 'minBool',\n    MAX_BOOL: 'maxBool',\n    RED: 'Rojo',\n    BLUE: 'Azul',\n    BLACK: 'Negro',\n    GREEN: 'Verde',\n    TRUE: 'True',\n    FALSE: 'False',\n    NORTH: 'Norte',\n    SOUTH: 'Sur',\n    EAST: 'Este',\n    WEST: 'Oeste',\n    BOOLEAN: 'Booleano',\n    COLOR: 'Color',\n    DIRECTION: 'Dirección',\n    NUMBER: 'Número'\n};\n\nmodule.exports = TOKEN_NAMES;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/grammar/reserved-words.js\n// module id = 4\n// module chunks = 0","var errors = require('../utils/errors');\n\nfunction itself() {\n    return this;\n}\n\nvar Scope = function (parser) {\n    this.parser = parser;\n    this.def = {};\n};\n\nScope.prototype.define = function (identifier) {\n    var t = this.def[identifier.value];\n    if (typeof t === 'object') {\n        errors.throwParserError(identifier, t.reserved ? 'Already reserved.' : 'Already defined.');\n    }\n    this.def[identifier.value] = identifier;\n    identifier.reserved = false;\n    identifier.nud = itself;\n    identifier.led = null;\n    identifier.std = null;\n    identifier.lbp = 0;\n    identifier.scope = this.parser.scope;\n    return identifier;\n};\n\nScope.prototype.find = function (name) {\n    var e = this;\n    var targetToken;\n    for (; ;) {\n        targetToken = e.def[name];\n        if (targetToken && typeof targetToken !== 'function') {\n            return e.def[name];\n        }\n        e = e.parent;\n        if (!e) {\n            targetToken = this.parser.symbolTable[name];\n            return targetToken && typeof targetToken !== 'function' ? targetToken : this.parser.symbolTable['(name)'];\n        }\n    }\n};\n\nScope.prototype.pop = function () {\n    this.scope = this.parent;\n};\n\nScope.prototype.reserve = function (name) {\n    if (name.arity !== 'name' || name.reserved) {\n        return;\n    }\n    var t = this.def[name.value];\n    if (t) {\n        if (t.reserved) {\n            return;\n        }\n        if (t.arity === 'name') {\n            name.error('Already defined.');\n        }\n    }\n    this.def[name.value] = name;\n    name.reserved = true;\n};\n\nmodule.exports = Scope;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/grammar/scope.js\n// module id = 5\n// module chunks = 0","function Lexer(prefix, suffix) {\n    // Current reading position\n    this.from = 0;\n    this.startColumn = 0;\n    this.endColumn = 0;\n    this.row = 0;\n    this.prefix = prefix || '/=-<>:|&.';\n    this.suffix = suffix || '=|&>.';\n\n    this.punctuators = '/+-*^.:|&;,()<>{}[]=';\n\n    // Look ahead position\n    this.i = 0;\n\n    this.buf = null;\n    this.buflen = 0;\n}\n\nLexer.prototype.hasNext = function () {\n    this._skipNonTokens();\n    return this.from < this.buflen;\n};\n\nLexer.prototype.input = function (buf) {\n    this.from = 0;\n    this.i = 0;\n    this.startColumn = 0;\n    this.endColumn = 0;\n    this.row = 0;\n    this.buf = buf;\n    this.buflen = buf.length;\n    this.current = null;\n    this.nextChar = null;\n};\n\nvar TokenTypes = {\n    IDENTIFIER: 'name',\n    OPERATOR: 'operator',\n    EOF: 'eof',\n    COMMENT: 'comment',\n    NUMBER: 'number',\n    NEWLINE: 'newline'\n};\n\n/**\n * This method is highly procedural for performance reasons.\n * There is no need for the lexer to be too flexible, since the\n * semantics will be associated to identifiers on the parser.\n *\n * @returns Token. The next token on the buffer, or null if the buffer is empty.\n */\nLexer.prototype.next = function () {\n    do {\n        this._skipNonTokens();\n        this._refreshCurrentAndNextChars();\n\n        if (this.from >= this.buflen) {\n            return null;\n        }\n    } while (this._processComment());\n\n    // Always add cases in descending order of occurrence probability\n    if (this._processIdentifier()) {\n        return this._consume(TokenTypes.IDENTIFIER);\n    } else if (this._processOperator()) {\n        return this._consume(TokenTypes.OPERATOR);\n    } else if (this._processNumber()) {\n        return this._consume(TokenTypes.NUMBER);\n    }\n    return this._processError();\n};\n\n// PRIVATE\n\nfunction error(token, description) {\n    return {error: description, on: token};\n}\n\nLexer.prototype._make = function (type, value) {\n    return {\n        type: type,\n        value: value,\n        range: {\n            start: {row: this.row, column: this.startColumn},\n            end: {row: this.row, column: this.endColumn}\n        }\n    };\n};\n\nLexer.prototype._consume = function (type) {\n    var text = this.buf.substring(this.from, this.i);\n    var newToken = this._make(type, text);\n    this.from = this.i;\n    this.startColumn = this.endColumn;\n    return newToken;\n};\n\nLexer.prototype._refreshCurrentAndNextChars = function () {\n    this.current = this.buf.charAt(this.from);\n    this.nextChar = this.buf.charAt(this.from + 1);\n};\n\nLexer.prototype._processOperator = function () {\n    if (this.punctuators.indexOf(this.current) >= 0) {\n        this._increaseFrom();\n        this._processMultiCharOperator();\n        return true;\n    }\n    return false;\n};\n\nLexer.prototype._processMultiCharOperator = function () {\n    if (this.prefix.indexOf(this.current) >= 0 && this.suffix.indexOf(this.nextChar) >= 0) {\n        this._incrementStep();\n    }\n};\n\nLexer.prototype._processNumber = function () {\n    if (_isDigit(this.current)) {\n        this._increaseFrom();\n        while (this.i < this.buflen && _isDigit(this.buf.charAt(this.i))) {\n            this._incrementStep();\n        }\n        return true;\n    }\n    return false;\n};\n\nLexer.prototype._processError = function () {\n    this._increaseFrom();\n    return error('Unmatched token', this._consume('UNMATCHED'));\n};\n\nLexer.prototype._resetColumnCount = function () {\n    this.startColumn = this.endColumn;\n};\n\nLexer.prototype._increaseFrom = function () {\n    this.i = this.from + 1;\n    this.startColumn = this.startColumn + 1;\n    this.endColumn = this.startColumn;\n};\n\nLexer.prototype._incrementStep = function () {\n    this.i++;\n    this.endColumn++;\n};\n\nLexer.prototype._processIdentifier = function () {\n    if (_isAlpha(this.current)) {\n        this._increaseFrom();\n        while (this.i < this.buflen && _isAlphanum(this.buf.charAt(this.i))) {\n            this._incrementStep();\n        }\n        return true;\n    }\n    return false;\n};\n\nLexer.prototype._skipNonTokens = function () {\n    while (this.from < this.buflen) {\n        var c = this.buf.charAt(this.from);\n        if (c === ' ' || c === '\\t' || c === '\\r' || c === '\\n') {\n            if (_isNewline(c)) {\n                this.row += 1;\n                this.endColumn = 0;\n                this.startColumn = 0;\n            } else {\n                this.startColumn++;\n                this.endColumn = this.startColumn;\n            }\n            this.from++;\n            this.i = this.from;\n        } else {\n            break;\n        }\n    }\n};\n\nLexer.prototype._processComment = function () {\n    var chars = this.current + this.nextChar;\n    return this._processSingleLineComment(chars) || this._processMultiLineComment(chars);\n};\n\nLexer.prototype._processSingleLineComment = function (chars) {\n    if (chars === '//') {\n        while (this.i < this.buflen && !_isNewline(this.buf.charAt(this.i))) {\n            this._incrementStep();\n        }\n        this.from = this.i;\n        this.row++;\n        this.startColumn = 0;\n        this.endColumn = 0;\n        return true;\n    }\n};\n\nLexer.prototype._processMultiLineComment = function (chars) {\n    if (chars === '/*') {\n        this._incrementStep();\n        this._incrementStep();\n        while (this.i < this.buflen && this.buf.charAt(this.i) !== '*' && this.buf.charAt(this.i + 1) !== '/') {\n            this._incrementStep();\n            if (_isNewline(this.buf.charAt(this.i))) {\n                this.endColumn = 0;\n            }\n        }\n        this._incrementStep();\n        this._incrementStep();\n        this.from = this.i;\n        this.endColumn = this.startColumn;\n        return true;\n    }\n    return false;\n};\n\nfunction _isNewline(c) {\n    return c === '\\r' || c === '\\n';\n}\n\nfunction _isDigit(c) {\n    return c >= '0' && c <= '9';\n}\n\nfunction _isAlpha(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '_' || c === '\\'';\n}\n\nfunction _isAlphanum(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c === '_' || c === '$';\n}\n\nmodule.exports = Lexer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/lexer/lexer.js\n// module id = 6\n// module chunks = 0","module.exports = function (node, constants) {\n    node.Assignment = function (token, left, right) {\n        this.token = token;\n        this.arity = constants.STM;\n        this.alias = ':=';\n        this.left = left;\n        this.right = right;\n    };\n\n    node.Assignment.prototype.interpret = function (context) {\n        context.put(this.left.token.value, this.right.eval(context));\n    };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/assignment.js\n// module id = 7\n// module chunks = 0","module.exports = function (node, constants) {\n    var BinaryOperation = function (token, left, right) {\n        this.token = token;\n        this.left = left;\n        this.right = right;\n        this.arity = constants.BINARY;\n    };\n\n    function defineBinaryOperation(className) {\n        node[className] = function (token, left, right) {\n            BinaryOperation.call(this, token, left, right);\n        };\n        node[className].prototype = new BinaryOperation();\n    }\n\n    defineBinaryOperation('SumOperation');\n    node.SumOperation.prototype.eval = function (context) {\n        return this.left.eval(context) + this.right.eval(context);\n    };\n\n    defineBinaryOperation('DiffOperation');\n    node.DiffOperation.prototype.eval = function (context) {\n        return this.left.eval(context) - this.right.eval(context);\n    };\n\n    defineBinaryOperation('MulOperation');\n    node.MulOperation.prototype.eval = function (context) {\n        return this.left.eval(context) * this.right.eval(context);\n    };\n\n    defineBinaryOperation('DivOperation');\n    node.DivOperation.prototype.eval = function (context) {\n        return Math.floor(this.left.eval(context) / this.right.eval(context));\n    };\n\n    defineBinaryOperation('ModOperation');\n    node.ModOperation.prototype.eval = function (context) {\n        return this.left.eval(context) % this.right.eval(context);\n    };\n\n    defineBinaryOperation('ExpOperation');\n    node.ExpOperation.prototype.eval = function (context) {\n        return Math.pow(this.left.eval(context), this.right.eval(context));\n    };\n\n    defineBinaryOperation('AndOperation');\n    node.AndOperation.prototype.eval = function (context) {\n        return this.left.eval(context) && this.right.eval(context);\n    };\n\n    defineBinaryOperation('OrOperation');\n    node.OrOperation.prototype.eval = function (context) {\n        return this.left.eval(context) || this.right.eval(context);\n    };\n\n    defineBinaryOperation('NotEqualOperation');\n    node.NotEqualOperation.prototype.eval = function (context) {\n        return this.left.eval(context) !== this.right.eval(context);\n    };\n\n    defineBinaryOperation('EqOperation');\n    node.EqOperation.prototype.eval = function (context) {\n        return this.left.eval(context) === this.right.eval(context);\n    };\n\n    defineBinaryOperation('LessOperation');\n    node.LessOperation.prototype.eval = function (context) {\n        return this.left.eval(context) < this.right.eval(context);\n    };\n\n    defineBinaryOperation('GraterOperation');\n    node.GraterOperation.prototype.eval = function (context) {\n        return this.left.eval(context) > this.right.eval(context);\n    };\n\n    defineBinaryOperation('LessEqualOperation');\n    node.LessEqualOperation.prototype.eval = function (context) {\n        return this.left.eval(context) <= this.right.eval(context);\n    };\n\n    defineBinaryOperation('GreaterEqualOperation');\n    node.GreaterEqualOperation.prototype.eval = function (context) {\n        return this.left.eval(context) >= this.right.eval(context);\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/binary-operations.js\n// module id = 8\n// module chunks = 0","module.exports = function (node) {\n    node.If = function (token, condition, trueBranch, falseBranch) {\n        this.token = token;\n        this.condition = condition;\n        this.trueBranch = trueBranch;\n        this.falseBranch = falseBranch;\n    };\n\n    node.If.prototype.interpret = function (context) {\n        return node.interpretBlock(this.condition.eval(context) ? this.trueBranch : this.falseBranch, context);\n    };\n\n    node.Switch = function (token, expression, cases) {\n        this.token = token;\n        this.expression = expression;\n        this.cases = cases;\n    };\n\n    node.Switch.prototype.interpret = function (context) {\n        var value = this.expression.eval(context);\n        for (var i = 0; i < this.cases.length; i++) {\n            if (this.cases[i].case.eval(context) === value) {\n                node.interpretBlock(this.cases[i].body, context);\n                break;\n            }\n        }\n        return context;\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/conditional-statements.js\n// module id = 9\n// module chunks = 0","module.exports = function (node) {\n    node.Constant = function (token, alias, value, type) {\n        this.token = token;\n        this.value = value;\n        this.alias = alias;\n        this.type = type;\n    };\n\n    node.Constant.prototype.eval = function () {\n        return this.value;\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/constant.js\n// module id = 10\n// module chunks = 0","module.exports = function (node) {\n    node.NumericLiteral = function (token, value) {\n        this.token = token;\n        this.value = value;\n    };\n    node.NumericLiteral.prototype.type = 'number';\n\n    node.NumericLiteral.prototype.eval = function () {\n        return this.value;\n    };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/literals.js\n// module id = 11\n// module chunks = 0","var node = {};\nnode.errors = require('../utils/errors');\n\nvar constants = {\n    STM: 'statement',\n    BINARY: 'binary',\n    EXPRESSION: 'binary'\n};\n\nnode.interpretBlock = function (block, context) {\n    block = block || [];\n    for (var i = 0; i < block.length; i++) {\n        block[i].interpret(context);\n    }\n    return context;\n};\n\nrequire('./literals')(node, constants);\nrequire('./constant')(node, constants);\nrequire('./variable')(node, constants);\nrequire('./assignment')(node, constants);\nrequire('./conditional-statements')(node, constants);\nrequire('./binary-operations')(node, constants);\nrequire('./unary-operations')(node, constants);\nrequire('./primitive-functions')(node, constants);\nrequire('./primitive-procedures')(node, constants);\nrequire('./routine-calls')(node, constants);\nrequire('./routine-declarations')(node, constants);\nrequire('./repetition-statements')(node, constants);\nrequire('./program-root')(node, constants);\n\nmodule.exports = node;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/nodes.js\n// module id = 12\n// module chunks = 0","module.exports = function (node, constants) {\n    node.HasStones = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'hasStones';\n        this.parameters = parameters;\n    };\n\n    node.HasStones.prototype.eval = function (context) {\n        return context.board().amountStones(this.parameters[0].eval(context)) > 0;\n    };\n\n    node.CanMove = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'canMove';\n        this.parameters = parameters;\n    };\n\n    node.CanMove.prototype.eval = function (context) {\n        return context.board().canMove(this.parameters[0].eval(context));\n    };\n\n    node.NumStones = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'numStones';\n        this.parameters = parameters;\n    };\n\n    node.NumStones.prototype.eval = function (context) {\n        return context.board().amountStones(this.parameters[0].eval(context));\n    };\n\n    node.MinDir = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'minDir';\n        this.parameters = parameters;\n    };\n\n    node.MinDir.prototype.eval = function (context) {\n        return context.nativeRepresentations().minDir;\n    };\n\n    node.MaxDir = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'maxDir';\n        this.parameters = parameters;\n    };\n\n    node.MaxDir.prototype.eval = function (context) {\n        return context.nativeRepresentations().maxDir;\n    };\n\n    node.MaxColor = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'maxColor';\n        this.parameters = parameters;\n    };\n\n    node.MaxColor.prototype.eval = function (context) {\n        return context.nativeRepresentations().maxColor;\n    };\n\n    node.MinColor = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'minColor';\n        this.parameters = parameters;\n    };\n\n    node.MinColor.prototype.eval = function (context) {\n        return context.nativeRepresentations().minColor;\n    };\n\n    node.MinBool = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'minBool';\n        this.parameters = parameters;\n    };\n\n    node.MinBool.prototype.eval = function () {\n        return false;\n    };\n\n    node.MaxBool = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'maxBool';\n        this.parameters = parameters;\n    };\n\n    node.MaxBool.prototype.eval = function () {\n        return true;\n    };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/primitive-functions.js\n// module id = 13\n// module chunks = 0","module.exports = function (node, constants) {\n    node.MoveClaw = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.STM;\n        this.name = 'MoveClaw';\n        this.parameters = parameters;\n    };\n\n    node.MoveClaw.prototype.interpret = function (context) {\n        try {\n            context.board().move(this.parameters[0].eval(context));\n        } catch (err) {\n            err.on = this.token;\n            throw err;\n        }\n        return context;\n    };\n\n    node.RemoveStone = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.STM;\n        this.name = 'Grab';\n        this.parameters = parameters;\n    };\n\n    node.RemoveStone.prototype.interpret = function (context) {\n        try {\n            context.board().removeStone(this.parameters[0].eval(context));\n        } catch (err) {\n            err.on = this.token;\n            throw err;\n        }\n        return context;\n    };\n\n    node.PutStone = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.STM;\n        this.name = 'Drop';\n        this.parameters = parameters;\n    };\n\n    node.PutStone.prototype.interpret = function (context) {\n        context.board().putStone(this.parameters[0].eval(context));\n        return context;\n    };\n\n    node.MoveToEdge = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.STM;\n        this.name = 'MoveToEdge';\n        this.parameters = parameters;\n    };\n\n    node.MoveToEdge.prototype.interpret = function (context) {\n        context.board().moveToEdge(this.parameters[0].eval(context));\n        return context;\n    };\n\n    node.CleanBoard = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.STM;\n        this.name = 'MoveToEdge';\n        this.parameters = parameters;\n    };\n\n    node.CleanBoard.prototype.interpret = function (context) {\n        context.board().clear();\n        return context;\n    };\n\n    node.Boom = function (token) {\n        this.token = token;\n        this.arity = constants.STM;\n        this.name = 'BOOM';\n    };\n\n    node.Boom.prototype.interpret = function (context) {\n        try {\n            context.board().boom();\n        } catch (err) {\n            err.on = node;\n            throw err;\n        }\n        return context;\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/primitive-procedures.js\n// module id = 14\n// module chunks = 0","module.exports = function (node) {\n    node.Program = function (token, body) {\n        this.token = token;\n        this.alias = 'program';\n        this.body = body || [];\n    };\n\n    node.Program.prototype.interpret = function (context) {\n        node.interpretBlock(this.body, context);\n        return context;\n    };\n\n    node.Root = function (program, declarations) {\n        this.alias = 'root';\n        this.program = program;\n        this.declarations = declarations;\n    };\n\n    node.Root.prototype.interpret = function (context) {\n        this.program.interpret(context);\n        return context;\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/program-root.js\n// module id = 15\n// module chunks = 0","module.exports = function (node) {\n    node.While = function (token, expression, body) {\n        this.alias = 'while';\n        this.token = token;\n        this.expression = expression;\n        this.body = body;\n    };\n\n    node.While.prototype.interpret = function (context) {\n        while (this.expression.eval(context)) {\n            node.interpretBlock(this.body, context);\n        }\n        return context;\n    };\n\n    node.Repeat = function (token, expression, body) {\n        this.alias = 'repeat';\n        this.token = token;\n        this.expression = expression;\n        this.body = body;\n    };\n\n    node.Repeat.prototype.interpret = function (context) {\n        var value = this.expression.eval(context);\n        for (var i = 0; i < value; i++) {\n            node.interpretBlock(this.body, context);\n        }\n        return context;\n    };\n\n    node.ForEach = function (token, iterator, rangeLeft, rangeRight, body) {\n        this.alias = 'foreach';\n        this.token = token;\n        this.iterator = iterator;\n        this.rangeLeft = rangeLeft;\n        this.rangeRight = rangeRight;\n        this.body = body;\n    };\n\n    node.ForEach.prototype.interpret = function (context) {\n        var rangeLeft = this.rangeLeft.eval(context);\n        var rangeRight = this.rangeRight.eval(context);\n\n        if (typeof rangeLeft !== typeof rangeRight) {\n            node.errors.throwInterpreterError(this.token, 'El rando del foreach debe ser mismos tipos de datos');\n        }\n\n        var values = context.nativeRepresentations();\n        var items = [];\n        if (typeof rangeLeft === 'object') {\n            if (rangeLeft[0] === values.minDir[0] && rangeLeft[1] === values.minDir[1]) {\n                items = [values.north, values.east, values.south, values.west];\n            } else {\n                items = [values.west, values.south, values.east, values.north];\n            }\n        } else if (typeof rangeLeft === 'boolean') {\n            if (rangeLeft) {\n                items = [true, false];\n            } else {\n                items = [false, true];\n            }\n        } else if (typeof rangeLeft === 'number' && rangeLeft >= values.minColor && rangeLeft <= values.maxColor) {\n            if (rangeLeft === values.minColor) {\n                items = [values.blue, values.red, values.black, values.green];\n            } else {\n                items = [values.green, values.black, values.red, values.blue];\n            }\n        }\n\n        for (var i = 0; i < items.length; i++) {\n            context.put(this.iterator.token.value, items[i]);\n            node.interpretBlock(this.body, context);\n        }\n\n        return context;\n    };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/repetition-statements.js\n// module id = 16\n// module chunks = 0","module.exports = function (node) {\n    function evalArguments(context, parameters) {\n        var results = [];\n        if (parameters) {\n            for (var i = 0; i < parameters.length; i++) {\n                results.push(parameters[i].eval(context));\n            }\n        }\n        return results;\n    }\n\n    function fillParameters(context, parameters, declaration) {\n        // TODO: no se pueden reasignar valores a los parámetros\n        if (declaration.parameters) {\n            for (var i = 0; i < declaration.parameters.length; i++) {\n                context.put(declaration.parameters[i].value, parameters[i]);\n            }\n        }\n    }\n\n    // TODO: el mundo de las variables, índices y parámetros debe ser disjunto por body!!\n\n    node.ProcedureCall = function (token, declarationProvider, parameters) {\n        this.token = token;\n        this.arity = 'routine';\n        this.alias = 'ProcedureCall';\n        this.name = token.value;\n        this.parameters = parameters;\n        this.declarationProvider = declarationProvider;\n    };\n\n    node.ProcedureCall.prototype.interpret = function (context) {\n        var target = this.declarationProvider();\n        if (!target.declaration) {\n            throw new node.errors.InterpreterException('El procedimiento ' + this.name + ' no se encuentra definido.', this.node);\n        }\n        var declaration = target.declaration;\n        var parameterValues = evalArguments(context, this.parameters);\n        context.startContext();\n        fillParameters(context, parameterValues, declaration);\n        node.interpretBlock(declaration.body, context);\n        context.stopContext();\n        return context;\n    };\n\n    node.FunctionCall = function (token, declarationProvider, parameters) {\n        this.token = token;\n        this.arity = 'routine';\n        this.alias = 'FunctionCall';\n        this.name = token.value;\n        this.parameters = parameters;\n        this.declarationProvider = declarationProvider;\n    };\n\n    node.FunctionCall.prototype.eval = function (context) {\n        var target = this.declarationProvider();\n        if (!target.declaration) {\n            throw new node.errors.InterpreterException('La función \"' + this.name + '\" no se encuentra definida.', this.node);\n        }\n        var declaration = target.declaration;\n        var parameterValues = evalArguments(context, this.parameters);\n        context.startContext();\n        context.pushBoard();\n        fillParameters(context, parameterValues, declaration);\n        node.interpretBlock(target.body, context);\n        var result = declaration.return.expression.eval(context);\n        context.popBoard();\n        context.stopContext();\n        return result;\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/routine-calls.js\n// module id = 17\n// module chunks = 0","module.exports = function (node) {\n    node.ProcedureDeclaration = function (token, parameters, body) {\n        this.token = token;\n        this.name = token.value;\n        this.arity = 'routine';\n        this.alias = 'procedureDeclaration';\n        this.parameters = parameters || [];\n        this.body = body || [];\n    };\n\n    node.FunctionDeclaration = function (token, parameters, body, returnExpression) {\n        this.token = token;\n        this.name = token.value;\n        this.arity = 'routine';\n        this.alias = 'functionDeclaration';\n        this.parameters = parameters || [];\n        this.body = body || [];\n        this.return = returnExpression;\n    };\n\n    node.ReturnStatement = function (token, expression) {\n        this.token = token;\n        this.alias = 'return';\n        this.expression = expression;\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/routine-declarations.js\n// module id = 18\n// module chunks = 0","module.exports = function (node) {\n    node.NotOperation = function (token, expression) {\n        this.token = token;\n        this.expression = expression;\n    };\n\n    node.NotOperation.prototype.eval = function (context) {\n        return !this.expression.eval(context);\n    };\n\n    node.SubstractionOperation = function (token, expression) {\n        this.token = token;\n        this.expression = expression;\n    };\n\n    node.SubstractionOperation.prototype.eval = function (context) {\n        return -this.expression.eval(context);\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/unary-operations.js\n// module id = 19\n// module chunks = 0","module.exports = function (node) {\n    node.Variable = function (token, id) {\n        this.token = token;\n        this.id = id;\n    };\n\n    node.Variable.prototype.eval = function (context) {\n        return context.get(this.id);\n    };\n\n    return node;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/variable.js\n// module id = 20\n// module chunks = 0","var doNothing = function () {\n};\n\nmodule.exports = (console && console.log) ? console.log : doNothing;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/utils/logger.js\n// module id = 21\n// module chunks = 0"],"sourceRoot":""}