{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.umd.min.js","webpack:///webpack/bootstrap 5c93a0a1552f2acb8fa4","webpack:///./lib/gbs.js","webpack:///./lib/utils/errors.js","webpack:///./lib/grammar/grammar.js","webpack:///./lib/grammar/parser.js","webpack:///./lib/grammar/reserved-words.js","webpack:///./lib/grammar/scope.js","webpack:///./lib/lexer/lexer.js","webpack:///./lib/model/execution-context.js","webpack:///./lib/model/model.js","webpack:///./lib/nodes/assignment.js","webpack:///./lib/nodes/binary-operations.js","webpack:///./lib/nodes/conditional-statements.js","webpack:///./lib/nodes/constant.js","webpack:///./lib/nodes/literals.js","webpack:///./lib/nodes/nodes.js","webpack:///./lib/nodes/primitive-functions.js","webpack:///./lib/nodes/primitive-procedures.js","webpack:///./lib/nodes/program-root.js","webpack:///./lib/nodes/repetition-statements.js","webpack:///./lib/nodes/routine-calls.js","webpack:///./lib/nodes/routine-declarations.js","webpack:///./lib/nodes/unary-operations.js","webpack:///./lib/nodes/variable.js","webpack:///./lib/utils/logger.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","gbs","grammar","Parser","Lexer","node","errors","Context","getParser","log","throwParserError","token","description","someError","error","on","throwInterpreterError","message","InterpreterException","prototype","Error","TOKEN_NAMES","commaSeparatedArguments","parser","parameters","push","expression","advance","parameterListCall","parameterDeclarationList","g","arity","parenthesisExpression","bodyStatement","block","bodyStatementWithOptionalMultiline","statement","defineConstant","symbol","alias","value","type","nud","Constant","NumericLiteral","Variable","op","OrOperation","AndOperation","SumOperation","DiffOperation","MulOperation","DIV","DivOperation","MOD","ModOperation","infixr","left","ExpOperation","prefix","NOT","NotOperation","SubstractionOperation","EqOperation","NotEqualOperation","LessOperation","GraterOperation","LessEqualOperation","GreaterEqualOperation","FALSE","BOOLEAN","TRUE","BLUE","COLOR","RED","BLACK","GREEN","NORTH","DIRECTION","SOUTH","EAST","WEST","IN","ELSE","TO","separator","stmt","infix","toUpperCase","ProcedureCall","scope","find","FunctionCall","Assignment","DROP","PutStone","GRAB","RemoveStone","MOVE","MoveClaw","MOVE_TO_EDGE","MoveToEdge","CLEAN_BOARD","CleanBoard","BOOM","Boom","HAS_STONES","HasStones","NUM_STONES","NumStones","MAX_COLOR","MaxColor","MIN_COLOR","MinColor","MAX_DIR","MaxDir","MIN_DIR","MinDir","MAX_BOOL","MaxBool","MIN_BOOL","MinBool","CAN_MOVE","CanMove","IF","condition","trueBranch","falseBranch","reserve","If","SWITCH","cases","exp","body","case","tokens","hasNext","Switch","WHILE","While","REPEAT","Repeat","FOR_EACH","iterator","rangeLeft","rangeRight","ForEach","a","statements","PROGRAM","Program","FUNCTION","newScope","toLowerCase","ret","pop","RETURN","declaration","FunctionDeclaration","ReturnStatement","PROCEDURE","ProcedureDeclaration","parse","input","main","declarations","roots","parseProgram","i","length","Root","throwUndefinedSymbolError","throwMissingOperatorError","Scope","OriginalSymbol","led","lexer","symbolTable","bindingPower","s","lbp","rightBindingPower","t","parent","o","v","lastToken","range","start","lastRange","next","parseInt","Object","create","bp","OpDefinition","n","std","statementsList","_currentRange","_applyRangeToSymbol","end","rootDeclaration","f","x","self","right","_parseContextAwareNode","nodeParser","parseExpression","parseStatements","THEN","OPPOSITE","NEXT","PREVIOUS","NUMBER","itself","def","identifier","reserved","name","targetToken","e","suffix","from","startColumn","endColumn","row","punctuators","buf","buflen","_isNewline","_isDigit","_isAlpha","_isAlphanum","_skipNonTokens","current","nextChar","TokenTypes","IDENTIFIER","OPERATOR","EOF","COMMENT","NEWLINE","_refreshCurrentAndNextChars","_processComment","_processIdentifier","_consume","_processOperator","_processNumber","_processError","_make","column","text","substring","newToken","charAt","indexOf","_increaseFrom","_processMultiCharOperator","_incrementStep","_resetColumnCount","chars","_processSingleLineComment","_processMultiLineComment","Board","variablesStack","boardsStack","currentBoard","currentVariables","init","nativeRepresentations","board","put","key","get","all","startContext","stopContext","pushBoard","clone","popBoard","sizeX","sizeY","y","GobstonesError","blue","red","black","green","north","east","south","west","minDir","maxDir","minColor","maxColor","table","j","putStone","color","dropStones","amount","removeStone","boom","clear","amountStones","canMove","vec","nextX","nextY","move","moveToEdge","printAscii","out","az","ro","ne","ve","constants","STM","interpret","context","eval","defineBinaryOperation","className","BinaryOperation","BINARY","Math","floor","pow","interpretBlock","EXPRESSION","err","program","values","items","evalArguments","results","fillParameters","declarationProvider","target","parameterValues","result","return","returnExpression","doNothing","console"],"mappings":"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","file":"index.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gsWeblangCore\"] = factory();\n\telse\n\t\troot[\"gsWeblangCore\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gsWeblangCore\"] = factory();\n\telse\n\t\troot[\"gsWeblangCore\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar gbs = {};\n\tvar grammar = __webpack_require__(2);\n\tgbs.Parser = __webpack_require__(3);\n\tgbs.Lexer = __webpack_require__(6);\n\tgbs.node = __webpack_require__(14);\n\tgbs.errors = __webpack_require__(1);\n\t\n\tgbs.Context = __webpack_require__(7);\n\tgbs.getParser = function () {\n\t    return grammar(gbs);\n\t};\n\t\n\tmodule.exports = gbs;\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar log = __webpack_require__(23);\n\t\n\tvar errors = {};\n\t\n\terrors.throwParserError = function (token, description) {\n\t    var someError = {error: description, on: token};\n\t    log('PARSER ERROR: ', someError);\n\t    throw someError;\n\t};\n\t\n\terrors.throwInterpreterError = function (token, message) {\n\t    throw new errors.InterpreterException(message, token);\n\t};\n\t\n\terrors.InterpreterException = function (message, on) {\n\t    this.message = message;\n\t    this.on = on;\n\t};\n\terrors.InterpreterException.prototype = new Error();\n\t\n\tmodule.exports = errors;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar TOKEN_NAMES = __webpack_require__(4);\n\t\n\tmodule.exports = function (gbs) {\n\t    var g = new gbs.Parser(new gbs.Lexer());\n\t    var define = g;\n\t\n\t    function commaSeparatedArguments(parser) {\n\t        var parameters = [];\n\t        if (parser.token.id !== ')') {\n\t            for (; ;) {\n\t                parameters.push(parser.expression(0));\n\t                if (parser.token.id !== ',') {\n\t                    break;\n\t                }\n\t                parser.advance(',');\n\t            }\n\t        }\n\t        return parameters;\n\t    }\n\t\n\t    function parameterListCall(parser) {\n\t        parser.advance('(');\n\t        var parameters = commaSeparatedArguments(parser);\n\t        parser.advance(')');\n\t        return parameters;\n\t    }\n\t\n\t    function parameterDeclarationList() {\n\t        var parameters = [];\n\t        g.advance('(');\n\t        if (g.token.id !== ')') {\n\t            for (; ;) {\n\t                if (g.token.arity !== 'name') {\n\t                    g.error(g.token, 'Se esperaba un nombre de parámetro.');\n\t                }\n\t                parameters.push(g.token);\n\t                g.advance();\n\t                if (g.token.id !== ',') {\n\t                    break;\n\t                }\n\t                g.advance(',');\n\t            }\n\t        }\n\t        g.advance(')');\n\t        return parameters;\n\t    }\n\t\n\t    function parenthesisExpression() {\n\t        g.advance('(');\n\t        var p = g.expression(0);\n\t        g.advance(')');\n\t        return p;\n\t    }\n\t\n\t    function bodyStatement() {\n\t        return g.block() || [];\n\t    }\n\t\n\t    function bodyStatementWithOptionalMultiline() {\n\t        return (g.token.id === '{') ? bodyStatement() : [g.statement()];\n\t    }\n\t\n\t    function defineConstant(symbol, alias, value, type) {\n\t        var token = g.symbol(symbol);\n\t        token.nud = function () {\n\t            return new gbs.node.Constant(token, alias, value, type);\n\t        };\n\t    }\n\t\n\t    define.symbol('(end)');\n\t    define.symbol('(literal)').nud = function () {\n\t        return new gbs.node.NumericLiteral(this, this.value);\n\t    };\n\t\n\t    define.symbol('(name)').nud = function () {\n\t        return new gbs.node.Variable(this, this.value);\n\t    };\n\t\n\t    define.op('||', 20, gbs.node.OrOperation);\n\t    define.op('&&', 25, gbs.node.AndOperation);\n\t\n\t    define.op('+', 50, gbs.node.SumOperation);\n\t    define.op('-', 50, gbs.node.DiffOperation);\n\t    define.op('*', 60, gbs.node.MulOperation);\n\t    // TODO: chequear que efectivamente sean no asociativos\n\t    define.op(TOKEN_NAMES.DIV, 70, gbs.node.DivOperation);\n\t    define.op(TOKEN_NAMES.MOD, 70, gbs.node.ModOperation);\n\t\n\t    define.infixr('^', 80, function (left) {\n\t        return new gbs.node.ExpOperation(g.token, left, g.expression(80));\n\t    });\n\t    // TODO: chequear cómo se comporta el NOT\n\t    define.prefix(TOKEN_NAMES.NOT, function () {\n\t        return new gbs.node.NotOperation(g.token, g.expression(70));\n\t    });\n\t    define.prefix('-', function () {\n\t        return new gbs.node.SubstractionOperation(g.token, g.expression(70));\n\t    });\n\t\n\t    define.op('==', 40, gbs.node.EqOperation);\n\t    define.op('/=', 40, gbs.node.NotEqualOperation);\n\t    define.op('<', 40, gbs.node.LessOperation);\n\t    define.op('>', 40, gbs.node.GraterOperation);\n\t    define.op('<=', 40, gbs.node.LessEqualOperation);\n\t    define.op('>=', 40, gbs.node.GreaterEqualOperation);\n\t\n\t    defineConstant(TOKEN_NAMES.FALSE, 'False', false, TOKEN_NAMES.BOOLEAN);\n\t    defineConstant(TOKEN_NAMES.TRUE, 'True', true, TOKEN_NAMES.BOOLEAN);\n\t    defineConstant(TOKEN_NAMES.BLUE, 'Blue', 0, TOKEN_NAMES.COLOR);\n\t    defineConstant(TOKEN_NAMES.RED, 'Red', 1, TOKEN_NAMES.COLOR);\n\t    defineConstant(TOKEN_NAMES.BLACK, 'Black', 2, TOKEN_NAMES.COLOR);\n\t    defineConstant(TOKEN_NAMES.GREEN, 'Green', 3, TOKEN_NAMES.COLOR);\n\t    defineConstant(TOKEN_NAMES.NORTH, 'North', [0, 1], TOKEN_NAMES.DIRECTION);\n\t    defineConstant(TOKEN_NAMES.SOUTH, 'South', [0, -1], TOKEN_NAMES.DIRECTION);\n\t    defineConstant(TOKEN_NAMES.EAST, 'East', [1, 0], TOKEN_NAMES.DIRECTION);\n\t    defineConstant(TOKEN_NAMES.WEST, 'West', [-1, 0], TOKEN_NAMES.DIRECTION);\n\t\n\t    define.symbol(':');\n\t    define.symbol(')');\n\t    define.symbol('(');\n\t    define.symbol('[');\n\t    define.symbol(']');\n\t    define.symbol('}');\n\t    define.symbol(',');\n\t    define.symbol('->');\n\t    define.symbol('..');\n\t    define.symbol(TOKEN_NAMES.IN);\n\t    define.symbol(TOKEN_NAMES.ELSE);\n\t    define.symbol(TOKEN_NAMES.TO);\n\t\n\t    var separator = {separator: ';'};\n\t    define.stmt(';', function () {\n\t        return separator;\n\t    });\n\t\n\t    define.infix('(', 80, function (left) {\n\t        if (left.token.arity !== 'name') {\n\t            gbs.errors.throwParserError(left, left.token.value + ' no es una función o procedimiento');\n\t        }\n\t        var parameters = commaSeparatedArguments(g);\n\t        g.advance(')');\n\t        var node;\n\t        if (left.token.value[0].toUpperCase() === left.token.value[0]) {\n\t            node = new gbs.node.ProcedureCall(left.token, function () {\n\t                return g.scope.find(left.token.value);\n\t            }, parameters);\n\t        } else {\n\t            node = new gbs.node.FunctionCall(left.token, function () {\n\t                return g.scope.find(left.token.value);\n\t            }, parameters);\n\t        }\n\t        return node;\n\t    });\n\t\n\t    define.infixr(':=', 10, function (left) {\n\t        if (left.id !== '.' && left.id !== '[' && (!left.token || left.token.arity !== 'name')) {\n\t            g.error(left, 'Del lado izquierdo de la asignación sólo pueden usarse identificadores');\n\t        }\n\t        return new gbs.node.Assignment({}, left, g.expression(9));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.DROP, function () {\n\t        return new gbs.node.PutStone(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.GRAB, function () {\n\t        return new gbs.node.RemoveStone(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.MOVE, function () {\n\t        return new gbs.node.MoveClaw(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.MOVE_TO_EDGE, function () {\n\t        return new gbs.node.MoveToEdge(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.CLEAN_BOARD, function () {\n\t        return new gbs.node.CleanBoard(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.BOOM, function () {\n\t        var token = g.token;\n\t        if (parenthesisExpression(g)) {\n\t            gbs.errors.throwParserError(token, 'BOOM no lleva parámetros');\n\t        }\n\t        return new gbs.node.Boom(token);\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.HAS_STONES, function () {\n\t        return new gbs.node.HasStones(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.NUM_STONES, function () {\n\t        return new gbs.node.NumStones(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.MAX_COLOR, function () {\n\t        return new gbs.node.MaxColor(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.MIN_COLOR, function () {\n\t        return new gbs.node.MinColor(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.MAX_DIR, function () {\n\t        return new gbs.node.MaxDir(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.MIN_DIR, function () {\n\t        return new gbs.node.MinDir(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.MAX_BOOL, function () {\n\t        return new gbs.node.MaxBool(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.MIN_BOOL, function () {\n\t        return new gbs.node.MinBool(g.token, parameterListCall(g));\n\t    });\n\t\n\t    define.prefix(TOKEN_NAMES.CAN_MOVE, function () {\n\t        var id = g.token;\n\t        var parameters = parameterListCall(g);\n\t        return new gbs.node.CanMove(id, parameters);\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.IF, function () {\n\t        var token = g.token;\n\t        g.advance('(');\n\t        var condition = g.expression(0);\n\t        g.advance(')');\n\t        var trueBranch = bodyStatement(g);\n\t        var falseBranch = null;\n\t        if (g.token.id === TOKEN_NAMES.ELSE) {\n\t            g.scope.reserve(g.token);\n\t            g.advance(TOKEN_NAMES.ELSE);\n\t            falseBranch = bodyStatement(g);\n\t        }\n\t        return new gbs.node.If(token, condition, trueBranch, falseBranch);\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.SWITCH, function () {\n\t        var token = g.token;\n\t        var condition = parenthesisExpression(g);\n\t        if (g.token.id === TOKEN_NAMES.TO) {\n\t            g.advance(TOKEN_NAMES.TO);\n\t        }\n\t        g.advance('{');\n\t        var cases = [];\n\t        for (; ;) {\n\t            var exp = g.expression(0);\n\t            g.advance('->');\n\t            var body = bodyStatementWithOptionalMultiline(g);\n\t            cases.push({\n\t                case: exp,\n\t                body: body\n\t            });\n\t            if (g.token.id === '}' || !g.tokens.hasNext()) {\n\t                break;\n\t            }\n\t        }\n\t        g.advance('}');\n\t        return new gbs.node.Switch(token, condition, cases);\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.WHILE, function () {\n\t        return new gbs.node.While(g.token, parenthesisExpression(g), bodyStatement(g));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.REPEAT, function () {\n\t        return new gbs.node.Repeat(g.token, parenthesisExpression(g), bodyStatement(g));\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.FOR_EACH, function () {\n\t        // foreach dir in [minDir() .. maxDir()]\n\t        var iterator = g.expression();\n\t        if (iterator.token.arity !== 'name') {\n\t            g.error(iterator.token, 'El foreach espera un identificador sobre el cual iterar');\n\t        }\n\t        g.advance(TOKEN_NAMES.IN);\n\t        g.advance('[');\n\t        var rangeLeft = g.expression();\n\t        g.advance('..');\n\t        var rangeRight = g.expression();\n\t        g.advance(']');\n\t        return new gbs.node.ForEach(g.token, iterator, rangeLeft, rangeRight, g.block());\n\t    });\n\t\n\t    define.stmt('{', function () {\n\t        var a = g.statements();\n\t        g.advance('}');\n\t        return a;\n\t    });\n\t\n\t    define.stmt('(', function () {\n\t        var a = g.statements();\n\t        g.advance(')');\n\t        return a;\n\t    });\n\t\n\t    define.prefix('(', function () {\n\t        var expression = g.expression(0);\n\t        g.advance(')');\n\t        return expression;\n\t    });\n\t\n\t    define.root(TOKEN_NAMES.PROGRAM, function () {\n\t        return new gbs.node.Program(g.token, g.block());\n\t    });\n\t\n\t    define.root(TOKEN_NAMES.FUNCTION, function () {\n\t        g.newScope();\n\t        var token = g.token;\n\t        if (g.token.arity === 'name') {\n\t            if (g.token.value[0] !== g.token.value[0].toLowerCase()) {\n\t                g.error(token, 'El nombre de la función ' + token.value + ' debe emepzar con minúscula');\n\t            }\n\t            g.scope.define(token);\n\t            g.advance();\n\t        } else {\n\t            g.error(token, 'Se esperaba un nombre de función');\n\t        }\n\t        var parameters = parameterDeclarationList(g);\n\t        var body = bodyStatement(g);\n\t\n\t        var ret = body.pop();\n\t        if (!ret || ret.alias !== 'return' || !ret.expression) {\n\t            g.error(token, 'La función ' + token.value + ' debe terminar con un ' + TOKEN_NAMES.RETURN);\n\t        }\n\t        g.scope.pop();\n\t        var declaration = new gbs.node.FunctionDeclaration(token, parameters, body, ret);\n\t        token.declaration = declaration;\n\t        return declaration;\n\t    });\n\t\n\t    define.stmt(TOKEN_NAMES.RETURN, function () {\n\t        return new gbs.node.ReturnStatement(g.token, parenthesisExpression(g));\n\t    });\n\t\n\t    define.root(TOKEN_NAMES.PROCEDURE, function () {\n\t        g.newScope();\n\t        var token = g.token;\n\t        if (g.token.arity === 'name') {\n\t            if (g.token.value[0] !== g.token.value[0].toUpperCase()) {\n\t                g.error(token, 'El nombre del procedimiento ' + token.value + ' debe emepzar con mayúscula');\n\t            }\n\t            g.scope.define(token);\n\t            g.advance();\n\t        } else {\n\t            g.error(token, 'Se esperaba un nombre de procedimiento');\n\t        }\n\t        var parameters = parameterDeclarationList(g);\n\t        var body = bodyStatement();\n\t        g.scope.pop();\n\t        var declaration = new gbs.node.ProcedureDeclaration(token, parameters, body);\n\t        token.declaration = declaration;\n\t        return declaration;\n\t    });\n\t\n\t    define.parse = function (input) {\n\t        var main;\n\t        var declarations = [];\n\t        var roots = g.parseProgram(input);\n\t        for (var i = 0; i < roots.length; i++) {\n\t            if (roots[i].alias === 'program') {\n\t                main = roots[i];\n\t            } else {\n\t                declarations.push(roots[i]);\n\t            }\n\t        }\n\t        return new gbs.node.Root(main, declarations);\n\t    };\n\t\n\t    return g;\n\t};\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar errors = __webpack_require__(1);\n\tvar Scope = __webpack_require__(5);\n\t\n\tfunction throwUndefinedSymbolError() {\n\t    errors.throwParserError(this, 'No definido');\n\t}\n\t\n\tfunction throwMissingOperatorError() {\n\t    errors.throwParserError(this, 'No se encontró el operador');\n\t}\n\t\n\tvar OriginalSymbol = function () {\n\t    this.nud = throwUndefinedSymbolError;\n\t    this.led = throwMissingOperatorError;\n\t};\n\t\n\tvar Parser = function (lexer) {\n\t    this.scope = null;\n\t    this.token = null;\n\t    this.tokens = lexer;\n\t    this.symbolTable = {};\n\t};\n\t\n\tParser.prototype.symbol = function (id, bindingPower) {\n\t    var s = this.symbolTable[id];\n\t    bindingPower = bindingPower || 0;\n\t    if (s) {\n\t        if (bindingPower > s.lbp) {\n\t            s.lbp = bindingPower;\n\t        }\n\t    } else {\n\t        s = new OriginalSymbol();\n\t        s.id = s.value = id;\n\t        s.lbp = bindingPower;\n\t        this.symbolTable[id] = s;\n\t    }\n\t    return s;\n\t};\n\t\n\tParser.prototype.expression = function (rightBindingPower) {\n\t    rightBindingPower = rightBindingPower || 0;\n\t    var left;\n\t    var t = this.token;\n\t    this.advance();\n\t    left = t.nud();\n\t    while (rightBindingPower < this.token.lbp) {\n\t        t = this.token;\n\t        this.advance();\n\t        left = t.led(left);\n\t    }\n\t    return left;\n\t};\n\t\n\tParser.prototype.error = function (token, message) {\n\t    errors.throwParserError(token, message);\n\t};\n\t\n\tParser.prototype.newScope = function () {\n\t    var s = this.scope;\n\t    this.scope = new Scope(this);\n\t    this.scope.parent = s;\n\t    return this.scope;\n\t};\n\t\n\tParser.prototype.advance = function (id) {\n\t    var a;\n\t    var o;\n\t    var t;\n\t    var v;\n\t    var tokens = this.tokens;\n\t    if (id && this.token.id !== id) {\n\t        if (this.lastToken && this.lastToken.range && this.token.range) {\n\t            this.token.range.start = this.lastToken.range.start;\n\t        }\n\t        errors.throwParserError(this.token, 'Se esperaba \"' + id + '\" pero se encontró \"' + this.token.value + '\"');\n\t    }\n\t    if (!tokens.hasNext()) {\n\t        var lastRange = this.token.range;\n\t        this.token = this.symbolTable['(end)'];\n\t        this.token.range = lastRange;\n\t        return this.token;\n\t    }\n\t    t = tokens.next();\n\t    v = t.value;\n\t    a = t.type;\n\t    if (a === 'name') {\n\t        o = this.scope.find(v);\n\t        if (o.arity === 'routine') {\n\t            // force late binding\n\t            o = this.symbolTable['(name)'];\n\t        }\n\t    } else if (a === 'operator') {\n\t        o = this.symbolTable[v];\n\t        if (!o) {\n\t            errors.throwParserError(t, 'Unknown operator.');\n\t        }\n\t    } else if (a === 'number') {\n\t        o = this.symbolTable['(literal)'];\n\t        a = 'literal';\n\t        v = parseInt(v, 10);\n\t    } else {\n\t        errors.throwParserError(t, 'Unexpected token.');\n\t    }\n\t\n\t    var token = Object.create(o);\n\t    token.range = t.range;\n\t    token.value = v;\n\t    token.arity = a;\n\t    this.lastToken = this.token;\n\t    this.token = token;\n\t    return token;\n\t};\n\t\n\tParser.prototype.op = function (id, bp, OpDefinition) {\n\t    var parser = this;\n\t    var s = this.symbol(id, bp);\n\t    s.led = function (left) {\n\t        return new OpDefinition(this, left, parser.expression(bp));\n\t    };\n\t    return s;\n\t};\n\t\n\tParser.prototype.statement = function () {\n\t    var n = this.token;\n\t    var v;\n\t    if (n.std) {\n\t        this.advance();\n\t        this.scope.reserve(n);\n\t        return n.std();\n\t    }\n\t    v = this.expression(0);\n\t    if (v.alias !== ':=' && v.id !== '(' && v.arity !== 'routine') {\n\t        errors.throwParserError(v, 'Bad expression statement.');\n\t    }\n\t    return v;\n\t};\n\t\n\tParser.prototype.statements = function () {\n\t    var statementsList = [];\n\t    var symbol;\n\t    for (; ;) {\n\t        if (this.token.id === '}' || this.token.id === '(end)') {\n\t            break;\n\t        }\n\t        var range = this._currentRange();\n\t        symbol = this.statement();\n\t        if (symbol && !symbol.separator) {\n\t            this._applyRangeToSymbol(range, symbol);\n\t            statementsList.push(symbol);\n\t        }\n\t    }\n\t    if (statementsList.length === 0) {\n\t        return null;\n\t    }\n\t    return statementsList;\n\t};\n\t\n\tParser.prototype._applyRangeToSymbol = function (range, symbol) {\n\t    symbol.range = range;\n\t    if (this.token.range && this.token.range.end) {\n\t        range.end = this.token.range.end;\n\t    }\n\t};\n\t\n\tParser.prototype.rootDeclaration = function () {\n\t    var n = this.token;\n\t    if (!n.root) {\n\t        errors.throwParserError(n, 'Se esperaba una definición de programa, función o procedimiento.');\n\t    }\n\t    this.advance();\n\t    this.scope.reserve(n);\n\t    return n.root();\n\t};\n\t\n\tParser.prototype.stmt = function (symbol, f) {\n\t    var x = this.symbol(symbol);\n\t    x.std = f;\n\t    return x;\n\t};\n\t\n\tParser.prototype.infix = function (id, bp, led) {\n\t    var s = this.symbol(id, bp);\n\t    var self = this;\n\t    s.led = led || function (left) {\n\t        this.left = left;\n\t        this.right = self.expression(bp);\n\t        this.arity = 'binary';\n\t        return this;\n\t    };\n\t    return s;\n\t};\n\t\n\tParser.prototype.infixr = function (id, bp, led) {\n\t    var s = this.symbol(id, bp);\n\t    var self = this;\n\t    s.led = led || function (left) {\n\t        this.left = left;\n\t        this.right = self.expression(bp - 1);\n\t        this.arity = 'binary';\n\t        return this;\n\t    };\n\t    return s;\n\t};\n\t\n\tParser.prototype.prefix = function (id, nud) {\n\t    var s = this.symbol(id);\n\t    var self = this;\n\t    s.nud = nud || function () {\n\t        self.scope.reserve(this);\n\t        this.left = self.expression(70);\n\t        this.arity = 'unary';\n\t        return this;\n\t    };\n\t    return s;\n\t};\n\t\n\tParser.prototype.root = function (symbol, f) {\n\t    var x = this.symbol(symbol);\n\t    x.root = f;\n\t    return x;\n\t};\n\t\n\tParser.prototype.block = function () {\n\t    var t = this.token;\n\t    this.advance('{');\n\t    return t.std();\n\t};\n\t\n\tParser.prototype._currentRange = function () {\n\t    return {start: this.token.range.start, end: this.token.range.end};\n\t};\n\t\n\tParser.prototype.roots = function () {\n\t    var roots = [];\n\t    var symbol;\n\t    for (; ;) {\n\t        if (this.token.id === '(end)') {\n\t            break;\n\t        }\n\t        var range = this._currentRange();\n\t        symbol = this.rootDeclaration();\n\t        if (symbol) {\n\t            this._applyRangeToSymbol(range, symbol);\n\t            roots.push(symbol);\n\t        }\n\t    }\n\t    if (roots.length === 0) {\n\t        return null;\n\t    }\n\t    return roots;\n\t};\n\t\n\tParser.prototype._parseContextAwareNode = function (input, nodeParser) {\n\t    this.tokens.input(input);\n\t    this.newScope();\n\t    this.advance();\n\t    var s = nodeParser();\n\t    this.advance('(end)');\n\t    this.scope.pop();\n\t    return s;\n\t};\n\t\n\tParser.prototype.parseExpression = function (input) {\n\t    var self = this;\n\t    return this._parseContextAwareNode(input, function () {\n\t        return self.expression(0);\n\t    });\n\t};\n\t\n\tParser.prototype.parseProgram = function (input) {\n\t    var self = this;\n\t    return this._parseContextAwareNode(input, function () {\n\t        return self.roots();\n\t    });\n\t};\n\t\n\tParser.prototype.parseStatements = function (input) {\n\t    var self = this;\n\t    return this._parseContextAwareNode(input, function () {\n\t        return self.statements();\n\t    });\n\t};\n\t\n\tmodule.exports = Parser;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tvar TOKEN_NAMES = {\n\t    PROGRAM: 'program',\n\t    PROCEDURE: 'procedure',\n\t    FUNCTION: 'function',\n\t    RETURN: 'return',\n\t    DROP: 'Poner',\n\t    MOVE: 'Mover',\n\t    GRAB: 'Sacar',\n\t    BOOM: 'BOOM',\n\t    MOVE_TO_EDGE: 'IrAlBorde',\n\t    CLEAN_BOARD: 'VaciarTablero',\n\t    REPEAT: 'repeat',\n\t    WHILE: 'while',\n\t    FOR_EACH: 'foreach',\n\t    IN: 'in',\n\t    IF: 'if',\n\t    THEN: 'then',\n\t    ELSE: 'else',\n\t    SWITCH: 'switch',\n\t    TO: 'to',\n\t    OPPOSITE: 'opuesto',\n\t    NEXT: 'siguiente',\n\t    PREVIOUS: 'previo',\n\t    DIV: 'div',\n\t    MOD: 'mod',\n\t    NOT: 'not',\n\t    HAS_STONES: 'hayBolitas',\n\t    CAN_MOVE: 'puedeMover',\n\t    NUM_STONES: 'nroBolitas',\n\t    MIN_DIR: 'minDir',\n\t    MAX_DIR: 'maxDir',\n\t    MIN_COLOR: 'minColor',\n\t    MAX_COLOR: 'maxColor',\n\t    MIN_BOOL: 'minBool',\n\t    MAX_BOOL: 'maxBool',\n\t    RED: 'Rojo',\n\t    BLUE: 'Azul',\n\t    BLACK: 'Negro',\n\t    GREEN: 'Verde',\n\t    TRUE: 'True',\n\t    FALSE: 'False',\n\t    NORTH: 'Norte',\n\t    SOUTH: 'Sur',\n\t    EAST: 'Este',\n\t    WEST: 'Oeste',\n\t    BOOLEAN: 'Booleano',\n\t    COLOR: 'Color',\n\t    DIRECTION: 'Dirección',\n\t    NUMBER: 'Número'\n\t};\n\t\n\tmodule.exports = TOKEN_NAMES;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar errors = __webpack_require__(1);\n\t\n\tfunction itself() {\n\t    return this;\n\t}\n\t\n\tvar Scope = function (parser) {\n\t    this.parser = parser;\n\t    this.def = {};\n\t};\n\t\n\tScope.prototype.define = function (identifier) {\n\t    var t = this.def[identifier.value];\n\t    if (typeof t === 'object') {\n\t        errors.throwParserError(identifier, t.reserved ? 'Already reserved.' : 'Already defined.');\n\t    }\n\t    this.def[identifier.value] = identifier;\n\t    identifier.reserved = false;\n\t    identifier.nud = itself;\n\t    identifier.led = null;\n\t    identifier.std = null;\n\t    identifier.lbp = 0;\n\t    identifier.scope = this.parser.scope;\n\t    return identifier;\n\t};\n\t\n\tScope.prototype.find = function (name) {\n\t    var e = this;\n\t    var targetToken;\n\t    for (; ;) {\n\t        targetToken = e.def[name];\n\t        if (targetToken && typeof targetToken !== 'function') {\n\t            return e.def[name];\n\t        }\n\t        e = e.parent;\n\t        if (!e) {\n\t            targetToken = this.parser.symbolTable[name];\n\t            return targetToken && typeof targetToken !== 'function' ? targetToken : this.parser.symbolTable['(name)'];\n\t        }\n\t    }\n\t};\n\t\n\tScope.prototype.pop = function () {\n\t    this.scope = this.parent;\n\t};\n\t\n\tScope.prototype.reserve = function (name) {\n\t    if (name.arity !== 'name' || name.reserved) {\n\t        return;\n\t    }\n\t    var t = this.def[name.value];\n\t    if (t) {\n\t        if (t.reserved) {\n\t            return;\n\t        }\n\t        if (t.arity === 'name') {\n\t            name.error('Already defined.');\n\t        }\n\t    }\n\t    this.def[name.value] = name;\n\t    name.reserved = true;\n\t};\n\t\n\tmodule.exports = Scope;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tfunction Lexer(prefix, suffix) {\n\t    // Current reading position\n\t    this.from = 0;\n\t    this.startColumn = 0;\n\t    this.endColumn = 0;\n\t    this.row = 0;\n\t    this.prefix = prefix || '/=-<>:|&.';\n\t    this.suffix = suffix || '=|&>.';\n\t\n\t    this.punctuators = '/+-*^.:|&;,()<>{}[]=';\n\t\n\t    // Look ahead position\n\t    this.i = 0;\n\t\n\t    this.buf = null;\n\t    this.buflen = 0;\n\t}\n\t\n\tLexer.prototype.hasNext = function () {\n\t    this._skipNonTokens();\n\t    return this.from < this.buflen;\n\t};\n\t\n\tLexer.prototype.input = function (buf) {\n\t    this.from = 0;\n\t    this.i = 0;\n\t    this.startColumn = 0;\n\t    this.endColumn = 0;\n\t    this.row = 0;\n\t    this.buf = buf;\n\t    this.buflen = buf.length;\n\t    this.current = null;\n\t    this.nextChar = null;\n\t};\n\t\n\tvar TokenTypes = {\n\t    IDENTIFIER: 'name',\n\t    OPERATOR: 'operator',\n\t    EOF: 'eof',\n\t    COMMENT: 'comment',\n\t    NUMBER: 'number',\n\t    NEWLINE: 'newline'\n\t};\n\t\n\t/**\n\t * This method is highly procedural for performance reasons.\n\t * There is no need for the lexer to be too flexible, since the\n\t * semantics will be associated to identifiers on the parser.\n\t *\n\t * @returns Token. The next token on the buffer, or null if the buffer is empty.\n\t */\n\tLexer.prototype.next = function () {\n\t    do {\n\t        this._skipNonTokens();\n\t        this._refreshCurrentAndNextChars();\n\t\n\t        if (this.from >= this.buflen) {\n\t            return null;\n\t        }\n\t    } while (this._processComment());\n\t\n\t    // Always add cases in descending order of occurrence probability\n\t    if (this._processIdentifier()) {\n\t        return this._consume(TokenTypes.IDENTIFIER);\n\t    } else if (this._processOperator()) {\n\t        return this._consume(TokenTypes.OPERATOR);\n\t    } else if (this._processNumber()) {\n\t        return this._consume(TokenTypes.NUMBER);\n\t    }\n\t    return this._processError();\n\t};\n\t\n\t// PRIVATE\n\t\n\tfunction error(token, description) {\n\t    return {error: description, on: token};\n\t}\n\t\n\tLexer.prototype._make = function (type, value) {\n\t    return {\n\t        type: type,\n\t        value: value,\n\t        range: {\n\t            start: {row: this.row, column: this.startColumn},\n\t            end: {row: this.row, column: this.endColumn}\n\t        }\n\t    };\n\t};\n\t\n\tLexer.prototype._consume = function (type) {\n\t    var text = this.buf.substring(this.from, this.i);\n\t    var newToken = this._make(type, text);\n\t    this.from = this.i;\n\t    this.startColumn = this.endColumn;\n\t    return newToken;\n\t};\n\t\n\tLexer.prototype._refreshCurrentAndNextChars = function () {\n\t    this.current = this.buf.charAt(this.from);\n\t    this.nextChar = this.buf.charAt(this.from + 1);\n\t};\n\t\n\tLexer.prototype._processOperator = function () {\n\t    if (this.punctuators.indexOf(this.current) >= 0) {\n\t        this._increaseFrom();\n\t        this._processMultiCharOperator();\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\tLexer.prototype._processMultiCharOperator = function () {\n\t    if (this.prefix.indexOf(this.current) >= 0 && this.suffix.indexOf(this.nextChar) >= 0) {\n\t        this._incrementStep();\n\t    }\n\t};\n\t\n\tLexer.prototype._processNumber = function () {\n\t    if (_isDigit(this.current)) {\n\t        this._increaseFrom();\n\t        while (this.i < this.buflen && _isDigit(this.buf.charAt(this.i))) {\n\t            this._incrementStep();\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\tLexer.prototype._processError = function () {\n\t    this._increaseFrom();\n\t    return error('Unmatched token', this._consume('UNMATCHED'));\n\t};\n\t\n\tLexer.prototype._resetColumnCount = function () {\n\t    this.startColumn = this.endColumn;\n\t};\n\t\n\tLexer.prototype._increaseFrom = function () {\n\t    this.i = this.from + 1;\n\t    this.startColumn = this.startColumn + 1;\n\t    this.endColumn = this.startColumn;\n\t};\n\t\n\tLexer.prototype._incrementStep = function () {\n\t    this.i++;\n\t    this.endColumn++;\n\t};\n\t\n\tLexer.prototype._processIdentifier = function () {\n\t    if (_isAlpha(this.current)) {\n\t        this._increaseFrom();\n\t        while (this.i < this.buflen && _isAlphanum(this.buf.charAt(this.i))) {\n\t            this._incrementStep();\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\tLexer.prototype._skipNonTokens = function () {\n\t    while (this.from < this.buflen) {\n\t        var c = this.buf.charAt(this.from);\n\t        if (c === ' ' || c === '\\t' || c === '\\r' || c === '\\n') {\n\t            if (_isNewline(c)) {\n\t                this.row += 1;\n\t                this.endColumn = 0;\n\t                this.startColumn = 0;\n\t            } else {\n\t                this.startColumn++;\n\t                this.endColumn = this.startColumn;\n\t            }\n\t            this.from++;\n\t            this.i = this.from;\n\t        } else {\n\t            break;\n\t        }\n\t    }\n\t};\n\t\n\tLexer.prototype._processComment = function () {\n\t    var chars = this.current + this.nextChar;\n\t    return this._processSingleLineComment(chars) || this._processMultiLineComment(chars);\n\t};\n\t\n\tLexer.prototype._processSingleLineComment = function (chars) {\n\t    if (chars === '//') {\n\t        while (this.i < this.buflen && !_isNewline(this.buf.charAt(this.i))) {\n\t            this._incrementStep();\n\t        }\n\t        this.from = this.i;\n\t        this.row++;\n\t        this.startColumn = 0;\n\t        this.endColumn = 0;\n\t        return true;\n\t    }\n\t};\n\t\n\tLexer.prototype._processMultiLineComment = function (chars) {\n\t    if (chars === '/*') {\n\t        this._incrementStep();\n\t        this._incrementStep();\n\t        while (this.i < this.buflen && this.buf.charAt(this.i) !== '*' && this.buf.charAt(this.i + 1) !== '/') {\n\t            this._incrementStep();\n\t            if (_isNewline(this.buf.charAt(this.i))) {\n\t                this.endColumn = 0;\n\t            }\n\t        }\n\t        this._incrementStep();\n\t        this._incrementStep();\n\t        this.from = this.i;\n\t        this.endColumn = this.startColumn;\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\tfunction _isNewline(c) {\n\t    return c === '\\r' || c === '\\n';\n\t}\n\t\n\tfunction _isDigit(c) {\n\t    return c >= '0' && c <= '9';\n\t}\n\t\n\tfunction _isAlpha(c) {\n\t    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '_' || c === '\\'';\n\t}\n\t\n\tfunction _isAlphanum(c) {\n\t    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c === '_' || c === '$';\n\t}\n\t\n\tmodule.exports = Lexer;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Board = __webpack_require__(8);\n\t\n\tvar Context = function () {\n\t    var variablesStack = [];\n\t    var boardsStack = [];\n\t    var currentBoard = new Board(9, 9);\n\t    var currentVariables = {};\n\t\n\t    this.init = function () {\n\t        currentBoard.init();\n\t    };\n\t\n\t    this.nativeRepresentations = function () {\n\t        return Board;\n\t    };\n\t\n\t    this.board = function () {\n\t        return currentBoard;\n\t    };\n\t\n\t    this.put = function (key, value) {\n\t        currentVariables[key] = value;\n\t    };\n\t\n\t    this.get = function (id) {\n\t        return currentVariables[id];\n\t    };\n\t\n\t    this.all = function () {\n\t        return currentVariables;\n\t    };\n\t\n\t    this.startContext = function () {\n\t        variablesStack.push(currentVariables);\n\t        currentVariables = {};\n\t    };\n\t\n\t    this.stopContext = function () {\n\t        currentVariables = variablesStack.pop();\n\t    };\n\t\n\t    this.pushBoard = function () {\n\t        boardsStack.push(currentBoard);\n\t        currentBoard = currentBoard.clone();\n\t    };\n\t\n\t    this.popBoard = function () {\n\t        currentBoard = boardsStack.pop();\n\t    };\n\t\n\t    this.init();\n\t};\n\t\n\tmodule.exports = Context;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tvar GobstonesError = function (message) {\n\t    this.message = message;\n\t};\n\tGobstonesError.prototype = new Error('BOOM');\n\t\n\tfunction Board(sizeX, sizeY) {\n\t    this.x = 0;\n\t    this.y = 0;\n\t\n\t    this.sizeX = sizeX;\n\t    this.sizeY = sizeY;\n\t}\n\t\n\tBoard.blue = 0;\n\tBoard.red = 1;\n\tBoard.black = 2;\n\tBoard.green = 3;\n\t\n\tBoard.north = [0, 1];\n\tBoard.east = [1, 0];\n\tBoard.south = [0, -1];\n\tBoard.west = [-1, 0];\n\t\n\tBoard.minDir = Board.north;\n\tBoard.maxDir = Board.west;\n\tBoard.minColor = Board.blue;\n\tBoard.maxColor = Board.green;\n\t\n\tBoard.prototype.init = function () {\n\t    this.table = [[], [], [], []];\n\t    for (var i = 0; i < this.sizeX; i++) {\n\t        this.table[0][i] = [];\n\t        this.table[1][i] = [];\n\t        this.table[2][i] = [];\n\t        this.table[3][i] = [];\n\t        for (var j = 0; j < this.sizeY; j++) {\n\t            this.table[0][i][j] = 0;\n\t            this.table[1][i][j] = 0;\n\t            this.table[2][i][j] = 0;\n\t            this.table[3][i][j] = 0;\n\t        }\n\t    }\n\t};\n\t\n\tBoard.prototype.clone = function () {\n\t    var c = new Board(this.sizeX, this.sizeY);\n\t    c.init();\n\t    for (var i = 0; i < this.sizeX; i++) {\n\t        c.table[0][i] = [];\n\t        c.table[1][i] = [];\n\t        c.table[2][i] = [];\n\t        c.table[3][i] = [];\n\t        for (var j = 0; j < this.sizeY; j++) {\n\t            c.table[0][i][j] = this.table[0][i][j];\n\t            c.table[1][i][j] = this.table[1][i][j];\n\t            c.table[2][i][j] = this.table[2][i][j];\n\t            c.table[3][i][j] = this.table[3][i][j];\n\t        }\n\t    }\n\t    c.x = this.x;\n\t    c.y = this.y;\n\t    return c;\n\t};\n\t\n\tBoard.prototype.putStone = function (color) {\n\t    this.dropStones(color, 1);\n\t};\n\t\n\tBoard.prototype.dropStones = function (color, amount) {\n\t    this.table[color][this.x][this.y] += amount;\n\t};\n\t\n\tBoard.prototype.removeStone = function (color) {\n\t    if (this.table[color][this.x][this.y] <= 0) {\n\t        throw new GobstonesError('Se intentó sacar una bolita pero ya no quedaban bolitas para sacar');\n\t    }\n\t    this.table[color][this.x][this.y] -= 1;\n\t};\n\t\n\tBoard.prototype.boom = function () {\n\t    throw new GobstonesError('BOOM!');\n\t};\n\t\n\tBoard.prototype.clear = function () {\n\t    this.init();\n\t};\n\t\n\tBoard.prototype.amountStones = function (color) {\n\t    return this.table[color][this.x][this.y];\n\t};\n\t\n\tBoard.prototype.canMove = function (vec) {\n\t    var nextX = this.x + vec[0];\n\t    var nextY = this.y + vec[1];\n\t    return nextX < this.sizeX && nextX >= 0 && nextY < this.sizeY && nextY >= 0;\n\t};\n\t\n\tBoard.prototype.move = function (vec) {\n\t    if (!this.canMove(vec)) {\n\t        throw new GobstonesError('Te caiste del tablero por: x=' + this.x + ' y=' + this.y);\n\t    }\n\t    this.x += vec[0];\n\t    this.y += vec[1];\n\t};\n\t\n\tBoard.prototype.moveToEdge = function (vec) {\n\t    if (vec[0] === 1) {\n\t        this.x = this.sizeX - 1;\n\t    } else if (vec[0] === -1) {\n\t        this.x = 0;\n\t    } else if (vec[1] === 1) {\n\t        this.y = this.sizeY - 1;\n\t    } else if (vec[1] === -1) {\n\t        this.y = 0;\n\t    }\n\t};\n\t\n\tBoard.prototype.printAscii = function () {\n\t    var out = this.sizeX + 'x' + this.sizeY + '\\n';\n\t    var az = this.table[0];\n\t    var ro = this.table[1];\n\t    var ne = this.table[2];\n\t    var ve = this.table[3];\n\t    for (var j = this.sizeY - 1; j >= 0; j--) {\n\t        for (var i = 0; i < this.sizeX; i++) {\n\t            out += (az[i][j] || ro[i][j] || ne[i][j] || ve[i][j]) ? '#' : '.';\n\t        }\n\t        out += '\\n';\n\t    }\n\t    return out;\n\t};\n\t\n\tmodule.exports = Board;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node, constants) {\n\t    node.Assignment = function (token, left, right) {\n\t        this.token = token;\n\t        this.arity = constants.STM;\n\t        this.alias = ':=';\n\t        this.left = left;\n\t        this.right = right;\n\t    };\n\t\n\t    node.Assignment.prototype.interpret = function (context) {\n\t        context.put(this.left.token.value, this.right.eval(context));\n\t    };\n\t};\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node, constants) {\n\t    var BinaryOperation = function (token, left, right) {\n\t        this.token = token;\n\t        this.left = left;\n\t        this.right = right;\n\t        this.arity = constants.BINARY;\n\t    };\n\t\n\t    function defineBinaryOperation(className) {\n\t        node[className] = function (token, left, right) {\n\t            BinaryOperation.call(this, token, left, right);\n\t        };\n\t        node[className].prototype = new BinaryOperation();\n\t    }\n\t\n\t    defineBinaryOperation('SumOperation');\n\t    node.SumOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) + this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('DiffOperation');\n\t    node.DiffOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) - this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('MulOperation');\n\t    node.MulOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) * this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('DivOperation');\n\t    node.DivOperation.prototype.eval = function (context) {\n\t        return Math.floor(this.left.eval(context) / this.right.eval(context));\n\t    };\n\t\n\t    defineBinaryOperation('ModOperation');\n\t    node.ModOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) % this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('ExpOperation');\n\t    node.ExpOperation.prototype.eval = function (context) {\n\t        return Math.pow(this.left.eval(context), this.right.eval(context));\n\t    };\n\t\n\t    defineBinaryOperation('AndOperation');\n\t    node.AndOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) && this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('OrOperation');\n\t    node.OrOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) || this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('NotEqualOperation');\n\t    node.NotEqualOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) !== this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('EqOperation');\n\t    node.EqOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) === this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('LessOperation');\n\t    node.LessOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) < this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('GraterOperation');\n\t    node.GraterOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) > this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('LessEqualOperation');\n\t    node.LessEqualOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) <= this.right.eval(context);\n\t    };\n\t\n\t    defineBinaryOperation('GreaterEqualOperation');\n\t    node.GreaterEqualOperation.prototype.eval = function (context) {\n\t        return this.left.eval(context) >= this.right.eval(context);\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.If = function (token, condition, trueBranch, falseBranch) {\n\t        this.token = token;\n\t        this.condition = condition;\n\t        this.trueBranch = trueBranch;\n\t        this.falseBranch = falseBranch;\n\t    };\n\t\n\t    node.If.prototype.interpret = function (context) {\n\t        return node.interpretBlock(this.condition.eval(context) ? this.trueBranch : this.falseBranch, context);\n\t    };\n\t\n\t    node.Switch = function (token, expression, cases) {\n\t        this.token = token;\n\t        this.expression = expression;\n\t        this.cases = cases;\n\t    };\n\t\n\t    node.Switch.prototype.interpret = function (context) {\n\t        var value = this.expression.eval(context);\n\t        for (var i = 0; i < this.cases.length; i++) {\n\t            if (this.cases[i].case.eval(context) === value) {\n\t                node.interpretBlock(this.cases[i].body, context);\n\t                break;\n\t            }\n\t        }\n\t        return context;\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.Constant = function (token, alias, value, type) {\n\t        this.token = token;\n\t        this.value = value;\n\t        this.alias = alias;\n\t        this.type = type;\n\t    };\n\t\n\t    node.Constant.prototype.eval = function () {\n\t        return this.value;\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.NumericLiteral = function (token, value) {\n\t        this.token = token;\n\t        this.value = value;\n\t    };\n\t    node.NumericLiteral.prototype.type = 'number';\n\t\n\t    node.NumericLiteral.prototype.eval = function () {\n\t        return this.value;\n\t    };\n\t};\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar node = {};\n\tnode.errors = __webpack_require__(1);\n\t\n\tvar constants = {\n\t    STM: 'statement',\n\t    BINARY: 'binary',\n\t    EXPRESSION: 'binary'\n\t};\n\t\n\tnode.interpretBlock = function (block, context) {\n\t    block = block || [];\n\t    for (var i = 0; i < block.length; i++) {\n\t        block[i].interpret(context);\n\t    }\n\t    return context;\n\t};\n\t\n\t__webpack_require__(13)(node, constants);\n\t__webpack_require__(12)(node, constants);\n\t__webpack_require__(22)(node, constants);\n\t__webpack_require__(9)(node, constants);\n\t__webpack_require__(11)(node, constants);\n\t__webpack_require__(10)(node, constants);\n\t__webpack_require__(21)(node, constants);\n\t__webpack_require__(15)(node, constants);\n\t__webpack_require__(16)(node, constants);\n\t__webpack_require__(19)(node, constants);\n\t__webpack_require__(20)(node, constants);\n\t__webpack_require__(18)(node, constants);\n\t__webpack_require__(17)(node, constants);\n\t\n\tmodule.exports = node;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node, constants) {\n\t    node.HasStones = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'hasStones';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.HasStones.prototype.eval = function (context) {\n\t        return context.board().amountStones(this.parameters[0].eval(context)) > 0;\n\t    };\n\t\n\t    node.CanMove = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'canMove';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.CanMove.prototype.eval = function (context) {\n\t        return context.board().canMove(this.parameters[0].eval(context));\n\t    };\n\t\n\t    node.NumStones = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'numStones';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.NumStones.prototype.eval = function (context) {\n\t        return context.board().amountStones(this.parameters[0].eval(context));\n\t    };\n\t\n\t    node.MinDir = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'minDir';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MinDir.prototype.eval = function (context) {\n\t        return context.nativeRepresentations().minDir;\n\t    };\n\t\n\t    node.MaxDir = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'maxDir';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MaxDir.prototype.eval = function (context) {\n\t        return context.nativeRepresentations().maxDir;\n\t    };\n\t\n\t    node.MaxColor = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'maxColor';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MaxColor.prototype.eval = function (context) {\n\t        return context.nativeRepresentations().maxColor;\n\t    };\n\t\n\t    node.MinColor = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'minColor';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MinColor.prototype.eval = function (context) {\n\t        return context.nativeRepresentations().minColor;\n\t    };\n\t\n\t    node.MinBool = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'minBool';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MinBool.prototype.eval = function () {\n\t        return false;\n\t    };\n\t\n\t    node.MaxBool = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.EXPRESSION;\n\t        this.name = 'maxBool';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MaxBool.prototype.eval = function () {\n\t        return true;\n\t    };\n\t};\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node, constants) {\n\t    node.MoveClaw = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.STM;\n\t        this.name = 'MoveClaw';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MoveClaw.prototype.interpret = function (context) {\n\t        try {\n\t            context.board().move(this.parameters[0].eval(context));\n\t        } catch (err) {\n\t            err.on = this.token;\n\t            throw err;\n\t        }\n\t        return context;\n\t    };\n\t\n\t    node.RemoveStone = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.STM;\n\t        this.name = 'Grab';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.RemoveStone.prototype.interpret = function (context) {\n\t        try {\n\t            context.board().removeStone(this.parameters[0].eval(context));\n\t        } catch (err) {\n\t            err.on = this.token;\n\t            throw err;\n\t        }\n\t        return context;\n\t    };\n\t\n\t    node.PutStone = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.STM;\n\t        this.name = 'Drop';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.PutStone.prototype.interpret = function (context) {\n\t        context.board().putStone(this.parameters[0].eval(context));\n\t        return context;\n\t    };\n\t\n\t    node.MoveToEdge = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.STM;\n\t        this.name = 'MoveToEdge';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.MoveToEdge.prototype.interpret = function (context) {\n\t        context.board().moveToEdge(this.parameters[0].eval(context));\n\t        return context;\n\t    };\n\t\n\t    node.CleanBoard = function (token, parameters) {\n\t        this.token = token;\n\t        this.arity = constants.STM;\n\t        this.name = 'MoveToEdge';\n\t        this.parameters = parameters;\n\t    };\n\t\n\t    node.CleanBoard.prototype.interpret = function (context) {\n\t        context.board().clear();\n\t        return context;\n\t    };\n\t\n\t    node.Boom = function (token) {\n\t        this.token = token;\n\t        this.arity = constants.STM;\n\t        this.name = 'BOOM';\n\t    };\n\t\n\t    node.Boom.prototype.interpret = function (context) {\n\t        try {\n\t            context.board().boom();\n\t        } catch (err) {\n\t            err.on = node;\n\t            throw err;\n\t        }\n\t        return context;\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.Program = function (token, body) {\n\t        this.token = token;\n\t        this.alias = 'program';\n\t        this.body = body || [];\n\t    };\n\t\n\t    node.Program.prototype.interpret = function (context) {\n\t        node.interpretBlock(this.body, context);\n\t        return context;\n\t    };\n\t\n\t    node.Root = function (program, declarations) {\n\t        this.alias = 'root';\n\t        this.program = program;\n\t        this.declarations = declarations;\n\t    };\n\t\n\t    node.Root.prototype.interpret = function (context) {\n\t        this.program.interpret(context);\n\t        return context;\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.While = function (token, expression, body) {\n\t        this.alias = 'while';\n\t        this.token = token;\n\t        this.expression = expression;\n\t        this.body = body;\n\t    };\n\t\n\t    node.While.prototype.interpret = function (context) {\n\t        while (this.expression.eval(context)) {\n\t            node.interpretBlock(this.body, context);\n\t        }\n\t        return context;\n\t    };\n\t\n\t    node.Repeat = function (token, expression, body) {\n\t        this.alias = 'repeat';\n\t        this.token = token;\n\t        this.expression = expression;\n\t        this.body = body;\n\t    };\n\t\n\t    node.Repeat.prototype.interpret = function (context) {\n\t        var value = this.expression.eval(context);\n\t        for (var i = 0; i < value; i++) {\n\t            node.interpretBlock(this.body, context);\n\t        }\n\t        return context;\n\t    };\n\t\n\t    node.ForEach = function (token, iterator, rangeLeft, rangeRight, body) {\n\t        this.alias = 'foreach';\n\t        this.token = token;\n\t        this.iterator = iterator;\n\t        this.rangeLeft = rangeLeft;\n\t        this.rangeRight = rangeRight;\n\t        this.body = body;\n\t    };\n\t\n\t    node.ForEach.prototype.interpret = function (context) {\n\t        var rangeLeft = this.rangeLeft.eval(context);\n\t        var rangeRight = this.rangeRight.eval(context);\n\t\n\t        if (typeof rangeLeft !== typeof rangeRight) {\n\t            node.errors.throwInterpreterError(this.token, 'El rando del foreach debe ser mismos tipos de datos');\n\t        }\n\t\n\t        var values = context.nativeRepresentations();\n\t        var items = [];\n\t        if (typeof rangeLeft === 'object') {\n\t            if (rangeLeft[0] === values.minDir[0] && rangeLeft[1] === values.minDir[1]) {\n\t                items = [values.north, values.east, values.south, values.west];\n\t            } else {\n\t                items = [values.west, values.south, values.east, values.north];\n\t            }\n\t        } else if (typeof rangeLeft === 'boolean') {\n\t            if (rangeLeft) {\n\t                items = [true, false];\n\t            } else {\n\t                items = [false, true];\n\t            }\n\t        } else if (typeof rangeLeft === 'number' && rangeLeft >= values.minColor && rangeLeft <= values.maxColor) {\n\t            if (rangeLeft === values.minColor) {\n\t                items = [values.blue, values.red, values.black, values.green];\n\t            } else {\n\t                items = [values.green, values.black, values.red, values.blue];\n\t            }\n\t        }\n\t\n\t        for (var i = 0; i < items.length; i++) {\n\t            context.put(this.iterator.token.value, items[i]);\n\t            node.interpretBlock(this.body, context);\n\t        }\n\t\n\t        return context;\n\t    };\n\t};\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    function evalArguments(context, parameters) {\n\t        var results = [];\n\t        if (parameters) {\n\t            for (var i = 0; i < parameters.length; i++) {\n\t                results.push(parameters[i].eval(context));\n\t            }\n\t        }\n\t        return results;\n\t    }\n\t\n\t    function fillParameters(context, parameters, declaration) {\n\t        // TODO: no se pueden reasignar valores a los parámetros\n\t        if (declaration.parameters) {\n\t            for (var i = 0; i < declaration.parameters.length; i++) {\n\t                context.put(declaration.parameters[i].value, parameters[i]);\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO: el mundo de las variables, índices y parámetros debe ser disjunto por body!!\n\t\n\t    node.ProcedureCall = function (token, declarationProvider, parameters) {\n\t        this.token = token;\n\t        this.arity = 'routine';\n\t        this.alias = 'ProcedureCall';\n\t        this.name = token.value;\n\t        this.parameters = parameters;\n\t        this.declarationProvider = declarationProvider;\n\t    };\n\t\n\t    node.ProcedureCall.prototype.interpret = function (context) {\n\t        var target = this.declarationProvider();\n\t        if (!target.declaration) {\n\t            throw new node.errors.InterpreterException('El procedimiento ' + this.name + ' no se encuentra definido.', this.node);\n\t        }\n\t        var declaration = target.declaration;\n\t        var parameterValues = evalArguments(context, this.parameters);\n\t        context.startContext();\n\t        fillParameters(context, parameterValues, declaration);\n\t        node.interpretBlock(declaration.body, context);\n\t        context.stopContext();\n\t        return context;\n\t    };\n\t\n\t    node.FunctionCall = function (token, declarationProvider, parameters) {\n\t        this.token = token;\n\t        this.arity = 'routine';\n\t        this.alias = 'FunctionCall';\n\t        this.name = token.value;\n\t        this.parameters = parameters;\n\t        this.declarationProvider = declarationProvider;\n\t    };\n\t\n\t    node.FunctionCall.prototype.eval = function (context) {\n\t        var target = this.declarationProvider();\n\t        if (!target.declaration) {\n\t            throw new node.errors.InterpreterException('La función \"' + this.name + '\" no se encuentra definida.', this.node);\n\t        }\n\t        var declaration = target.declaration;\n\t        var parameterValues = evalArguments(context, this.parameters);\n\t        context.startContext();\n\t        context.pushBoard();\n\t        fillParameters(context, parameterValues, declaration);\n\t        node.interpretBlock(target.body, context);\n\t        var result = declaration.return.expression.eval(context);\n\t        context.popBoard();\n\t        context.stopContext();\n\t        return result;\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.ProcedureDeclaration = function (token, parameters, body) {\n\t        this.token = token;\n\t        this.name = token.value;\n\t        this.arity = 'routine';\n\t        this.alias = 'procedureDeclaration';\n\t        this.parameters = parameters || [];\n\t        this.body = body || [];\n\t    };\n\t\n\t    node.FunctionDeclaration = function (token, parameters, body, returnExpression) {\n\t        this.token = token;\n\t        this.name = token.value;\n\t        this.arity = 'routine';\n\t        this.alias = 'functionDeclaration';\n\t        this.parameters = parameters || [];\n\t        this.body = body || [];\n\t        this.return = returnExpression;\n\t    };\n\t\n\t    node.ReturnStatement = function (token, expression) {\n\t        this.token = token;\n\t        this.alias = 'return';\n\t        this.expression = expression;\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.NotOperation = function (token, expression) {\n\t        this.token = token;\n\t        this.expression = expression;\n\t    };\n\t\n\t    node.NotOperation.prototype.eval = function (context) {\n\t        return !this.expression.eval(context);\n\t    };\n\t\n\t    node.SubstractionOperation = function (token, expression) {\n\t        this.token = token;\n\t        this.expression = expression;\n\t    };\n\t\n\t    node.SubstractionOperation.prototype.eval = function (context) {\n\t        return -this.expression.eval(context);\n\t    };\n\t}\n\t;\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (node) {\n\t    node.Variable = function (token, id) {\n\t        this.token = token;\n\t        this.id = id;\n\t    };\n\t\n\t    node.Variable.prototype.eval = function (context) {\n\t        return context.get(this.id);\n\t    };\n\t\n\t    return node;\n\t};\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\tvar doNothing = function () {\n\t};\n\t\n\tmodule.exports = (console && console.log) ? console.log : doNothing;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// index.umd.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5c93a0a1552f2acb8fa4","var gbs = {};\nvar grammar = require('./grammar/grammar');\ngbs.Parser = require('./grammar/parser');\ngbs.Lexer = require('./lexer/lexer');\ngbs.node = require('./nodes/nodes');\ngbs.errors = require('./utils/errors');\n\ngbs.Context = require('../lib/model/execution-context');\ngbs.getParser = function () {\n    return grammar(gbs);\n};\n\nmodule.exports = gbs;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/gbs.js\n// module id = 0\n// module chunks = 0","var log = require('./logger');\n\nvar errors = {};\n\nerrors.throwParserError = function (token, description) {\n    var someError = {error: description, on: token};\n    log('PARSER ERROR: ', someError);\n    throw someError;\n};\n\nerrors.throwInterpreterError = function (token, message) {\n    throw new errors.InterpreterException(message, token);\n};\n\nerrors.InterpreterException = function (message, on) {\n    this.message = message;\n    this.on = on;\n};\nerrors.InterpreterException.prototype = new Error();\n\nmodule.exports = errors;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/utils/errors.js\n// module id = 1\n// module chunks = 0","var TOKEN_NAMES = require('./reserved-words');\n\nmodule.exports = function (gbs) {\n    var g = new gbs.Parser(new gbs.Lexer());\n    var define = g;\n\n    function commaSeparatedArguments(parser) {\n        var parameters = [];\n        if (parser.token.id !== ')') {\n            for (; ;) {\n                parameters.push(parser.expression(0));\n                if (parser.token.id !== ',') {\n                    break;\n                }\n                parser.advance(',');\n            }\n        }\n        return parameters;\n    }\n\n    function parameterListCall(parser) {\n        parser.advance('(');\n        var parameters = commaSeparatedArguments(parser);\n        parser.advance(')');\n        return parameters;\n    }\n\n    function parameterDeclarationList() {\n        var parameters = [];\n        g.advance('(');\n        if (g.token.id !== ')') {\n            for (; ;) {\n                if (g.token.arity !== 'name') {\n                    g.error(g.token, 'Se esperaba un nombre de parámetro.');\n                }\n                parameters.push(g.token);\n                g.advance();\n                if (g.token.id !== ',') {\n                    break;\n                }\n                g.advance(',');\n            }\n        }\n        g.advance(')');\n        return parameters;\n    }\n\n    function parenthesisExpression() {\n        g.advance('(');\n        var p = g.expression(0);\n        g.advance(')');\n        return p;\n    }\n\n    function bodyStatement() {\n        return g.block() || [];\n    }\n\n    function bodyStatementWithOptionalMultiline() {\n        return (g.token.id === '{') ? bodyStatement() : [g.statement()];\n    }\n\n    function defineConstant(symbol, alias, value, type) {\n        var token = g.symbol(symbol);\n        token.nud = function () {\n            return new gbs.node.Constant(token, alias, value, type);\n        };\n    }\n\n    define.symbol('(end)');\n    define.symbol('(literal)').nud = function () {\n        return new gbs.node.NumericLiteral(this, this.value);\n    };\n\n    define.symbol('(name)').nud = function () {\n        return new gbs.node.Variable(this, this.value);\n    };\n\n    define.op('||', 20, gbs.node.OrOperation);\n    define.op('&&', 25, gbs.node.AndOperation);\n\n    define.op('+', 50, gbs.node.SumOperation);\n    define.op('-', 50, gbs.node.DiffOperation);\n    define.op('*', 60, gbs.node.MulOperation);\n    // TODO: chequear que efectivamente sean no asociativos\n    define.op(TOKEN_NAMES.DIV, 70, gbs.node.DivOperation);\n    define.op(TOKEN_NAMES.MOD, 70, gbs.node.ModOperation);\n\n    define.infixr('^', 80, function (left) {\n        return new gbs.node.ExpOperation(g.token, left, g.expression(80));\n    });\n    // TODO: chequear cómo se comporta el NOT\n    define.prefix(TOKEN_NAMES.NOT, function () {\n        return new gbs.node.NotOperation(g.token, g.expression(70));\n    });\n    define.prefix('-', function () {\n        return new gbs.node.SubstractionOperation(g.token, g.expression(70));\n    });\n\n    define.op('==', 40, gbs.node.EqOperation);\n    define.op('/=', 40, gbs.node.NotEqualOperation);\n    define.op('<', 40, gbs.node.LessOperation);\n    define.op('>', 40, gbs.node.GraterOperation);\n    define.op('<=', 40, gbs.node.LessEqualOperation);\n    define.op('>=', 40, gbs.node.GreaterEqualOperation);\n\n    defineConstant(TOKEN_NAMES.FALSE, 'False', false, TOKEN_NAMES.BOOLEAN);\n    defineConstant(TOKEN_NAMES.TRUE, 'True', true, TOKEN_NAMES.BOOLEAN);\n    defineConstant(TOKEN_NAMES.BLUE, 'Blue', 0, TOKEN_NAMES.COLOR);\n    defineConstant(TOKEN_NAMES.RED, 'Red', 1, TOKEN_NAMES.COLOR);\n    defineConstant(TOKEN_NAMES.BLACK, 'Black', 2, TOKEN_NAMES.COLOR);\n    defineConstant(TOKEN_NAMES.GREEN, 'Green', 3, TOKEN_NAMES.COLOR);\n    defineConstant(TOKEN_NAMES.NORTH, 'North', [0, 1], TOKEN_NAMES.DIRECTION);\n    defineConstant(TOKEN_NAMES.SOUTH, 'South', [0, -1], TOKEN_NAMES.DIRECTION);\n    defineConstant(TOKEN_NAMES.EAST, 'East', [1, 0], TOKEN_NAMES.DIRECTION);\n    defineConstant(TOKEN_NAMES.WEST, 'West', [-1, 0], TOKEN_NAMES.DIRECTION);\n\n    define.symbol(':');\n    define.symbol(')');\n    define.symbol('(');\n    define.symbol('[');\n    define.symbol(']');\n    define.symbol('}');\n    define.symbol(',');\n    define.symbol('->');\n    define.symbol('..');\n    define.symbol(TOKEN_NAMES.IN);\n    define.symbol(TOKEN_NAMES.ELSE);\n    define.symbol(TOKEN_NAMES.TO);\n\n    var separator = {separator: ';'};\n    define.stmt(';', function () {\n        return separator;\n    });\n\n    define.infix('(', 80, function (left) {\n        if (left.token.arity !== 'name') {\n            gbs.errors.throwParserError(left, left.token.value + ' no es una función o procedimiento');\n        }\n        var parameters = commaSeparatedArguments(g);\n        g.advance(')');\n        var node;\n        if (left.token.value[0].toUpperCase() === left.token.value[0]) {\n            node = new gbs.node.ProcedureCall(left.token, function () {\n                return g.scope.find(left.token.value);\n            }, parameters);\n        } else {\n            node = new gbs.node.FunctionCall(left.token, function () {\n                return g.scope.find(left.token.value);\n            }, parameters);\n        }\n        return node;\n    });\n\n    define.infixr(':=', 10, function (left) {\n        if (left.id !== '.' && left.id !== '[' && (!left.token || left.token.arity !== 'name')) {\n            g.error(left, 'Del lado izquierdo de la asignación sólo pueden usarse identificadores');\n        }\n        return new gbs.node.Assignment({}, left, g.expression(9));\n    });\n\n    define.stmt(TOKEN_NAMES.DROP, function () {\n        return new gbs.node.PutStone(g.token, parameterListCall(g));\n    });\n\n    define.stmt(TOKEN_NAMES.GRAB, function () {\n        return new gbs.node.RemoveStone(g.token, parameterListCall(g));\n    });\n\n    define.stmt(TOKEN_NAMES.MOVE, function () {\n        return new gbs.node.MoveClaw(g.token, parameterListCall(g));\n    });\n\n    define.stmt(TOKEN_NAMES.MOVE_TO_EDGE, function () {\n        return new gbs.node.MoveToEdge(g.token, parameterListCall(g));\n    });\n\n    define.stmt(TOKEN_NAMES.CLEAN_BOARD, function () {\n        return new gbs.node.CleanBoard(g.token, parameterListCall(g));\n    });\n\n    define.stmt(TOKEN_NAMES.BOOM, function () {\n        var token = g.token;\n        if (parenthesisExpression(g)) {\n            gbs.errors.throwParserError(token, 'BOOM no lleva parámetros');\n        }\n        return new gbs.node.Boom(token);\n    });\n\n    define.prefix(TOKEN_NAMES.HAS_STONES, function () {\n        return new gbs.node.HasStones(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.NUM_STONES, function () {\n        return new gbs.node.NumStones(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.MAX_COLOR, function () {\n        return new gbs.node.MaxColor(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.MIN_COLOR, function () {\n        return new gbs.node.MinColor(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.MAX_DIR, function () {\n        return new gbs.node.MaxDir(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.MIN_DIR, function () {\n        return new gbs.node.MinDir(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.MAX_BOOL, function () {\n        return new gbs.node.MaxBool(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.MIN_BOOL, function () {\n        return new gbs.node.MinBool(g.token, parameterListCall(g));\n    });\n\n    define.prefix(TOKEN_NAMES.CAN_MOVE, function () {\n        var id = g.token;\n        var parameters = parameterListCall(g);\n        return new gbs.node.CanMove(id, parameters);\n    });\n\n    define.stmt(TOKEN_NAMES.IF, function () {\n        var token = g.token;\n        g.advance('(');\n        var condition = g.expression(0);\n        g.advance(')');\n        var trueBranch = bodyStatement(g);\n        var falseBranch = null;\n        if (g.token.id === TOKEN_NAMES.ELSE) {\n            g.scope.reserve(g.token);\n            g.advance(TOKEN_NAMES.ELSE);\n            falseBranch = bodyStatement(g);\n        }\n        return new gbs.node.If(token, condition, trueBranch, falseBranch);\n    });\n\n    define.stmt(TOKEN_NAMES.SWITCH, function () {\n        var token = g.token;\n        var condition = parenthesisExpression(g);\n        if (g.token.id === TOKEN_NAMES.TO) {\n            g.advance(TOKEN_NAMES.TO);\n        }\n        g.advance('{');\n        var cases = [];\n        for (; ;) {\n            var exp = g.expression(0);\n            g.advance('->');\n            var body = bodyStatementWithOptionalMultiline(g);\n            cases.push({\n                case: exp,\n                body: body\n            });\n            if (g.token.id === '}' || !g.tokens.hasNext()) {\n                break;\n            }\n        }\n        g.advance('}');\n        return new gbs.node.Switch(token, condition, cases);\n    });\n\n    define.stmt(TOKEN_NAMES.WHILE, function () {\n        return new gbs.node.While(g.token, parenthesisExpression(g), bodyStatement(g));\n    });\n\n    define.stmt(TOKEN_NAMES.REPEAT, function () {\n        return new gbs.node.Repeat(g.token, parenthesisExpression(g), bodyStatement(g));\n    });\n\n    define.stmt(TOKEN_NAMES.FOR_EACH, function () {\n        // foreach dir in [minDir() .. maxDir()]\n        var iterator = g.expression();\n        if (iterator.token.arity !== 'name') {\n            g.error(iterator.token, 'El foreach espera un identificador sobre el cual iterar');\n        }\n        g.advance(TOKEN_NAMES.IN);\n        g.advance('[');\n        var rangeLeft = g.expression();\n        g.advance('..');\n        var rangeRight = g.expression();\n        g.advance(']');\n        return new gbs.node.ForEach(g.token, iterator, rangeLeft, rangeRight, g.block());\n    });\n\n    define.stmt('{', function () {\n        var a = g.statements();\n        g.advance('}');\n        return a;\n    });\n\n    define.stmt('(', function () {\n        var a = g.statements();\n        g.advance(')');\n        return a;\n    });\n\n    define.prefix('(', function () {\n        var expression = g.expression(0);\n        g.advance(')');\n        return expression;\n    });\n\n    define.root(TOKEN_NAMES.PROGRAM, function () {\n        return new gbs.node.Program(g.token, g.block());\n    });\n\n    define.root(TOKEN_NAMES.FUNCTION, function () {\n        g.newScope();\n        var token = g.token;\n        if (g.token.arity === 'name') {\n            if (g.token.value[0] !== g.token.value[0].toLowerCase()) {\n                g.error(token, 'El nombre de la función ' + token.value + ' debe emepzar con minúscula');\n            }\n            g.scope.define(token);\n            g.advance();\n        } else {\n            g.error(token, 'Se esperaba un nombre de función');\n        }\n        var parameters = parameterDeclarationList(g);\n        var body = bodyStatement(g);\n\n        var ret = body.pop();\n        if (!ret || ret.alias !== 'return' || !ret.expression) {\n            g.error(token, 'La función ' + token.value + ' debe terminar con un ' + TOKEN_NAMES.RETURN);\n        }\n        g.scope.pop();\n        var declaration = new gbs.node.FunctionDeclaration(token, parameters, body, ret);\n        token.declaration = declaration;\n        return declaration;\n    });\n\n    define.stmt(TOKEN_NAMES.RETURN, function () {\n        return new gbs.node.ReturnStatement(g.token, parenthesisExpression(g));\n    });\n\n    define.root(TOKEN_NAMES.PROCEDURE, function () {\n        g.newScope();\n        var token = g.token;\n        if (g.token.arity === 'name') {\n            if (g.token.value[0] !== g.token.value[0].toUpperCase()) {\n                g.error(token, 'El nombre del procedimiento ' + token.value + ' debe emepzar con mayúscula');\n            }\n            g.scope.define(token);\n            g.advance();\n        } else {\n            g.error(token, 'Se esperaba un nombre de procedimiento');\n        }\n        var parameters = parameterDeclarationList(g);\n        var body = bodyStatement();\n        g.scope.pop();\n        var declaration = new gbs.node.ProcedureDeclaration(token, parameters, body);\n        token.declaration = declaration;\n        return declaration;\n    });\n\n    define.parse = function (input) {\n        var main;\n        var declarations = [];\n        var roots = g.parseProgram(input);\n        for (var i = 0; i < roots.length; i++) {\n            if (roots[i].alias === 'program') {\n                main = roots[i];\n            } else {\n                declarations.push(roots[i]);\n            }\n        }\n        return new gbs.node.Root(main, declarations);\n    };\n\n    return g;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/grammar/grammar.js\n// module id = 2\n// module chunks = 0","var errors = require('../utils/errors');\nvar Scope = require('./scope');\n\nfunction throwUndefinedSymbolError() {\n    errors.throwParserError(this, 'No definido');\n}\n\nfunction throwMissingOperatorError() {\n    errors.throwParserError(this, 'No se encontró el operador');\n}\n\nvar OriginalSymbol = function () {\n    this.nud = throwUndefinedSymbolError;\n    this.led = throwMissingOperatorError;\n};\n\nvar Parser = function (lexer) {\n    this.scope = null;\n    this.token = null;\n    this.tokens = lexer;\n    this.symbolTable = {};\n};\n\nParser.prototype.symbol = function (id, bindingPower) {\n    var s = this.symbolTable[id];\n    bindingPower = bindingPower || 0;\n    if (s) {\n        if (bindingPower > s.lbp) {\n            s.lbp = bindingPower;\n        }\n    } else {\n        s = new OriginalSymbol();\n        s.id = s.value = id;\n        s.lbp = bindingPower;\n        this.symbolTable[id] = s;\n    }\n    return s;\n};\n\nParser.prototype.expression = function (rightBindingPower) {\n    rightBindingPower = rightBindingPower || 0;\n    var left;\n    var t = this.token;\n    this.advance();\n    left = t.nud();\n    while (rightBindingPower < this.token.lbp) {\n        t = this.token;\n        this.advance();\n        left = t.led(left);\n    }\n    return left;\n};\n\nParser.prototype.error = function (token, message) {\n    errors.throwParserError(token, message);\n};\n\nParser.prototype.newScope = function () {\n    var s = this.scope;\n    this.scope = new Scope(this);\n    this.scope.parent = s;\n    return this.scope;\n};\n\nParser.prototype.advance = function (id) {\n    var a;\n    var o;\n    var t;\n    var v;\n    var tokens = this.tokens;\n    if (id && this.token.id !== id) {\n        if (this.lastToken && this.lastToken.range && this.token.range) {\n            this.token.range.start = this.lastToken.range.start;\n        }\n        errors.throwParserError(this.token, 'Se esperaba \"' + id + '\" pero se encontró \"' + this.token.value + '\"');\n    }\n    if (!tokens.hasNext()) {\n        var lastRange = this.token.range;\n        this.token = this.symbolTable['(end)'];\n        this.token.range = lastRange;\n        return this.token;\n    }\n    t = tokens.next();\n    v = t.value;\n    a = t.type;\n    if (a === 'name') {\n        o = this.scope.find(v);\n        if (o.arity === 'routine') {\n            // force late binding\n            o = this.symbolTable['(name)'];\n        }\n    } else if (a === 'operator') {\n        o = this.symbolTable[v];\n        if (!o) {\n            errors.throwParserError(t, 'Unknown operator.');\n        }\n    } else if (a === 'number') {\n        o = this.symbolTable['(literal)'];\n        a = 'literal';\n        v = parseInt(v, 10);\n    } else {\n        errors.throwParserError(t, 'Unexpected token.');\n    }\n\n    var token = Object.create(o);\n    token.range = t.range;\n    token.value = v;\n    token.arity = a;\n    this.lastToken = this.token;\n    this.token = token;\n    return token;\n};\n\nParser.prototype.op = function (id, bp, OpDefinition) {\n    var parser = this;\n    var s = this.symbol(id, bp);\n    s.led = function (left) {\n        return new OpDefinition(this, left, parser.expression(bp));\n    };\n    return s;\n};\n\nParser.prototype.statement = function () {\n    var n = this.token;\n    var v;\n    if (n.std) {\n        this.advance();\n        this.scope.reserve(n);\n        return n.std();\n    }\n    v = this.expression(0);\n    if (v.alias !== ':=' && v.id !== '(' && v.arity !== 'routine') {\n        errors.throwParserError(v, 'Bad expression statement.');\n    }\n    return v;\n};\n\nParser.prototype.statements = function () {\n    var statementsList = [];\n    var symbol;\n    for (; ;) {\n        if (this.token.id === '}' || this.token.id === '(end)') {\n            break;\n        }\n        var range = this._currentRange();\n        symbol = this.statement();\n        if (symbol && !symbol.separator) {\n            this._applyRangeToSymbol(range, symbol);\n            statementsList.push(symbol);\n        }\n    }\n    if (statementsList.length === 0) {\n        return null;\n    }\n    return statementsList;\n};\n\nParser.prototype._applyRangeToSymbol = function (range, symbol) {\n    symbol.range = range;\n    if (this.token.range && this.token.range.end) {\n        range.end = this.token.range.end;\n    }\n};\n\nParser.prototype.rootDeclaration = function () {\n    var n = this.token;\n    if (!n.root) {\n        errors.throwParserError(n, 'Se esperaba una definición de programa, función o procedimiento.');\n    }\n    this.advance();\n    this.scope.reserve(n);\n    return n.root();\n};\n\nParser.prototype.stmt = function (symbol, f) {\n    var x = this.symbol(symbol);\n    x.std = f;\n    return x;\n};\n\nParser.prototype.infix = function (id, bp, led) {\n    var s = this.symbol(id, bp);\n    var self = this;\n    s.led = led || function (left) {\n        this.left = left;\n        this.right = self.expression(bp);\n        this.arity = 'binary';\n        return this;\n    };\n    return s;\n};\n\nParser.prototype.infixr = function (id, bp, led) {\n    var s = this.symbol(id, bp);\n    var self = this;\n    s.led = led || function (left) {\n        this.left = left;\n        this.right = self.expression(bp - 1);\n        this.arity = 'binary';\n        return this;\n    };\n    return s;\n};\n\nParser.prototype.prefix = function (id, nud) {\n    var s = this.symbol(id);\n    var self = this;\n    s.nud = nud || function () {\n        self.scope.reserve(this);\n        this.left = self.expression(70);\n        this.arity = 'unary';\n        return this;\n    };\n    return s;\n};\n\nParser.prototype.root = function (symbol, f) {\n    var x = this.symbol(symbol);\n    x.root = f;\n    return x;\n};\n\nParser.prototype.block = function () {\n    var t = this.token;\n    this.advance('{');\n    return t.std();\n};\n\nParser.prototype._currentRange = function () {\n    return {start: this.token.range.start, end: this.token.range.end};\n};\n\nParser.prototype.roots = function () {\n    var roots = [];\n    var symbol;\n    for (; ;) {\n        if (this.token.id === '(end)') {\n            break;\n        }\n        var range = this._currentRange();\n        symbol = this.rootDeclaration();\n        if (symbol) {\n            this._applyRangeToSymbol(range, symbol);\n            roots.push(symbol);\n        }\n    }\n    if (roots.length === 0) {\n        return null;\n    }\n    return roots;\n};\n\nParser.prototype._parseContextAwareNode = function (input, nodeParser) {\n    this.tokens.input(input);\n    this.newScope();\n    this.advance();\n    var s = nodeParser();\n    this.advance('(end)');\n    this.scope.pop();\n    return s;\n};\n\nParser.prototype.parseExpression = function (input) {\n    var self = this;\n    return this._parseContextAwareNode(input, function () {\n        return self.expression(0);\n    });\n};\n\nParser.prototype.parseProgram = function (input) {\n    var self = this;\n    return this._parseContextAwareNode(input, function () {\n        return self.roots();\n    });\n};\n\nParser.prototype.parseStatements = function (input) {\n    var self = this;\n    return this._parseContextAwareNode(input, function () {\n        return self.statements();\n    });\n};\n\nmodule.exports = Parser;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/grammar/parser.js\n// module id = 3\n// module chunks = 0","var TOKEN_NAMES = {\n    PROGRAM: 'program',\n    PROCEDURE: 'procedure',\n    FUNCTION: 'function',\n    RETURN: 'return',\n    DROP: 'Poner',\n    MOVE: 'Mover',\n    GRAB: 'Sacar',\n    BOOM: 'BOOM',\n    MOVE_TO_EDGE: 'IrAlBorde',\n    CLEAN_BOARD: 'VaciarTablero',\n    REPEAT: 'repeat',\n    WHILE: 'while',\n    FOR_EACH: 'foreach',\n    IN: 'in',\n    IF: 'if',\n    THEN: 'then',\n    ELSE: 'else',\n    SWITCH: 'switch',\n    TO: 'to',\n    OPPOSITE: 'opuesto',\n    NEXT: 'siguiente',\n    PREVIOUS: 'previo',\n    DIV: 'div',\n    MOD: 'mod',\n    NOT: 'not',\n    HAS_STONES: 'hayBolitas',\n    CAN_MOVE: 'puedeMover',\n    NUM_STONES: 'nroBolitas',\n    MIN_DIR: 'minDir',\n    MAX_DIR: 'maxDir',\n    MIN_COLOR: 'minColor',\n    MAX_COLOR: 'maxColor',\n    MIN_BOOL: 'minBool',\n    MAX_BOOL: 'maxBool',\n    RED: 'Rojo',\n    BLUE: 'Azul',\n    BLACK: 'Negro',\n    GREEN: 'Verde',\n    TRUE: 'True',\n    FALSE: 'False',\n    NORTH: 'Norte',\n    SOUTH: 'Sur',\n    EAST: 'Este',\n    WEST: 'Oeste',\n    BOOLEAN: 'Booleano',\n    COLOR: 'Color',\n    DIRECTION: 'Dirección',\n    NUMBER: 'Número'\n};\n\nmodule.exports = TOKEN_NAMES;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/grammar/reserved-words.js\n// module id = 4\n// module chunks = 0","var errors = require('../utils/errors');\n\nfunction itself() {\n    return this;\n}\n\nvar Scope = function (parser) {\n    this.parser = parser;\n    this.def = {};\n};\n\nScope.prototype.define = function (identifier) {\n    var t = this.def[identifier.value];\n    if (typeof t === 'object') {\n        errors.throwParserError(identifier, t.reserved ? 'Already reserved.' : 'Already defined.');\n    }\n    this.def[identifier.value] = identifier;\n    identifier.reserved = false;\n    identifier.nud = itself;\n    identifier.led = null;\n    identifier.std = null;\n    identifier.lbp = 0;\n    identifier.scope = this.parser.scope;\n    return identifier;\n};\n\nScope.prototype.find = function (name) {\n    var e = this;\n    var targetToken;\n    for (; ;) {\n        targetToken = e.def[name];\n        if (targetToken && typeof targetToken !== 'function') {\n            return e.def[name];\n        }\n        e = e.parent;\n        if (!e) {\n            targetToken = this.parser.symbolTable[name];\n            return targetToken && typeof targetToken !== 'function' ? targetToken : this.parser.symbolTable['(name)'];\n        }\n    }\n};\n\nScope.prototype.pop = function () {\n    this.scope = this.parent;\n};\n\nScope.prototype.reserve = function (name) {\n    if (name.arity !== 'name' || name.reserved) {\n        return;\n    }\n    var t = this.def[name.value];\n    if (t) {\n        if (t.reserved) {\n            return;\n        }\n        if (t.arity === 'name') {\n            name.error('Already defined.');\n        }\n    }\n    this.def[name.value] = name;\n    name.reserved = true;\n};\n\nmodule.exports = Scope;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/grammar/scope.js\n// module id = 5\n// module chunks = 0","function Lexer(prefix, suffix) {\n    // Current reading position\n    this.from = 0;\n    this.startColumn = 0;\n    this.endColumn = 0;\n    this.row = 0;\n    this.prefix = prefix || '/=-<>:|&.';\n    this.suffix = suffix || '=|&>.';\n\n    this.punctuators = '/+-*^.:|&;,()<>{}[]=';\n\n    // Look ahead position\n    this.i = 0;\n\n    this.buf = null;\n    this.buflen = 0;\n}\n\nLexer.prototype.hasNext = function () {\n    this._skipNonTokens();\n    return this.from < this.buflen;\n};\n\nLexer.prototype.input = function (buf) {\n    this.from = 0;\n    this.i = 0;\n    this.startColumn = 0;\n    this.endColumn = 0;\n    this.row = 0;\n    this.buf = buf;\n    this.buflen = buf.length;\n    this.current = null;\n    this.nextChar = null;\n};\n\nvar TokenTypes = {\n    IDENTIFIER: 'name',\n    OPERATOR: 'operator',\n    EOF: 'eof',\n    COMMENT: 'comment',\n    NUMBER: 'number',\n    NEWLINE: 'newline'\n};\n\n/**\n * This method is highly procedural for performance reasons.\n * There is no need for the lexer to be too flexible, since the\n * semantics will be associated to identifiers on the parser.\n *\n * @returns Token. The next token on the buffer, or null if the buffer is empty.\n */\nLexer.prototype.next = function () {\n    do {\n        this._skipNonTokens();\n        this._refreshCurrentAndNextChars();\n\n        if (this.from >= this.buflen) {\n            return null;\n        }\n    } while (this._processComment());\n\n    // Always add cases in descending order of occurrence probability\n    if (this._processIdentifier()) {\n        return this._consume(TokenTypes.IDENTIFIER);\n    } else if (this._processOperator()) {\n        return this._consume(TokenTypes.OPERATOR);\n    } else if (this._processNumber()) {\n        return this._consume(TokenTypes.NUMBER);\n    }\n    return this._processError();\n};\n\n// PRIVATE\n\nfunction error(token, description) {\n    return {error: description, on: token};\n}\n\nLexer.prototype._make = function (type, value) {\n    return {\n        type: type,\n        value: value,\n        range: {\n            start: {row: this.row, column: this.startColumn},\n            end: {row: this.row, column: this.endColumn}\n        }\n    };\n};\n\nLexer.prototype._consume = function (type) {\n    var text = this.buf.substring(this.from, this.i);\n    var newToken = this._make(type, text);\n    this.from = this.i;\n    this.startColumn = this.endColumn;\n    return newToken;\n};\n\nLexer.prototype._refreshCurrentAndNextChars = function () {\n    this.current = this.buf.charAt(this.from);\n    this.nextChar = this.buf.charAt(this.from + 1);\n};\n\nLexer.prototype._processOperator = function () {\n    if (this.punctuators.indexOf(this.current) >= 0) {\n        this._increaseFrom();\n        this._processMultiCharOperator();\n        return true;\n    }\n    return false;\n};\n\nLexer.prototype._processMultiCharOperator = function () {\n    if (this.prefix.indexOf(this.current) >= 0 && this.suffix.indexOf(this.nextChar) >= 0) {\n        this._incrementStep();\n    }\n};\n\nLexer.prototype._processNumber = function () {\n    if (_isDigit(this.current)) {\n        this._increaseFrom();\n        while (this.i < this.buflen && _isDigit(this.buf.charAt(this.i))) {\n            this._incrementStep();\n        }\n        return true;\n    }\n    return false;\n};\n\nLexer.prototype._processError = function () {\n    this._increaseFrom();\n    return error('Unmatched token', this._consume('UNMATCHED'));\n};\n\nLexer.prototype._resetColumnCount = function () {\n    this.startColumn = this.endColumn;\n};\n\nLexer.prototype._increaseFrom = function () {\n    this.i = this.from + 1;\n    this.startColumn = this.startColumn + 1;\n    this.endColumn = this.startColumn;\n};\n\nLexer.prototype._incrementStep = function () {\n    this.i++;\n    this.endColumn++;\n};\n\nLexer.prototype._processIdentifier = function () {\n    if (_isAlpha(this.current)) {\n        this._increaseFrom();\n        while (this.i < this.buflen && _isAlphanum(this.buf.charAt(this.i))) {\n            this._incrementStep();\n        }\n        return true;\n    }\n    return false;\n};\n\nLexer.prototype._skipNonTokens = function () {\n    while (this.from < this.buflen) {\n        var c = this.buf.charAt(this.from);\n        if (c === ' ' || c === '\\t' || c === '\\r' || c === '\\n') {\n            if (_isNewline(c)) {\n                this.row += 1;\n                this.endColumn = 0;\n                this.startColumn = 0;\n            } else {\n                this.startColumn++;\n                this.endColumn = this.startColumn;\n            }\n            this.from++;\n            this.i = this.from;\n        } else {\n            break;\n        }\n    }\n};\n\nLexer.prototype._processComment = function () {\n    var chars = this.current + this.nextChar;\n    return this._processSingleLineComment(chars) || this._processMultiLineComment(chars);\n};\n\nLexer.prototype._processSingleLineComment = function (chars) {\n    if (chars === '//') {\n        while (this.i < this.buflen && !_isNewline(this.buf.charAt(this.i))) {\n            this._incrementStep();\n        }\n        this.from = this.i;\n        this.row++;\n        this.startColumn = 0;\n        this.endColumn = 0;\n        return true;\n    }\n};\n\nLexer.prototype._processMultiLineComment = function (chars) {\n    if (chars === '/*') {\n        this._incrementStep();\n        this._incrementStep();\n        while (this.i < this.buflen && this.buf.charAt(this.i) !== '*' && this.buf.charAt(this.i + 1) !== '/') {\n            this._incrementStep();\n            if (_isNewline(this.buf.charAt(this.i))) {\n                this.endColumn = 0;\n            }\n        }\n        this._incrementStep();\n        this._incrementStep();\n        this.from = this.i;\n        this.endColumn = this.startColumn;\n        return true;\n    }\n    return false;\n};\n\nfunction _isNewline(c) {\n    return c === '\\r' || c === '\\n';\n}\n\nfunction _isDigit(c) {\n    return c >= '0' && c <= '9';\n}\n\nfunction _isAlpha(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '_' || c === '\\'';\n}\n\nfunction _isAlphanum(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c === '_' || c === '$';\n}\n\nmodule.exports = Lexer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/lexer/lexer.js\n// module id = 6\n// module chunks = 0","var Board = require('./model');\n\nvar Context = function () {\n    var variablesStack = [];\n    var boardsStack = [];\n    var currentBoard = new Board(9, 9);\n    var currentVariables = {};\n\n    this.init = function () {\n        currentBoard.init();\n    };\n\n    this.nativeRepresentations = function () {\n        return Board;\n    };\n\n    this.board = function () {\n        return currentBoard;\n    };\n\n    this.put = function (key, value) {\n        currentVariables[key] = value;\n    };\n\n    this.get = function (id) {\n        return currentVariables[id];\n    };\n\n    this.all = function () {\n        return currentVariables;\n    };\n\n    this.startContext = function () {\n        variablesStack.push(currentVariables);\n        currentVariables = {};\n    };\n\n    this.stopContext = function () {\n        currentVariables = variablesStack.pop();\n    };\n\n    this.pushBoard = function () {\n        boardsStack.push(currentBoard);\n        currentBoard = currentBoard.clone();\n    };\n\n    this.popBoard = function () {\n        currentBoard = boardsStack.pop();\n    };\n\n    this.init();\n};\n\nmodule.exports = Context;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/execution-context.js\n// module id = 7\n// module chunks = 0","var GobstonesError = function (message) {\n    this.message = message;\n};\nGobstonesError.prototype = new Error('BOOM');\n\nfunction Board(sizeX, sizeY) {\n    this.x = 0;\n    this.y = 0;\n\n    this.sizeX = sizeX;\n    this.sizeY = sizeY;\n}\n\nBoard.blue = 0;\nBoard.red = 1;\nBoard.black = 2;\nBoard.green = 3;\n\nBoard.north = [0, 1];\nBoard.east = [1, 0];\nBoard.south = [0, -1];\nBoard.west = [-1, 0];\n\nBoard.minDir = Board.north;\nBoard.maxDir = Board.west;\nBoard.minColor = Board.blue;\nBoard.maxColor = Board.green;\n\nBoard.prototype.init = function () {\n    this.table = [[], [], [], []];\n    for (var i = 0; i < this.sizeX; i++) {\n        this.table[0][i] = [];\n        this.table[1][i] = [];\n        this.table[2][i] = [];\n        this.table[3][i] = [];\n        for (var j = 0; j < this.sizeY; j++) {\n            this.table[0][i][j] = 0;\n            this.table[1][i][j] = 0;\n            this.table[2][i][j] = 0;\n            this.table[3][i][j] = 0;\n        }\n    }\n};\n\nBoard.prototype.clone = function () {\n    var c = new Board(this.sizeX, this.sizeY);\n    c.init();\n    for (var i = 0; i < this.sizeX; i++) {\n        c.table[0][i] = [];\n        c.table[1][i] = [];\n        c.table[2][i] = [];\n        c.table[3][i] = [];\n        for (var j = 0; j < this.sizeY; j++) {\n            c.table[0][i][j] = this.table[0][i][j];\n            c.table[1][i][j] = this.table[1][i][j];\n            c.table[2][i][j] = this.table[2][i][j];\n            c.table[3][i][j] = this.table[3][i][j];\n        }\n    }\n    c.x = this.x;\n    c.y = this.y;\n    return c;\n};\n\nBoard.prototype.putStone = function (color) {\n    this.dropStones(color, 1);\n};\n\nBoard.prototype.dropStones = function (color, amount) {\n    this.table[color][this.x][this.y] += amount;\n};\n\nBoard.prototype.removeStone = function (color) {\n    if (this.table[color][this.x][this.y] <= 0) {\n        throw new GobstonesError('Se intentó sacar una bolita pero ya no quedaban bolitas para sacar');\n    }\n    this.table[color][this.x][this.y] -= 1;\n};\n\nBoard.prototype.boom = function () {\n    throw new GobstonesError('BOOM!');\n};\n\nBoard.prototype.clear = function () {\n    this.init();\n};\n\nBoard.prototype.amountStones = function (color) {\n    return this.table[color][this.x][this.y];\n};\n\nBoard.prototype.canMove = function (vec) {\n    var nextX = this.x + vec[0];\n    var nextY = this.y + vec[1];\n    return nextX < this.sizeX && nextX >= 0 && nextY < this.sizeY && nextY >= 0;\n};\n\nBoard.prototype.move = function (vec) {\n    if (!this.canMove(vec)) {\n        throw new GobstonesError('Te caiste del tablero por: x=' + this.x + ' y=' + this.y);\n    }\n    this.x += vec[0];\n    this.y += vec[1];\n};\n\nBoard.prototype.moveToEdge = function (vec) {\n    if (vec[0] === 1) {\n        this.x = this.sizeX - 1;\n    } else if (vec[0] === -1) {\n        this.x = 0;\n    } else if (vec[1] === 1) {\n        this.y = this.sizeY - 1;\n    } else if (vec[1] === -1) {\n        this.y = 0;\n    }\n};\n\nBoard.prototype.printAscii = function () {\n    var out = this.sizeX + 'x' + this.sizeY + '\\n';\n    var az = this.table[0];\n    var ro = this.table[1];\n    var ne = this.table[2];\n    var ve = this.table[3];\n    for (var j = this.sizeY - 1; j >= 0; j--) {\n        for (var i = 0; i < this.sizeX; i++) {\n            out += (az[i][j] || ro[i][j] || ne[i][j] || ve[i][j]) ? '#' : '.';\n        }\n        out += '\\n';\n    }\n    return out;\n};\n\nmodule.exports = Board;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/model.js\n// module id = 8\n// module chunks = 0","module.exports = function (node, constants) {\n    node.Assignment = function (token, left, right) {\n        this.token = token;\n        this.arity = constants.STM;\n        this.alias = ':=';\n        this.left = left;\n        this.right = right;\n    };\n\n    node.Assignment.prototype.interpret = function (context) {\n        context.put(this.left.token.value, this.right.eval(context));\n    };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/assignment.js\n// module id = 9\n// module chunks = 0","module.exports = function (node, constants) {\n    var BinaryOperation = function (token, left, right) {\n        this.token = token;\n        this.left = left;\n        this.right = right;\n        this.arity = constants.BINARY;\n    };\n\n    function defineBinaryOperation(className) {\n        node[className] = function (token, left, right) {\n            BinaryOperation.call(this, token, left, right);\n        };\n        node[className].prototype = new BinaryOperation();\n    }\n\n    defineBinaryOperation('SumOperation');\n    node.SumOperation.prototype.eval = function (context) {\n        return this.left.eval(context) + this.right.eval(context);\n    };\n\n    defineBinaryOperation('DiffOperation');\n    node.DiffOperation.prototype.eval = function (context) {\n        return this.left.eval(context) - this.right.eval(context);\n    };\n\n    defineBinaryOperation('MulOperation');\n    node.MulOperation.prototype.eval = function (context) {\n        return this.left.eval(context) * this.right.eval(context);\n    };\n\n    defineBinaryOperation('DivOperation');\n    node.DivOperation.prototype.eval = function (context) {\n        return Math.floor(this.left.eval(context) / this.right.eval(context));\n    };\n\n    defineBinaryOperation('ModOperation');\n    node.ModOperation.prototype.eval = function (context) {\n        return this.left.eval(context) % this.right.eval(context);\n    };\n\n    defineBinaryOperation('ExpOperation');\n    node.ExpOperation.prototype.eval = function (context) {\n        return Math.pow(this.left.eval(context), this.right.eval(context));\n    };\n\n    defineBinaryOperation('AndOperation');\n    node.AndOperation.prototype.eval = function (context) {\n        return this.left.eval(context) && this.right.eval(context);\n    };\n\n    defineBinaryOperation('OrOperation');\n    node.OrOperation.prototype.eval = function (context) {\n        return this.left.eval(context) || this.right.eval(context);\n    };\n\n    defineBinaryOperation('NotEqualOperation');\n    node.NotEqualOperation.prototype.eval = function (context) {\n        return this.left.eval(context) !== this.right.eval(context);\n    };\n\n    defineBinaryOperation('EqOperation');\n    node.EqOperation.prototype.eval = function (context) {\n        return this.left.eval(context) === this.right.eval(context);\n    };\n\n    defineBinaryOperation('LessOperation');\n    node.LessOperation.prototype.eval = function (context) {\n        return this.left.eval(context) < this.right.eval(context);\n    };\n\n    defineBinaryOperation('GraterOperation');\n    node.GraterOperation.prototype.eval = function (context) {\n        return this.left.eval(context) > this.right.eval(context);\n    };\n\n    defineBinaryOperation('LessEqualOperation');\n    node.LessEqualOperation.prototype.eval = function (context) {\n        return this.left.eval(context) <= this.right.eval(context);\n    };\n\n    defineBinaryOperation('GreaterEqualOperation');\n    node.GreaterEqualOperation.prototype.eval = function (context) {\n        return this.left.eval(context) >= this.right.eval(context);\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/binary-operations.js\n// module id = 10\n// module chunks = 0","module.exports = function (node) {\n    node.If = function (token, condition, trueBranch, falseBranch) {\n        this.token = token;\n        this.condition = condition;\n        this.trueBranch = trueBranch;\n        this.falseBranch = falseBranch;\n    };\n\n    node.If.prototype.interpret = function (context) {\n        return node.interpretBlock(this.condition.eval(context) ? this.trueBranch : this.falseBranch, context);\n    };\n\n    node.Switch = function (token, expression, cases) {\n        this.token = token;\n        this.expression = expression;\n        this.cases = cases;\n    };\n\n    node.Switch.prototype.interpret = function (context) {\n        var value = this.expression.eval(context);\n        for (var i = 0; i < this.cases.length; i++) {\n            if (this.cases[i].case.eval(context) === value) {\n                node.interpretBlock(this.cases[i].body, context);\n                break;\n            }\n        }\n        return context;\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/conditional-statements.js\n// module id = 11\n// module chunks = 0","module.exports = function (node) {\n    node.Constant = function (token, alias, value, type) {\n        this.token = token;\n        this.value = value;\n        this.alias = alias;\n        this.type = type;\n    };\n\n    node.Constant.prototype.eval = function () {\n        return this.value;\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/constant.js\n// module id = 12\n// module chunks = 0","module.exports = function (node) {\n    node.NumericLiteral = function (token, value) {\n        this.token = token;\n        this.value = value;\n    };\n    node.NumericLiteral.prototype.type = 'number';\n\n    node.NumericLiteral.prototype.eval = function () {\n        return this.value;\n    };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/literals.js\n// module id = 13\n// module chunks = 0","var node = {};\nnode.errors = require('../utils/errors');\n\nvar constants = {\n    STM: 'statement',\n    BINARY: 'binary',\n    EXPRESSION: 'binary'\n};\n\nnode.interpretBlock = function (block, context) {\n    block = block || [];\n    for (var i = 0; i < block.length; i++) {\n        block[i].interpret(context);\n    }\n    return context;\n};\n\nrequire('./literals')(node, constants);\nrequire('./constant')(node, constants);\nrequire('./variable')(node, constants);\nrequire('./assignment')(node, constants);\nrequire('./conditional-statements')(node, constants);\nrequire('./binary-operations')(node, constants);\nrequire('./unary-operations')(node, constants);\nrequire('./primitive-functions')(node, constants);\nrequire('./primitive-procedures')(node, constants);\nrequire('./routine-calls')(node, constants);\nrequire('./routine-declarations')(node, constants);\nrequire('./repetition-statements')(node, constants);\nrequire('./program-root')(node, constants);\n\nmodule.exports = node;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/nodes.js\n// module id = 14\n// module chunks = 0","module.exports = function (node, constants) {\n    node.HasStones = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'hasStones';\n        this.parameters = parameters;\n    };\n\n    node.HasStones.prototype.eval = function (context) {\n        return context.board().amountStones(this.parameters[0].eval(context)) > 0;\n    };\n\n    node.CanMove = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'canMove';\n        this.parameters = parameters;\n    };\n\n    node.CanMove.prototype.eval = function (context) {\n        return context.board().canMove(this.parameters[0].eval(context));\n    };\n\n    node.NumStones = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'numStones';\n        this.parameters = parameters;\n    };\n\n    node.NumStones.prototype.eval = function (context) {\n        return context.board().amountStones(this.parameters[0].eval(context));\n    };\n\n    node.MinDir = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'minDir';\n        this.parameters = parameters;\n    };\n\n    node.MinDir.prototype.eval = function (context) {\n        return context.nativeRepresentations().minDir;\n    };\n\n    node.MaxDir = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'maxDir';\n        this.parameters = parameters;\n    };\n\n    node.MaxDir.prototype.eval = function (context) {\n        return context.nativeRepresentations().maxDir;\n    };\n\n    node.MaxColor = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'maxColor';\n        this.parameters = parameters;\n    };\n\n    node.MaxColor.prototype.eval = function (context) {\n        return context.nativeRepresentations().maxColor;\n    };\n\n    node.MinColor = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'minColor';\n        this.parameters = parameters;\n    };\n\n    node.MinColor.prototype.eval = function (context) {\n        return context.nativeRepresentations().minColor;\n    };\n\n    node.MinBool = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'minBool';\n        this.parameters = parameters;\n    };\n\n    node.MinBool.prototype.eval = function () {\n        return false;\n    };\n\n    node.MaxBool = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.EXPRESSION;\n        this.name = 'maxBool';\n        this.parameters = parameters;\n    };\n\n    node.MaxBool.prototype.eval = function () {\n        return true;\n    };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/primitive-functions.js\n// module id = 15\n// module chunks = 0","module.exports = function (node, constants) {\n    node.MoveClaw = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.STM;\n        this.name = 'MoveClaw';\n        this.parameters = parameters;\n    };\n\n    node.MoveClaw.prototype.interpret = function (context) {\n        try {\n            context.board().move(this.parameters[0].eval(context));\n        } catch (err) {\n            err.on = this.token;\n            throw err;\n        }\n        return context;\n    };\n\n    node.RemoveStone = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.STM;\n        this.name = 'Grab';\n        this.parameters = parameters;\n    };\n\n    node.RemoveStone.prototype.interpret = function (context) {\n        try {\n            context.board().removeStone(this.parameters[0].eval(context));\n        } catch (err) {\n            err.on = this.token;\n            throw err;\n        }\n        return context;\n    };\n\n    node.PutStone = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.STM;\n        this.name = 'Drop';\n        this.parameters = parameters;\n    };\n\n    node.PutStone.prototype.interpret = function (context) {\n        context.board().putStone(this.parameters[0].eval(context));\n        return context;\n    };\n\n    node.MoveToEdge = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.STM;\n        this.name = 'MoveToEdge';\n        this.parameters = parameters;\n    };\n\n    node.MoveToEdge.prototype.interpret = function (context) {\n        context.board().moveToEdge(this.parameters[0].eval(context));\n        return context;\n    };\n\n    node.CleanBoard = function (token, parameters) {\n        this.token = token;\n        this.arity = constants.STM;\n        this.name = 'MoveToEdge';\n        this.parameters = parameters;\n    };\n\n    node.CleanBoard.prototype.interpret = function (context) {\n        context.board().clear();\n        return context;\n    };\n\n    node.Boom = function (token) {\n        this.token = token;\n        this.arity = constants.STM;\n        this.name = 'BOOM';\n    };\n\n    node.Boom.prototype.interpret = function (context) {\n        try {\n            context.board().boom();\n        } catch (err) {\n            err.on = node;\n            throw err;\n        }\n        return context;\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/primitive-procedures.js\n// module id = 16\n// module chunks = 0","module.exports = function (node) {\n    node.Program = function (token, body) {\n        this.token = token;\n        this.alias = 'program';\n        this.body = body || [];\n    };\n\n    node.Program.prototype.interpret = function (context) {\n        node.interpretBlock(this.body, context);\n        return context;\n    };\n\n    node.Root = function (program, declarations) {\n        this.alias = 'root';\n        this.program = program;\n        this.declarations = declarations;\n    };\n\n    node.Root.prototype.interpret = function (context) {\n        this.program.interpret(context);\n        return context;\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/program-root.js\n// module id = 17\n// module chunks = 0","module.exports = function (node) {\n    node.While = function (token, expression, body) {\n        this.alias = 'while';\n        this.token = token;\n        this.expression = expression;\n        this.body = body;\n    };\n\n    node.While.prototype.interpret = function (context) {\n        while (this.expression.eval(context)) {\n            node.interpretBlock(this.body, context);\n        }\n        return context;\n    };\n\n    node.Repeat = function (token, expression, body) {\n        this.alias = 'repeat';\n        this.token = token;\n        this.expression = expression;\n        this.body = body;\n    };\n\n    node.Repeat.prototype.interpret = function (context) {\n        var value = this.expression.eval(context);\n        for (var i = 0; i < value; i++) {\n            node.interpretBlock(this.body, context);\n        }\n        return context;\n    };\n\n    node.ForEach = function (token, iterator, rangeLeft, rangeRight, body) {\n        this.alias = 'foreach';\n        this.token = token;\n        this.iterator = iterator;\n        this.rangeLeft = rangeLeft;\n        this.rangeRight = rangeRight;\n        this.body = body;\n    };\n\n    node.ForEach.prototype.interpret = function (context) {\n        var rangeLeft = this.rangeLeft.eval(context);\n        var rangeRight = this.rangeRight.eval(context);\n\n        if (typeof rangeLeft !== typeof rangeRight) {\n            node.errors.throwInterpreterError(this.token, 'El rando del foreach debe ser mismos tipos de datos');\n        }\n\n        var values = context.nativeRepresentations();\n        var items = [];\n        if (typeof rangeLeft === 'object') {\n            if (rangeLeft[0] === values.minDir[0] && rangeLeft[1] === values.minDir[1]) {\n                items = [values.north, values.east, values.south, values.west];\n            } else {\n                items = [values.west, values.south, values.east, values.north];\n            }\n        } else if (typeof rangeLeft === 'boolean') {\n            if (rangeLeft) {\n                items = [true, false];\n            } else {\n                items = [false, true];\n            }\n        } else if (typeof rangeLeft === 'number' && rangeLeft >= values.minColor && rangeLeft <= values.maxColor) {\n            if (rangeLeft === values.minColor) {\n                items = [values.blue, values.red, values.black, values.green];\n            } else {\n                items = [values.green, values.black, values.red, values.blue];\n            }\n        }\n\n        for (var i = 0; i < items.length; i++) {\n            context.put(this.iterator.token.value, items[i]);\n            node.interpretBlock(this.body, context);\n        }\n\n        return context;\n    };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/repetition-statements.js\n// module id = 18\n// module chunks = 0","module.exports = function (node) {\n    function evalArguments(context, parameters) {\n        var results = [];\n        if (parameters) {\n            for (var i = 0; i < parameters.length; i++) {\n                results.push(parameters[i].eval(context));\n            }\n        }\n        return results;\n    }\n\n    function fillParameters(context, parameters, declaration) {\n        // TODO: no se pueden reasignar valores a los parámetros\n        if (declaration.parameters) {\n            for (var i = 0; i < declaration.parameters.length; i++) {\n                context.put(declaration.parameters[i].value, parameters[i]);\n            }\n        }\n    }\n\n    // TODO: el mundo de las variables, índices y parámetros debe ser disjunto por body!!\n\n    node.ProcedureCall = function (token, declarationProvider, parameters) {\n        this.token = token;\n        this.arity = 'routine';\n        this.alias = 'ProcedureCall';\n        this.name = token.value;\n        this.parameters = parameters;\n        this.declarationProvider = declarationProvider;\n    };\n\n    node.ProcedureCall.prototype.interpret = function (context) {\n        var target = this.declarationProvider();\n        if (!target.declaration) {\n            throw new node.errors.InterpreterException('El procedimiento ' + this.name + ' no se encuentra definido.', this.node);\n        }\n        var declaration = target.declaration;\n        var parameterValues = evalArguments(context, this.parameters);\n        context.startContext();\n        fillParameters(context, parameterValues, declaration);\n        node.interpretBlock(declaration.body, context);\n        context.stopContext();\n        return context;\n    };\n\n    node.FunctionCall = function (token, declarationProvider, parameters) {\n        this.token = token;\n        this.arity = 'routine';\n        this.alias = 'FunctionCall';\n        this.name = token.value;\n        this.parameters = parameters;\n        this.declarationProvider = declarationProvider;\n    };\n\n    node.FunctionCall.prototype.eval = function (context) {\n        var target = this.declarationProvider();\n        if (!target.declaration) {\n            throw new node.errors.InterpreterException('La función \"' + this.name + '\" no se encuentra definida.', this.node);\n        }\n        var declaration = target.declaration;\n        var parameterValues = evalArguments(context, this.parameters);\n        context.startContext();\n        context.pushBoard();\n        fillParameters(context, parameterValues, declaration);\n        node.interpretBlock(target.body, context);\n        var result = declaration.return.expression.eval(context);\n        context.popBoard();\n        context.stopContext();\n        return result;\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/routine-calls.js\n// module id = 19\n// module chunks = 0","module.exports = function (node) {\n    node.ProcedureDeclaration = function (token, parameters, body) {\n        this.token = token;\n        this.name = token.value;\n        this.arity = 'routine';\n        this.alias = 'procedureDeclaration';\n        this.parameters = parameters || [];\n        this.body = body || [];\n    };\n\n    node.FunctionDeclaration = function (token, parameters, body, returnExpression) {\n        this.token = token;\n        this.name = token.value;\n        this.arity = 'routine';\n        this.alias = 'functionDeclaration';\n        this.parameters = parameters || [];\n        this.body = body || [];\n        this.return = returnExpression;\n    };\n\n    node.ReturnStatement = function (token, expression) {\n        this.token = token;\n        this.alias = 'return';\n        this.expression = expression;\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/routine-declarations.js\n// module id = 20\n// module chunks = 0","module.exports = function (node) {\n    node.NotOperation = function (token, expression) {\n        this.token = token;\n        this.expression = expression;\n    };\n\n    node.NotOperation.prototype.eval = function (context) {\n        return !this.expression.eval(context);\n    };\n\n    node.SubstractionOperation = function (token, expression) {\n        this.token = token;\n        this.expression = expression;\n    };\n\n    node.SubstractionOperation.prototype.eval = function (context) {\n        return -this.expression.eval(context);\n    };\n}\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/unary-operations.js\n// module id = 21\n// module chunks = 0","module.exports = function (node) {\n    node.Variable = function (token, id) {\n        this.token = token;\n        this.id = id;\n    };\n\n    node.Variable.prototype.eval = function (context) {\n        return context.get(this.id);\n    };\n\n    return node;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/nodes/variable.js\n// module id = 22\n// module chunks = 0","var doNothing = function () {\n};\n\nmodule.exports = (console && console.log) ? console.log : doNothing;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/utils/logger.js\n// module id = 23\n// module chunks = 0"],"sourceRoot":""}