{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.umd.min.js","webpack:///webpack/bootstrap 88d6d51746274b29c8dc","webpack:///./lib/public.js","webpack:///./lib/execution-context.js","webpack:///./lib/gobstones-tokens-en.js","webpack:///./lib/grammar.js","webpack:///./lib/interpreter.js","webpack:///./lib/lexer.js","webpack:///./lib/model.js","webpack:///./lib/parser.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","grammar","parser","lexer","tokens","interpreter","context","Board","Context","variablesStack","boardsStack","currentBoard","currentVariables","init","board","put","key","value","console","log","get","all","startContext","push","stopContext","pop","pushBoard","clone","popBoard","TOKEN_NAMES","WHILE","IF","ELSE","SWITCH","REPEAT","FUNCTION","PROCEDURE","PROGRAM","PUT","REMOVE","HAS_STONES","CAN_MOVE","MOVE","RETURN","RED","BLUE","BLACK","GREEN","TRUE","NOT","TO","FALSE","NORTH","SOUTH","EAST","WEST","Grammar","Parser","names","behaviour","operator","op","bp","f","g","infix","left","self","right","expression","arity","eval","parameterListCall","parameters","token","advance","parameterDeclarationList","error","scope","parenthesisExpression","bodyStatement","block","statement","n","b","x","y","prefix","negation","symbol","constant","stmt","separator","node","toUpperCase","procedureCall","find","functionCall","infixr","assignment","putStone","removeStone","moveClaw","hasStone","canMove","nud","literal","variable","condition","trueBranch","falseBranch","reserve","conditional","cases","exp","body","case","hasNext","conditionalRepetition","numericExpression","numericRepetition","a","statements","programDeclaration","newScope","ret","alias","declaration","functionDeclaration","std","procedureDeclaration","rootProgram","interpretBlock","i","length","interpret","fillParameters","Statement","behaviours","Object","create","times","switch","name","declarationProvider","result","color","paramters","move","fun","returnExpression","main","declarations","Lexer","suffix","from","row","punctuators","buf","buflen","description","on","_isNewline","_isDigit","_isAlpha","_isAlphanum","prototype","_skipNonTokens","input","current","nextChar","TokenTypes","IDENTIFIER","OPERATOR","EOF","COMMENT","NUMBER","NEWLINE","next","_refreshCurrentAndNextChars","_processIdentifier","_consume","_processOperator","_processNumber","_processComment","_processError","_make","type","to","text","substring","newToken","charAt","indexOf","_processMultiCharOperator","chars","_processSingleLineComment","_processMultiLineComment","sizeX","sizeY","blue","red","black","green","table","j","slice","vec","nextX","nextY","printAscii","out","az","ro","ne","ve","symbolTable","someError","OriginalSymbol","led","itself","originalScope","t","def","reserved","lbp","targetToken","e","parent","s","bindingPower","rightBindingPower","o","v","parseInt","rootDeclaration","statementsList","roots","parseProgram","parse","parseExpression"],"mappings":"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","file":"index.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gsWeblangCore\"] = factory();\n\telse\n\t\troot[\"gsWeblangCore\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gsWeblangCore\"] = factory();\n\telse\n\t\troot[\"gsWeblangCore\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = {\n\t    grammar: __webpack_require__(3),\n\t    parser: __webpack_require__(7),\n\t    lexer: __webpack_require__(5),\n\t    tokens: __webpack_require__(2),\n\t    interpreter: __webpack_require__(4),\n\t    context: __webpack_require__(1)\n\t};\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Board = __webpack_require__(6);\n\t\n\tvar Context = function () {\n\t    var variablesStack = [];\n\t    var boardsStack = [];\n\t    var currentBoard = new Board(9, 9);\n\t    var currentVariables = {};\n\t\n\t    this.init = function () {\n\t        currentBoard.init();\n\t    };\n\t\n\t    this.board = function () {\n\t        return currentBoard;\n\t    };\n\t\n\t    this.put = function (key, value) {\n\t        console.log('VARIABLE SET: ', key, '   ', value);\n\t        currentVariables[key] = value;\n\t    };\n\t\n\t    this.get = function (id) {\n\t        return currentVariables[id];\n\t    };\n\t\n\t    this.all = function () {\n\t        return currentVariables;\n\t    };\n\t\n\t    this.startContext = function () {\n\t        variablesStack.push(currentVariables);\n\t        currentVariables = {};\n\t    };\n\t\n\t    this.stopContext = function () {\n\t        currentVariables = variablesStack.pop();\n\t    };\n\t\n\t    this.pushBoard = function () {\n\t        boardsStack.push(currentBoard);\n\t        currentBoard = currentBoard.clone();\n\t    };\n\t\n\t    this.popBoard = function () {\n\t        currentBoard = boardsStack.pop();\n\t    };\n\t\n\t    this.init();\n\t};\n\t\n\tmodule.exports = Context;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tvar TOKEN_NAMES = {\n\t    WHILE: 'while',\n\t    IF: 'if',\n\t    ELSE: 'else',\n\t    SWITCH: 'switch',\n\t    REPEAT: 'repeat',\n\t    FUNCTION: 'function',\n\t    PROCEDURE: 'procedure',\n\t    PROGRAM: 'program',\n\t    PUT: 'Poner',\n\t    REMOVE: 'Sacar',\n\t    HAS_STONES: 'hayBolitas',\n\t    CAN_MOVE: 'puedeMover',\n\t    MOVE: 'Mover',\n\t    RETURN: 'return',\n\t    RED: 'Rojo',\n\t    BLUE: 'Azul',\n\t    BLACK: 'Negro',\n\t    GREEN: 'Verde',\n\t    TRUE: 'True',\n\t    NOT: 'not',\n\t    TO: 'to',\n\t    FALSE: 'False',\n\t    NORTH: 'Norte',\n\t    SOUTH: 'Sur',\n\t    EAST: 'Este',\n\t    WEST: 'Oeste'\n\t};\n\t\n\tmodule.exports = TOKEN_NAMES;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tfunction Grammar(Parser, lexer, names, behaviour) {\n\t    'use strict';\n\t\n\t    var n = names;\n\t    var b = behaviour;\n\t    var g = new Parser(lexer);\n\t\n\t    function operator(op, bp, f) {\n\t        g.infix(op, bp, function (left) {\n\t            var self = this;\n\t            this.left = left;\n\t            this.right = g.expression(bp);\n\t            this.arity = 'binary';\n\t            this.eval = function (context) {\n\t                return f(self.right.eval(context), self.left.eval(context));\n\t            };\n\t            return this;\n\t        });\n\t    }\n\t\n\t    function parameterListCall() {\n\t        var parameters = [];\n\t        if (g.token.id !== ')') {\n\t            for (; ;) {\n\t                parameters.push(g.expression(0));\n\t                if (g.token.id !== ',') {\n\t                    break;\n\t                }\n\t                g.advance(',');\n\t            }\n\t        }\n\t        g.advance(')');\n\t        return parameters;\n\t    }\n\t\n\t    function parameterDeclarationList() {\n\t        var parameters = [];\n\t        g.advance('(');\n\t        if (g.token.id !== ')') {\n\t            for (; ;) {\n\t                if (g.token.arity !== 'name') {\n\t                    g.error(g.token, 'Expected a parameter name.');\n\t                }\n\t                g.scope.define(g.token);\n\t                parameters.push(g.token);\n\t                g.advance();\n\t                if (g.token.id !== ',') {\n\t                    break;\n\t                }\n\t                g.advance(',');\n\t            }\n\t        }\n\t        g.advance(')');\n\t        return parameters;\n\t    }\n\t\n\t    function parenthesisExpression() {\n\t        'use strict';\n\t        g.advance('(');\n\t        var p = g.expression(0);\n\t        g.advance(')');\n\t        return p;\n\t    }\n\t\n\t    function bodyStatement() {\n\t        return (g.token.id === '{') ? g.block() : [g.statement()];\n\t    }\n\t\n\t    operator('<', 40, function (x, y) {\n\t        return x < y;\n\t    });\n\t    operator('<=', 40, function (x, y) {\n\t        return x <= y;\n\t    });\n\t    operator('>', 40, function (x, y) {\n\t        return x > y;\n\t    });\n\t    operator('>=', 40, function (x, y) {\n\t        return x >= y;\n\t    });\n\t    operator('!=', 40, function (x, y) {\n\t        return x !== y;\n\t    });\n\t    operator('==', 40, function (x, y) {\n\t        return x === y;\n\t    });\n\t    operator('||', 20, function (x, y) {\n\t        return x || y;\n\t    });\n\t    operator('&&', 20, function (x, y) {\n\t        return x && y;\n\t    });\n\t    operator('+', 50, function (x, y) {\n\t        return x + y;\n\t    });\n\t    operator('-', 50, function (x, y) {\n\t        return x - y;\n\t    });\n\t    operator('*', 60, function (x, y) {\n\t        return x * y;\n\t    });\n\t    operator('/', 60, function (x, y) {\n\t        return x / y;\n\t    });\n\t    \n\t    g.prefix(n.NOT, function (x) {\n\t       return b.negation(g.expression(60)); \n\t    });\n\t\n\t    g.symbol('(end)');\n\t\n\t    g.symbol(':');\n\t    g.symbol(')');\n\t    g.symbol('(');\n\t    g.symbol(']');\n\t    g.symbol('}');\n\t    g.symbol(',');\n\t    g.symbol('->');\n\t    g.symbol(n.ELSE);\n\t    g.symbol(n.TO);\n\t\n\t    g.constant(n.FALSE, false);\n\t    g.constant(n.TRUE, true);\n\t    g.constant(n.BLUE, 0);\n\t    g.constant(n.RED, 1);\n\t    g.constant(n.BLACK, 2);\n\t    g.constant(n.GREEN, 3);\n\t    g.constant(n.NORTH, [0, 1]);\n\t    g.constant(n.SOUTH, [0, -1]);\n\t    g.constant(n.EAST, [1, 0]);\n\t    g.constant(n.WEST, [-1, 0]);\n\t\n\t    g.stmt(';', function () {\n\t        return {separator: ';'};\n\t    });\n\t\n\t    g.infix('(', 80, function (left) {\n\t        if (left.arity !== 'name') {\n\t            g.error(left, left.value + ' is not a routine');\n\t        }\n\t        var parameters = parameterListCall();\n\t        var node;\n\t        if (left.value[0].toUpperCase() === left.value[0]) {\n\t            node = b.procedureCall(left.value, function () {\n\t                return g.scope.find(left.value);\n\t            }, parameters);\n\t        } else {\n\t            node = b.functionCall(left.value, function () {\n\t                return g.scope.find(left.value);\n\t            }, parameters);\n\t        }\n\t        return node;\n\t    });\n\t\n\t    g.infixr(':=', 10, function (left) {\n\t        if (left.id !== '.' && left.id !== '[' && left.arity !== 'name') {\n\t            g.error(left, 'Bad lvalue.');\n\t        }\n\t        return b.assignment(left, g.expression(9));\n\t    });\n\t\n\t    g.stmt(n.PUT, function () {\n\t        return b.putStone(parenthesisExpression());\n\t    });\n\t    g.stmt(n.REMOVE, function () {\n\t        return b.removeStone(parenthesisExpression());\n\t    });\n\t    g.stmt(n.MOVE, function () {\n\t        return b.moveClaw(parenthesisExpression());\n\t    });\n\t    g.prefix(n.HAS_STONES, function () {\n\t        return b.hasStone(parenthesisExpression());\n\t    });\n\t    g.prefix(n.CAN_MOVE, function () {\n\t        return b.canMove(parenthesisExpression());\n\t    });\n\t\n\t    g.symbol('(literal)').nud = b.literal();\n\t    g.symbol('(name)').nud = b.variable();\n\t\n\t    g.stmt(n.IF, function () {\n\t        g.advance('(');\n\t        var condition = g.expression(0);\n\t        g.advance(')');\n\t        var trueBranch = bodyStatement();\n\t        var falseBranch = null;\n\t        if (g.token.id === n.ELSE) {\n\t            g.scope.reserve(g.token);\n\t            g.advance(n.ELSE);\n\t            falseBranch = bodyStatement();\n\t        }\n\t        return b.conditional(condition, trueBranch, falseBranch);\n\t    });\n\t\n\t    g.stmt(n.SWITCH, function () {\n\t        var condition = parenthesisExpression();\n\t        if (g.token.id === n.TO) {\n\t           g.advance(n.TO); \n\t        }\n\t        g.advance('{');\n\t        var cases = [];\n\t        for (; ;) {\n\t            var exp = g.expression(0);\n\t            g.advance('->');\n\t            var body = bodyStatement();\n\t            cases.push({\n\t                case: exp,\n\t                body: body\n\t            });\n\t            if (g.token.id === '}' || !g.tokens.hasNext()) {\n\t                break;\n\t            }\n\t        }\n\t        g.advance('}');\n\t        return b.switch(condition, cases);\n\t    });\n\t\n\t    g.stmt(n.WHILE, function () {\n\t        var condition = parenthesisExpression();\n\t        var body = bodyStatement();\n\t        return b.conditionalRepetition(condition, body);\n\t    });\n\t\n\t    g.stmt(n.REPEAT, function () {\n\t        var numericExpression = parenthesisExpression();\n\t        var body = bodyStatement();\n\t        return b.numericRepetition(numericExpression, body);\n\t    });\n\t\n\t    g.stmt('{', function () {\n\t        var a = g.statements();\n\t        g.advance('}');\n\t        return a;\n\t    });\n\t\n\t    g.stmt('(', function () {\n\t        var a = g.statements();\n\t        g.advance(')');\n\t        return a;\n\t    });\n\t\n\t    g.root(n.PROGRAM, function () {\n\t        return b.programDeclaration(g.block());\n\t    });\n\t\n\t    g.root(n.FUNCTION, function () {\n\t        g.newScope();\n\t        var token = g.token;\n\t        if (g.token.arity === 'name') {\n\t            g.scope.define(g.token);\n\t            g.advance();\n\t        }\n\t        var parameters = parameterDeclarationList();\n\t        var body = bodyStatement();\n\t        var ret = body.pop();\n\t        if (!ret || ret.alias !== 'return' || !ret.expression) {\n\t            g.error(token, 'La función ' + token.value + ' debe terminar con un ' + n.RETURN);\n\t        }\n\t        g.scope.pop();\n\t        var declaration = b.functionDeclaration(token, parameters, body, ret.expression);\n\t        declaration.std = function () {\n\t            return declaration;\n\t        };\n\t        return declaration;\n\t    });\n\t\n\t    g.root(n.PROCEDURE, function () {\n\t        /**\n\t         * Bind scope to token\n\t         * Bind declaration to token\n\t         */\n\t\n\t        g.newScope();\n\t        var token = g.token;\n\t        if (g.token.arity === 'name') {\n\t            g.scope.define(g.token);\n\t            g.advance();\n\t        }\n\t        var parameters = parameterDeclarationList();\n\t        var body = bodyStatement();\n\t        g.scope.pop();\n\t        var declaration = b.procedureDeclaration(token, parameters, body);\n\t        declaration.std = function () {\n\t            return declaration;\n\t        };\n\t        return declaration;\n\t    });\n\t\n\t    g.stmt(n.RETURN, function () {\n\t        if (g.token.id !== ';') {\n\t            this.alias = 'return';\n\t            this.expression = parenthesisExpression();\n\t        }\n\t        return this;\n\t    });\n\t\n\t    return b.rootProgram(g);\n\t}\n\t\n\tmodule.exports = Grammar;\n\t\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Context = __webpack_require__(1);\n\t\n\tvar Statement = {\n\t    arity: 'statement'\n\t};\n\t\n\tfunction interpretBlock(block, context) {\n\t    block = block || [];\n\t    for (var i = 0; i < block.length; i++) {\n\t        block[i].interpret(context);\n\t    }\n\t}\n\t\n\tfunction fillParameters(context, parameters, declaration) {\n\t    for (var i = 0; i < declaration.parameters.length; i++) {\n\t        context.put(declaration.parameters[i].value, parameters[i].eval(context));\n\t    }\n\t}\n\t\n\tvar behaviours = {\n\t    conditional: function (condition, left, right) {\n\t        var stmt = Object.create(Statement);\n\t        stmt.alias = 'conditional';\n\t        stmt.condition = condition;\n\t        stmt.left = left;\n\t        stmt.right = right;\n\t        stmt.interpret = function (context) {\n\t            interpretBlock(condition.eval(context) ? left : right, context);\n\t            return context;\n\t        };\n\t        return stmt;\n\t    },\n\t    literal: function () {\n\t        return function () {\n\t            var self = this;\n\t            this.eval = function () {\n\t                return self.value;\n\t            };\n\t            return this;\n\t        };\n\t    },\n\t    variable: function () {\n\t        return function () {\n\t            var self = this;\n\t            this.eval = function (context) {\n\t                return context.get(self.value);\n\t            };\n\t            return this;\n\t        };\n\t    },\n\t    conditionalRepetition: function (condition, body) {\n\t        var stmt = Object.create(Statement);\n\t        stmt.alias = 'while';\n\t        stmt.expression = condition;\n\t        stmt.body = body;\n\t        stmt.interpret = function (context) {\n\t            while (condition.eval(context)) {\n\t                interpretBlock(body, context);\n\t            }\n\t            return context;\n\t        };\n\t        return stmt;\n\t    },\n\t    numericRepetition: function (numericExpression, body) {\n\t        var stmt = Object.create(Statement);\n\t        stmt.alias = 'repeat';\n\t        stmt.expression = numericExpression;\n\t        stmt.body = body;\n\t        stmt.interpret = function (context) {\n\t            var times = numericExpression.eval(context);\n\t            for (var i = 0; i <= times; i++) {\n\t                interpretBlock(body, context);\n\t            }\n\t            return context;\n\t        };\n\t        return stmt;\n\t    },\n\t    assignment: function (left, right) {\n\t        var stmt = Object.create(Statement);\n\t        stmt.alias = ':=';\n\t        stmt.arity = 'binary';\n\t        stmt.variable = left;\n\t        stmt.expression = right;\n\t        stmt.assignment = true;\n\t        stmt.interpret = function (context) {\n\t            context.put(left.value, right.eval(context));\n\t        };\n\t        return stmt;\n\t    },\n\t    switch: function (condition, cases) {\n\t        var stmt = Object.create(Statement);\n\t        stmt.alias = 'switch';\n\t        stmt.value = condition;\n\t        stmt.cases = cases;\n\t        stmt.interpret = function (context) {\n\t            var value = condition.eval(context);\n\t            \n\t            for (var i = 0; i < cases.length; i++) {\n\t                console.log(value, \"   ---   \",cases[i].case.eval(context), value == cases[i].case.eval(context), value === cases[i].case.eval(context));\n\t                if (cases[i].case.eval(context) === value) {\n\t                    console.log(cases[i].body, \" <<<<<< \");\n\t                    interpretBlock(cases[i].body, context);\n\t                }\n\t            }\n\t            return context;\n\t        };\n\t        return stmt;\n\t    },\n\t    procedureCall: function (name, declaration, parameters) {\n\t        var stmt = Object.create(Statement);\n\t        stmt.arity = 'routine';\n\t        stmt.alias = 'ProcedureCall';\n\t        stmt.name = name;\n\t        stmt.parameters = parameters;\n\t\n\t        stmt.interpret = function (context) {\n\t            context.startContext();\n\t            fillParameters(context, parameters, declaration);\n\t            interpretBlock(declaration.body, context);\n\t            context.stopContext();\n\t            return context;\n\t        };\n\t        return stmt;\n\t    },\n\t    functionCall: function (name, declarationProvider, parameters) {\n\t        var stmt = {};\n\t        stmt.alias = 'functionCall';\n\t        stmt.name = name;\n\t        stmt.eval = function (context) {\n\t            var declaration = declarationProvider();\n\t            context.startContext();\n\t            context.pushBoard();\n\t            if (declaration.parameters) {\n\t                fillParameters(context, parameters, declaration);\n\t            }\n\t            interpretBlock(declaration.body, context);\n\t            var result = declaration.return.eval(context);\n\t            context.popBoard();\n\t            context.stopContext();\n\t            return result;\n\t        };\n\t        return stmt;\n\t    },\n\t    putStone: function (expression) {\n\t        var stmt = Object.create(Statement);\n\t        stmt.alias = 'PutStone';\n\t        stmt.color = expression;\n\t        stmt.interpret = function (context) {\n\t            context.board().putStone(expression.eval(context));\n\t            return context;\n\t        };\n\t        return stmt;\n\t    },\n\t    negation: function(expression) {\n\t        var exp = {arity: 'unary'};\n\t        exp.alias = 'not';\n\t        exp.expression = expression;\n\t        exp.eval = function (context) {\n\t            return !expression.eval(context);\n\t        };\n\t        return this;\n\t    },\n\t    removeStone: function (expression) {\n\t        var stmt = Object.create(Statement);\n\t        stmt.alias = 'RemoveStone';\n\t        stmt.parameters = [expression];\n\t        stmt.interpret = function (context) {\n\t            context.board().removeStone(expression.eval(context));\n\t            return context;\n\t        };\n\t        return stmt;\n\t    },\n\t    moveClaw: function (expression) {\n\t        var stmt = Object.create(Statement);\n\t        stmt.alias = 'MoveClaw';\n\t        stmt.paramters = [expression];\n\t        stmt.interpret = function (context) {\n\t            context.board().move(expression.eval(context));\n\t            return context;\n\t        };\n\t        return stmt;\n\t    },\n\t    hasStone: function (expression) {\n\t        var fun = {};\n\t        fun.eval = function (context) {\n\t            return context.board().hasStone(expression.eval(context));\n\t        };\n\t        return fun;\n\t    },\n\t    canMove: function (expression) {\n\t        var fun = {};\n\t        fun.eval = function (context) {\n\t            return context.board().canMove(expression.eval(context));\n\t        };\n\t        return fun;\n\t    },\n\t    programDeclaration: function (body) {\n\t        var stmt = Object.create(Statement);\n\t        stmt.alias = 'program';\n\t        stmt.body = body;\n\t        stmt.interpret = function (context) {\n\t            interpretBlock(body, context);\n\t            return context;\n\t        };\n\t        return stmt;\n\t    },\n\t    procedureDeclaration: function (token, parameters, body) {\n\t        token.name = token.value;\n\t        token.arity = 'routine';\n\t        token.alias = 'procedureDeclaration';\n\t        token.parameters = parameters;\n\t        token.body = body;\n\t        token.interpret = function (context) {\n\t            return context;\n\t        };\n\t        return token;\n\t    },\n\t    functionDeclaration: function (token, parameters, body, returnExpression) {\n\t        token.interpret = function (context) {\n\t            return context;\n\t        };\n\t        token.name = token.value;\n\t        token.arity = 'routine';\n\t        token.alias = 'functionDeclaration';\n\t        token.parameters = parameters;\n\t        token.body = body;\n\t        token.return = returnExpression;\n\t        return token;\n\t    },\n\t    rootProgram: function (grammar) {\n\t        grammar.interpret = function (root, context) {\n\t            var main;\n\t            var declarations = [];\n\t            context = context || new Context();\n\t            for (var i = 0; i < root.length; i++) {\n\t                if (root[i].alias === 'program') {\n\t                    main = root[i];\n\t                } else {\n\t                    declarations.push(root[i]);\n\t                }\n\t            }\n\t            interpretBlock(declarations, context);\n\t            main.interpret(context);\n\t        };\n\t        return grammar;\n\t    }\n\t};\n\t\n\tmodule.exports = behaviours;\n\t\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * LEXER\n\t *\n\t * The lexer class is an iterator that takes a String as input in Lexer.input\n\t * and returns a token each time Lexer.next is called, or null otherwise.\n\t * Characters used for multi character operators can be configured on instantiation.\n\t */\n\t\n\t// PUBLIC\n\t\n\tfunction Lexer(prefix, suffix) {\n\t    // Current reading position\n\t    this.from = 0;\n\t    this.row = 0;\n\t    this.prefix = prefix || '!=-<>:|&';\n\t    this.suffix = suffix || '=|&>';\n\t\n\t    this.punctuators = '+-*.:%|!?#&;,()<>{}[]=';\n\t\n\t    // Look ahead position\n\t    this.i = 0;\n\t\n\t    this.buf = null;\n\t    this.buflen = 0;\n\t}\n\t\n\tLexer.prototype.hasNext = function () {\n\t    this._skipNonTokens();\n\t    return this.from < this.buflen;\n\t};\n\t\n\tLexer.prototype.input = function (buf) {\n\t    this.from = 0;\n\t    this.i = 0;\n\t    this.row = 0;\n\t    this.buf = buf;\n\t    this.buflen = buf.length;\n\t    this.current = null;\n\t    this.nextChar = null;\n\t};\n\t\n\tvar TokenTypes = {\n\t    IDENTIFIER: 'name',\n\t    OPERATOR: 'operator',\n\t    EOF: 'eof',\n\t    COMMENT: 'comment',\n\t    NUMBER: 'number',\n\t    NEWLINE: 'newline'\n\t};\n\t\n\t/**\n\t * This method is highly procedural for performance reasons.\n\t * There is no need for the lexer to be too flexible, since the\n\t * semantics will be associated to identifiers on the parser.\n\t *\n\t * @returns Token. The next token on the buffer, or null if the buffer is empty.\n\t */\n\tLexer.prototype.next = function () {\n\t    this._skipNonTokens();\n\t    this._refreshCurrentAndNextChars();\n\t\n\t    if (this.from >= this.buflen) {\n\t        return null;\n\t    }\n\t\n\t    // Always add cases in descending order of occurrence probability\n\t    if (this._processIdentifier()) {\n\t        return this._consume(TokenTypes.IDENTIFIER);\n\t    } else if (this._processOperator()) {\n\t        return this._consume(TokenTypes.OPERATOR);\n\t    } else if (this._processNumber()) {\n\t        return this._consume(TokenTypes.NUMBER);\n\t    } else if (this._processComment()) {\n\t        return this._consume(TokenTypes.COMMENT);\n\t    }\n\t\n\t    return this._processError();\n\t};\n\t\n\t// PRIVATE\n\t\n\tfunction error(token, description) {\n\t    return {error: description, on: token};\n\t}\n\t\n\tLexer.prototype._make = function (type, value) {\n\t    return {type: type, value: value, from: this.from, to: this.i, row: this.row};\n\t};\n\t\n\tLexer.prototype._consume = function (type) {\n\t    var text = this.buf.substring(this.from, this.i);\n\t    var newToken = this._make(type, text);\n\t    this.from = this.i;\n\t    return newToken;\n\t};\n\t\n\tLexer.prototype._refreshCurrentAndNextChars = function () {\n\t    this.current = this.buf.charAt(this.from);\n\t    this.nextChar = this.buf.charAt(this.from + 1);\n\t};\n\t\n\tLexer.prototype._processOperator = function () {\n\t    if (this.punctuators.indexOf(this.current) >= 0) {\n\t        this.i = this.from + 1;\n\t        this._processMultiCharOperator();\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\tLexer.prototype._processMultiCharOperator = function () {\n\t    if (this.prefix.indexOf(this.current) >= 0 && this.suffix.indexOf(this.nextChar) >= 0) {\n\t        this.i++;\n\t    }\n\t};\n\t\n\tLexer.prototype._processNumber = function () {\n\t    if (_isDigit(this.current)) {\n\t        this.i = this.from + 1;\n\t        while (this.i < this.buflen && _isDigit(this.buf.charAt(this.i))) {\n\t            this.i++;\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\tLexer.prototype._processError = function () {\n\t    this.i = this.from + 1;\n\t    return error('Unmatched token', this._consume('UNMATCHED'));\n\t};\n\t\n\tLexer.prototype._processIdentifier = function () {\n\t    if (_isAlpha(this.current)) {\n\t        this.i = this.from + 1;\n\t        while (this.i < this.buflen && _isAlphanum(this.buf.charAt(this.i))) {\n\t            this.i++;\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\tLexer.prototype._skipNonTokens = function () {\n\t    while (this.from < this.buflen) {\n\t        var c = this.buf.charAt(this.from);\n\t        if (c === ' ' || c === '\\t' || c === '\\r' || c === '\\n') {\n\t            if (c === '\\n') {\n\t                this.row += 1;\n\t            }\n\t            this.from++;\n\t            this.i = this.from;\n\t        } else {\n\t            break;\n\t        }\n\t    }\n\t};\n\t\n\tLexer.prototype._processComment = function () {\n\t    var chars = this.current + this.nextChar;\n\t    return this._processSingleLineComment(chars) || this._processMultiLineComment(chars);\n\t};\n\t\n\tLexer.prototype._processSingleLineComment = function (chars) {\n\t    if (chars === '//') {\n\t        while (this.i < this.buflen && !_isNewline(this.buf.charAt(this.i))) {\n\t            this.i++;\n\t        }\n\t        return true;\n\t    }\n\t};\n\t\n\tLexer.prototype._processMultiLineComment = function (chars) {\n\t    if (chars === '/*') {\n\t        this.i = this.i + 2;\n\t        while (this.i < this.buflen && this.buf.charAt(this.i) !== '*' && this.buf.charAt(this.i + 1) !== '/') {\n\t            this.i++;\n\t        }\n\t        this.i = this.i + 2;\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\tfunction _isNewline(c) {\n\t    return c === '\\r' || c === '\\n';\n\t}\n\t\n\tfunction _isDigit(c) {\n\t    return c >= '0' && c <= '9';\n\t}\n\t\n\tfunction _isAlpha(c) {\n\t    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '_' || c === '$';\n\t}\n\t\n\tfunction _isAlphanum(c) {\n\t    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c === '_' || c === '$';\n\t}\n\t\n\tmodule.exports = Lexer;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tfunction Board(sizeX, sizeY) {\n\t    this.x = 0;\n\t    this.y = 0;\n\t\n\t    this.sizeX = sizeX;\n\t    this.sizeY = sizeY;\n\t}\n\t\n\tBoard.blue = 0;\n\tBoard.red = 1;\n\tBoard.black = 2;\n\tBoard.green = 3;\n\t\n\tBoard.prototype.init = function () {\n\t    this.table = [[], [], [], []];\n\t    for (var i = 0; i < this.sizeX; i++) {\n\t        this.table[0][i] = [];\n\t        this.table[1][i] = [];\n\t        this.table[2][i] = [];\n\t        this.table[3][i] = [];\n\t        for (var j = 0; j < this.sizeY; j++) {\n\t            this.table[0][i][j] = 0;\n\t            this.table[1][i][j] = 0;\n\t            this.table[2][i][j] = 0;\n\t            this.table[3][i][j] = 0;\n\t        }\n\t    }\n\t};\n\t\n\tBoard.prototype.clone = function () {\n\t    var c = new Board(this.sizeX, this.sizeY);\n\t    c.init();\n\t    for (var i = 0; i < this.table.length; i++) {\n\t        c.table[i] = this.table[i].slice();\n\t    }\n\t    c.x = this.x;\n\t    c.y = this.y;\n\t    return c;\n\t};\n\t\n\tBoard.prototype.putStone = function (color) {\n\t    this.table[color][this.x][this.y] += 1;\n\t};\n\t\n\tBoard.prototype.removeStone = function (color) {\n\t    this.table[color][this.x][this.y] -= 1;\n\t};\n\t\n\tBoard.prototype.hasStone = function (color) {\n\t    return this.table[color][this.x][this.y];\n\t};\n\t\n\tBoard.prototype.canMove = function (vec) {\n\t    var nextX = this.x + vec[0];\n\t    var nextY = this.y + vec[1];\n\t    return nextX < this.sizeX && nextX >= 0 && nextY < this.sizeY && nextY >= 0;\n\t};\n\t\n\tBoard.prototype.move = function (vec) {\n\t    this.x += vec[0];\n\t    this.y += vec[1];\n\t};\n\t\n\tBoard.prototype.printAscii = function () {\n\t    var out = this.sizeX + 'x' + this.sizeY + '\\n';\n\t    var az = this.table[0];\n\t    var ro = this.table[1];\n\t    var ne = this.table[2];\n\t    var ve = this.table[3];\n\t    for (var j = this.sizeY - 1; j >= 0; j--) {\n\t        for (var i = 0; i < this.sizeX; i++) {\n\t            out += (az[i][j] || ro[i][j] || ne[i][j] || ve[i][j]) ? '#' : '.';\n\t        }\n\t        out += '\\n';\n\t    }\n\t    return out;\n\t};\n\t\n\tmodule.exports = Board;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tfunction Parser(lexer) {\n\t    this.scope = null;\n\t    this.token = null;\n\t    this.tokens = lexer;\n\t    var self = this;\n\t\n\t    var symbolTable = {};\n\t\n\t    this.error = function (token, description) {\n\t        var someError = {error: description, on: token};\n\t        throw someError;\n\t    };\n\t\n\t    var OriginalSymbol = {\n\t        nud: function () {\n\t            self.error(this, 'Undefined.');\n\t        },\n\t        led: function () {\n\t            self.error(this, 'Missing operator.');\n\t        }\n\t    };\n\t\n\t    var itself = function () {\n\t        return this;\n\t    };\n\t\n\t    var originalScope = {\n\t        define: function (name) {\n\t            var t = this.def[name.value];\n\t            if (typeof t === 'object') {\n\t                self.error(name, t.reserved ? 'Already reserved.' : 'Already defined.');\n\t            }\n\t            this.def[name.value] = name;\n\t            name.reserved = false;\n\t            name.nud = itself;\n\t            name.led = null;\n\t            name.std = null;\n\t            name.lbp = 0;\n\t            name.scope = self.scope;\n\t            return name;\n\t        },\n\t        find: function (name) {\n\t            var e = this;\n\t            var targetToken;\n\t            for (; ;) {\n\t                targetToken = e.def[name];\n\t                if (targetToken && typeof targetToken !== 'function') {\n\t                    return e.def[name];\n\t                }\n\t                e = e.parent;\n\t                if (!e) {\n\t                    targetToken = symbolTable[name];\n\t                    return targetToken && typeof targetToken !== 'function' ? targetToken : symbolTable['(name)'];\n\t                }\n\t            }\n\t        },\n\t        pop: function () {\n\t            this.scope = this.parent;\n\t        },\n\t        reserve: function (name) {\n\t            if (name.arity !== 'name' || name.reserved) {\n\t                return;\n\t            }\n\t            var t = this.def[name.value];\n\t            if (t) {\n\t                if (t.reserved) {\n\t                    return;\n\t                }\n\t                if (t.arity === 'name') {\n\t                    name.error('Already defined.');\n\t                }\n\t            }\n\t            this.def[name.value] = name;\n\t            name.reserved = true;\n\t        }\n\t    };\n\t\n\t    this.newScope = function () {\n\t        var s = self.scope;\n\t        self.scope = Object.create(originalScope);\n\t        self.scope.def = {};\n\t        self.scope.parent = s;\n\t        return self.scope;\n\t    };\n\t\n\t    this.symbol = function (id, bindingPower) {\n\t        var s = symbolTable[id];\n\t        bindingPower = bindingPower || 0;\n\t        if (s) {\n\t            if (bindingPower >= s.lbp) {\n\t                s.lbp = bindingPower;\n\t            }\n\t        } else {\n\t            s = Object.create(OriginalSymbol);\n\t            s.id = s.value = id;\n\t            s.lbp = bindingPower;\n\t            symbolTable[id] = s;\n\t        }\n\t        return s;\n\t    };\n\t\n\t    this.expression = function (rightBindingPower) {\n\t        var left;\n\t        var t = self.token;\n\t        this.advance();\n\t        left = t.nud();\n\t        while (rightBindingPower < self.token.lbp) {\n\t            t = self.token;\n\t            this.advance();\n\t            left = t.led(left);\n\t        }\n\t        return left;\n\t    };\n\t\n\t    this.constant = function (symbol, value) {\n\t        var x = this.symbol(symbol);\n\t        x.nud = function () {\n\t            self.scope.reserve(this);\n\t            this.value = symbolTable[this.id].value;\n\t            this.arity = 'literal';\n\t            this.eval = function () {\n\t                return value;\n\t            };\n\t            return this;\n\t        };\n\t        x.value = value;\n\t        return x;\n\t    };\n\t\n\t    this.infix = function (id, bp, led) {\n\t        var s = this.symbol(id, bp);\n\t        s.led = led || function (left) {\n\t            this.left = left;\n\t            this.right = self.expression(bp);\n\t            this.arity = 'binary';\n\t            return this;\n\t        };\n\t        return s;\n\t    };\n\t\n\t    this.infixr = function (id, bp, led) {\n\t        var s = this.symbol(id, bp);\n\t        s.led = led || function (left) {\n\t            this.left = left;\n\t            this.right = self.expression(bp - 1);\n\t            this.arity = 'binary';\n\t            return this;\n\t        };\n\t        return s;\n\t    };\n\t\n\t    this.prefix = function (id, nud) {\n\t        var s = this.symbol(id);\n\t        s.nud = nud || function () {\n\t            scope.reserve(this);\n\t            this.left = self.expression(70);\n\t            this.arity = 'unary';\n\t            return this;\n\t        };\n\t        return s;\n\t    };\n\t\n\t    this.stmt = function (symbol, f) {\n\t        var x = this.symbol(symbol);\n\t        x.std = f;\n\t        return x;\n\t    };\n\t\n\t    this.root = function (symbol, f) {\n\t        var x = this.symbol(symbol);\n\t        x.root = f;\n\t        return x;\n\t    };\n\t\n\t    /**\n\t     * The advance function fetches the next token,\n\t     * generating the corresponding symbol from the definitions on symbolTable\n\t     *\n\t     * @param id. Token ID\n\t     * @returns Token\n\t     */\n\t    this.advance = function (id) {\n\t        var a;\n\t        var o;\n\t        var t;\n\t        var v;\n\t        var tokens = this.tokens;\n\t        if (id && this.token.id !== id) {\n\t            this.error(this.token, 'Se esperaba \"' + id + '\" pero se encontró ' + this.token.value);\n\t        }\n\t        if (!tokens.hasNext()) {\n\t            this.token = symbolTable['(end)'];\n\t            return this.token;\n\t        }\n\t        t = tokens.next();\n\t        v = t.value;\n\t        a = t.type;\n\t        if (a === 'name') {\n\t            o = this.scope.find(v);\n\t        } else if (a === 'operator') {\n\t            o = symbolTable[v];\n\t            if (!o) {\n\t                this.error(t, 'Unknown operator.');\n\t            }\n\t        } else if (a === 'number') {\n\t            o = symbolTable['(literal)'];\n\t            a = 'literal';\n\t            v = parseInt(v, 10);\n\t        } else {\n\t            this.error(t, 'Unexpected token.');\n\t        }\n\t\n\t        var token = Object.create(o);\n\t        token.from = t.from;\n\t        token.row = t.row;\n\t        token.to = t.to;\n\t        token.value = v;\n\t        token.arity = a;\n\t        this.token = token;\n\t        return token;\n\t    };\n\t\n\t    this.block = function () {\n\t        var t = this.token;\n\t        this.advance('{');\n\t        return t.std();\n\t    };\n\t\n\t    this.statement = function () {\n\t        var n = this.token;\n\t        var v;\n\t\n\t        if (n.std) {\n\t            this.advance();\n\t            self.scope.reserve(n);\n\t            return n.std();\n\t        }\n\t        v = this.expression(0);\n\t        if (!v.assignment && v.id !== '(' && v.arity !== 'routine') {\n\t            this.error(v, 'Bad expression statement.');\n\t        }\n\t        return v;\n\t    };\n\t\n\t    this.rootDeclaration = function () {\n\t        var n = this.token;\n\t        var v;\n\t\n\t        if (n.root) {\n\t            this.advance();\n\t            self.scope.reserve(n);\n\t            return n.root();\n\t        }\n\t        v = this.expression(0);\n\t        if (!v.assignment && v.id !== '(' && v.arity !== 'routine') {\n\t            this.error(v, 'Bad expression statement.');\n\t        }\n\t        return v;\n\t    };\n\t\n\t    this.statements = function () {\n\t        var statementsList = [];\n\t        var symbol;\n\t        for (; ;) {\n\t            if (this.token.id === '}' || this.token.id === '(end)') {\n\t                break;\n\t            }\n\t            var from = this.token.from;\n\t            symbol = this.statement();\n\t            if (symbol) {\n\t                symbol.from = from;\n\t                if (this.token.from) {\n\t                    symbol.to = this.token.from;\n\t                }\n\t                statementsList.push(symbol);\n\t            }\n\t        }\n\t        if (statementsList.length === 0) {\n\t            return null;\n\t        }\n\t        return statementsList;\n\t    };\n\t\n\t    this.roots = function () {\n\t        var roots = [];\n\t        var symbol;\n\t        for (; ;) {\n\t            if (this.token.id === '(end)') {\n\t                break;\n\t            }\n\t            var from = this.token.from;\n\t            symbol = this.rootDeclaration();\n\t            if (symbol) {\n\t                symbol.from = from;\n\t                if (this.token.from) {\n\t                    symbol.to = this.token.from;\n\t                }\n\t                roots.push(symbol);\n\t            }\n\t        }\n\t        if (roots.length === 0) {\n\t            return null;\n\t        }\n\t        return roots;\n\t    };\n\t\n\t    this.parseProgram = function (input) {\n\t        this.tokens.input(input);\n\t        this.newScope();\n\t        this.advance();\n\t        var s = this.roots();\n\t        this.advance('(end)');\n\t        this.scope.pop();\n\t        return s;\n\t    };\n\t\n\t    this.parse = function (input) {\n\t        this.tokens.input(input);\n\t        this.newScope();\n\t        this.advance();\n\t        var s = this.statements();\n\t        this.advance('(end)');\n\t        this.scope.pop();\n\t        return s;\n\t    };\n\t\n\t    this.parseExpression = function (input) {\n\t        this.tokens.input(input);\n\t        this.newScope();\n\t        this.advance();\n\t        var s = this.expression(0);\n\t        this.advance('(end)');\n\t        this.scope.pop();\n\t        return s;\n\t    };\n\t}\n\t\n\tmodule.exports = Parser;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** index.umd.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 88d6d51746274b29c8dc\n **/","module.exports = {\n    grammar: require('../lib/grammar'),\n    parser: require('../lib/parser'),\n    lexer: require('../lib/lexer'),\n    tokens: require('../lib/gobstones-tokens-en'),\n    interpreter: require('../lib/interpreter'),\n    context: require('../lib/execution-context')\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/public.js\n ** module id = 0\n ** module chunks = 0\n **/","var Board = require('./model');\n\nvar Context = function () {\n    var variablesStack = [];\n    var boardsStack = [];\n    var currentBoard = new Board(9, 9);\n    var currentVariables = {};\n\n    this.init = function () {\n        currentBoard.init();\n    };\n\n    this.board = function () {\n        return currentBoard;\n    };\n\n    this.put = function (key, value) {\n        console.log('VARIABLE SET: ', key, '   ', value);\n        currentVariables[key] = value;\n    };\n\n    this.get = function (id) {\n        return currentVariables[id];\n    };\n\n    this.all = function () {\n        return currentVariables;\n    };\n\n    this.startContext = function () {\n        variablesStack.push(currentVariables);\n        currentVariables = {};\n    };\n\n    this.stopContext = function () {\n        currentVariables = variablesStack.pop();\n    };\n\n    this.pushBoard = function () {\n        boardsStack.push(currentBoard);\n        currentBoard = currentBoard.clone();\n    };\n\n    this.popBoard = function () {\n        currentBoard = boardsStack.pop();\n    };\n\n    this.init();\n};\n\nmodule.exports = Context;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/execution-context.js\n ** module id = 1\n ** module chunks = 0\n **/","var TOKEN_NAMES = {\n    WHILE: 'while',\n    IF: 'if',\n    ELSE: 'else',\n    SWITCH: 'switch',\n    REPEAT: 'repeat',\n    FUNCTION: 'function',\n    PROCEDURE: 'procedure',\n    PROGRAM: 'program',\n    PUT: 'Poner',\n    REMOVE: 'Sacar',\n    HAS_STONES: 'hayBolitas',\n    CAN_MOVE: 'puedeMover',\n    MOVE: 'Mover',\n    RETURN: 'return',\n    RED: 'Rojo',\n    BLUE: 'Azul',\n    BLACK: 'Negro',\n    GREEN: 'Verde',\n    TRUE: 'True',\n    NOT: 'not',\n    TO: 'to',\n    FALSE: 'False',\n    NORTH: 'Norte',\n    SOUTH: 'Sur',\n    EAST: 'Este',\n    WEST: 'Oeste'\n};\n\nmodule.exports = TOKEN_NAMES;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/gobstones-tokens-en.js\n ** module id = 2\n ** module chunks = 0\n **/","function Grammar(Parser, lexer, names, behaviour) {\n    'use strict';\n\n    var n = names;\n    var b = behaviour;\n    var g = new Parser(lexer);\n\n    function operator(op, bp, f) {\n        g.infix(op, bp, function (left) {\n            var self = this;\n            this.left = left;\n            this.right = g.expression(bp);\n            this.arity = 'binary';\n            this.eval = function (context) {\n                return f(self.right.eval(context), self.left.eval(context));\n            };\n            return this;\n        });\n    }\n\n    function parameterListCall() {\n        var parameters = [];\n        if (g.token.id !== ')') {\n            for (; ;) {\n                parameters.push(g.expression(0));\n                if (g.token.id !== ',') {\n                    break;\n                }\n                g.advance(',');\n            }\n        }\n        g.advance(')');\n        return parameters;\n    }\n\n    function parameterDeclarationList() {\n        var parameters = [];\n        g.advance('(');\n        if (g.token.id !== ')') {\n            for (; ;) {\n                if (g.token.arity !== 'name') {\n                    g.error(g.token, 'Expected a parameter name.');\n                }\n                g.scope.define(g.token);\n                parameters.push(g.token);\n                g.advance();\n                if (g.token.id !== ',') {\n                    break;\n                }\n                g.advance(',');\n            }\n        }\n        g.advance(')');\n        return parameters;\n    }\n\n    function parenthesisExpression() {\n        'use strict';\n        g.advance('(');\n        var p = g.expression(0);\n        g.advance(')');\n        return p;\n    }\n\n    function bodyStatement() {\n        return (g.token.id === '{') ? g.block() : [g.statement()];\n    }\n\n    operator('<', 40, function (x, y) {\n        return x < y;\n    });\n    operator('<=', 40, function (x, y) {\n        return x <= y;\n    });\n    operator('>', 40, function (x, y) {\n        return x > y;\n    });\n    operator('>=', 40, function (x, y) {\n        return x >= y;\n    });\n    operator('!=', 40, function (x, y) {\n        return x !== y;\n    });\n    operator('==', 40, function (x, y) {\n        return x === y;\n    });\n    operator('||', 20, function (x, y) {\n        return x || y;\n    });\n    operator('&&', 20, function (x, y) {\n        return x && y;\n    });\n    operator('+', 50, function (x, y) {\n        return x + y;\n    });\n    operator('-', 50, function (x, y) {\n        return x - y;\n    });\n    operator('*', 60, function (x, y) {\n        return x * y;\n    });\n    operator('/', 60, function (x, y) {\n        return x / y;\n    });\n    \n    g.prefix(n.NOT, function (x) {\n       return b.negation(g.expression(60)); \n    });\n\n    g.symbol('(end)');\n\n    g.symbol(':');\n    g.symbol(')');\n    g.symbol('(');\n    g.symbol(']');\n    g.symbol('}');\n    g.symbol(',');\n    g.symbol('->');\n    g.symbol(n.ELSE);\n    g.symbol(n.TO);\n\n    g.constant(n.FALSE, false);\n    g.constant(n.TRUE, true);\n    g.constant(n.BLUE, 0);\n    g.constant(n.RED, 1);\n    g.constant(n.BLACK, 2);\n    g.constant(n.GREEN, 3);\n    g.constant(n.NORTH, [0, 1]);\n    g.constant(n.SOUTH, [0, -1]);\n    g.constant(n.EAST, [1, 0]);\n    g.constant(n.WEST, [-1, 0]);\n\n    g.stmt(';', function () {\n        return {separator: ';'};\n    });\n\n    g.infix('(', 80, function (left) {\n        if (left.arity !== 'name') {\n            g.error(left, left.value + ' is not a routine');\n        }\n        var parameters = parameterListCall();\n        var node;\n        if (left.value[0].toUpperCase() === left.value[0]) {\n            node = b.procedureCall(left.value, function () {\n                return g.scope.find(left.value);\n            }, parameters);\n        } else {\n            node = b.functionCall(left.value, function () {\n                return g.scope.find(left.value);\n            }, parameters);\n        }\n        return node;\n    });\n\n    g.infixr(':=', 10, function (left) {\n        if (left.id !== '.' && left.id !== '[' && left.arity !== 'name') {\n            g.error(left, 'Bad lvalue.');\n        }\n        return b.assignment(left, g.expression(9));\n    });\n\n    g.stmt(n.PUT, function () {\n        return b.putStone(parenthesisExpression());\n    });\n    g.stmt(n.REMOVE, function () {\n        return b.removeStone(parenthesisExpression());\n    });\n    g.stmt(n.MOVE, function () {\n        return b.moveClaw(parenthesisExpression());\n    });\n    g.prefix(n.HAS_STONES, function () {\n        return b.hasStone(parenthesisExpression());\n    });\n    g.prefix(n.CAN_MOVE, function () {\n        return b.canMove(parenthesisExpression());\n    });\n\n    g.symbol('(literal)').nud = b.literal();\n    g.symbol('(name)').nud = b.variable();\n\n    g.stmt(n.IF, function () {\n        g.advance('(');\n        var condition = g.expression(0);\n        g.advance(')');\n        var trueBranch = bodyStatement();\n        var falseBranch = null;\n        if (g.token.id === n.ELSE) {\n            g.scope.reserve(g.token);\n            g.advance(n.ELSE);\n            falseBranch = bodyStatement();\n        }\n        return b.conditional(condition, trueBranch, falseBranch);\n    });\n\n    g.stmt(n.SWITCH, function () {\n        var condition = parenthesisExpression();\n        if (g.token.id === n.TO) {\n           g.advance(n.TO); \n        }\n        g.advance('{');\n        var cases = [];\n        for (; ;) {\n            var exp = g.expression(0);\n            g.advance('->');\n            var body = bodyStatement();\n            cases.push({\n                case: exp,\n                body: body\n            });\n            if (g.token.id === '}' || !g.tokens.hasNext()) {\n                break;\n            }\n        }\n        g.advance('}');\n        return b.switch(condition, cases);\n    });\n\n    g.stmt(n.WHILE, function () {\n        var condition = parenthesisExpression();\n        var body = bodyStatement();\n        return b.conditionalRepetition(condition, body);\n    });\n\n    g.stmt(n.REPEAT, function () {\n        var numericExpression = parenthesisExpression();\n        var body = bodyStatement();\n        return b.numericRepetition(numericExpression, body);\n    });\n\n    g.stmt('{', function () {\n        var a = g.statements();\n        g.advance('}');\n        return a;\n    });\n\n    g.stmt('(', function () {\n        var a = g.statements();\n        g.advance(')');\n        return a;\n    });\n\n    g.root(n.PROGRAM, function () {\n        return b.programDeclaration(g.block());\n    });\n\n    g.root(n.FUNCTION, function () {\n        g.newScope();\n        var token = g.token;\n        if (g.token.arity === 'name') {\n            g.scope.define(g.token);\n            g.advance();\n        }\n        var parameters = parameterDeclarationList();\n        var body = bodyStatement();\n        var ret = body.pop();\n        if (!ret || ret.alias !== 'return' || !ret.expression) {\n            g.error(token, 'La función ' + token.value + ' debe terminar con un ' + n.RETURN);\n        }\n        g.scope.pop();\n        var declaration = b.functionDeclaration(token, parameters, body, ret.expression);\n        declaration.std = function () {\n            return declaration;\n        };\n        return declaration;\n    });\n\n    g.root(n.PROCEDURE, function () {\n        /**\n         * Bind scope to token\n         * Bind declaration to token\n         */\n\n        g.newScope();\n        var token = g.token;\n        if (g.token.arity === 'name') {\n            g.scope.define(g.token);\n            g.advance();\n        }\n        var parameters = parameterDeclarationList();\n        var body = bodyStatement();\n        g.scope.pop();\n        var declaration = b.procedureDeclaration(token, parameters, body);\n        declaration.std = function () {\n            return declaration;\n        };\n        return declaration;\n    });\n\n    g.stmt(n.RETURN, function () {\n        if (g.token.id !== ';') {\n            this.alias = 'return';\n            this.expression = parenthesisExpression();\n        }\n        return this;\n    });\n\n    return b.rootProgram(g);\n}\n\nmodule.exports = Grammar;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/grammar.js\n ** module id = 3\n ** module chunks = 0\n **/","var Context = require('./execution-context');\n\nvar Statement = {\n    arity: 'statement'\n};\n\nfunction interpretBlock(block, context) {\n    block = block || [];\n    for (var i = 0; i < block.length; i++) {\n        block[i].interpret(context);\n    }\n}\n\nfunction fillParameters(context, parameters, declaration) {\n    for (var i = 0; i < declaration.parameters.length; i++) {\n        context.put(declaration.parameters[i].value, parameters[i].eval(context));\n    }\n}\n\nvar behaviours = {\n    conditional: function (condition, left, right) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'conditional';\n        stmt.condition = condition;\n        stmt.left = left;\n        stmt.right = right;\n        stmt.interpret = function (context) {\n            interpretBlock(condition.eval(context) ? left : right, context);\n            return context;\n        };\n        return stmt;\n    },\n    literal: function () {\n        return function () {\n            var self = this;\n            this.eval = function () {\n                return self.value;\n            };\n            return this;\n        };\n    },\n    variable: function () {\n        return function () {\n            var self = this;\n            this.eval = function (context) {\n                return context.get(self.value);\n            };\n            return this;\n        };\n    },\n    conditionalRepetition: function (condition, body) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'while';\n        stmt.expression = condition;\n        stmt.body = body;\n        stmt.interpret = function (context) {\n            while (condition.eval(context)) {\n                interpretBlock(body, context);\n            }\n            return context;\n        };\n        return stmt;\n    },\n    numericRepetition: function (numericExpression, body) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'repeat';\n        stmt.expression = numericExpression;\n        stmt.body = body;\n        stmt.interpret = function (context) {\n            var times = numericExpression.eval(context);\n            for (var i = 0; i <= times; i++) {\n                interpretBlock(body, context);\n            }\n            return context;\n        };\n        return stmt;\n    },\n    assignment: function (left, right) {\n        var stmt = Object.create(Statement);\n        stmt.alias = ':=';\n        stmt.arity = 'binary';\n        stmt.variable = left;\n        stmt.expression = right;\n        stmt.assignment = true;\n        stmt.interpret = function (context) {\n            context.put(left.value, right.eval(context));\n        };\n        return stmt;\n    },\n    switch: function (condition, cases) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'switch';\n        stmt.value = condition;\n        stmt.cases = cases;\n        stmt.interpret = function (context) {\n            var value = condition.eval(context);\n            \n            for (var i = 0; i < cases.length; i++) {\n                console.log(value, \"   ---   \",cases[i].case.eval(context), value == cases[i].case.eval(context), value === cases[i].case.eval(context));\n                if (cases[i].case.eval(context) === value) {\n                    console.log(cases[i].body, \" <<<<<< \");\n                    interpretBlock(cases[i].body, context);\n                }\n            }\n            return context;\n        };\n        return stmt;\n    },\n    procedureCall: function (name, declaration, parameters) {\n        var stmt = Object.create(Statement);\n        stmt.arity = 'routine';\n        stmt.alias = 'ProcedureCall';\n        stmt.name = name;\n        stmt.parameters = parameters;\n\n        stmt.interpret = function (context) {\n            context.startContext();\n            fillParameters(context, parameters, declaration);\n            interpretBlock(declaration.body, context);\n            context.stopContext();\n            return context;\n        };\n        return stmt;\n    },\n    functionCall: function (name, declarationProvider, parameters) {\n        var stmt = {};\n        stmt.alias = 'functionCall';\n        stmt.name = name;\n        stmt.eval = function (context) {\n            var declaration = declarationProvider();\n            context.startContext();\n            context.pushBoard();\n            if (declaration.parameters) {\n                fillParameters(context, parameters, declaration);\n            }\n            interpretBlock(declaration.body, context);\n            var result = declaration.return.eval(context);\n            context.popBoard();\n            context.stopContext();\n            return result;\n        };\n        return stmt;\n    },\n    putStone: function (expression) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'PutStone';\n        stmt.color = expression;\n        stmt.interpret = function (context) {\n            context.board().putStone(expression.eval(context));\n            return context;\n        };\n        return stmt;\n    },\n    negation: function(expression) {\n        var exp = {arity: 'unary'};\n        exp.alias = 'not';\n        exp.expression = expression;\n        exp.eval = function (context) {\n            return !expression.eval(context);\n        };\n        return this;\n    },\n    removeStone: function (expression) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'RemoveStone';\n        stmt.parameters = [expression];\n        stmt.interpret = function (context) {\n            context.board().removeStone(expression.eval(context));\n            return context;\n        };\n        return stmt;\n    },\n    moveClaw: function (expression) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'MoveClaw';\n        stmt.paramters = [expression];\n        stmt.interpret = function (context) {\n            context.board().move(expression.eval(context));\n            return context;\n        };\n        return stmt;\n    },\n    hasStone: function (expression) {\n        var fun = {};\n        fun.eval = function (context) {\n            return context.board().hasStone(expression.eval(context));\n        };\n        return fun;\n    },\n    canMove: function (expression) {\n        var fun = {};\n        fun.eval = function (context) {\n            return context.board().canMove(expression.eval(context));\n        };\n        return fun;\n    },\n    programDeclaration: function (body) {\n        var stmt = Object.create(Statement);\n        stmt.alias = 'program';\n        stmt.body = body;\n        stmt.interpret = function (context) {\n            interpretBlock(body, context);\n            return context;\n        };\n        return stmt;\n    },\n    procedureDeclaration: function (token, parameters, body) {\n        token.name = token.value;\n        token.arity = 'routine';\n        token.alias = 'procedureDeclaration';\n        token.parameters = parameters;\n        token.body = body;\n        token.interpret = function (context) {\n            return context;\n        };\n        return token;\n    },\n    functionDeclaration: function (token, parameters, body, returnExpression) {\n        token.interpret = function (context) {\n            return context;\n        };\n        token.name = token.value;\n        token.arity = 'routine';\n        token.alias = 'functionDeclaration';\n        token.parameters = parameters;\n        token.body = body;\n        token.return = returnExpression;\n        return token;\n    },\n    rootProgram: function (grammar) {\n        grammar.interpret = function (root, context) {\n            var main;\n            var declarations = [];\n            context = context || new Context();\n            for (var i = 0; i < root.length; i++) {\n                if (root[i].alias === 'program') {\n                    main = root[i];\n                } else {\n                    declarations.push(root[i]);\n                }\n            }\n            interpretBlock(declarations, context);\n            main.interpret(context);\n        };\n        return grammar;\n    }\n};\n\nmodule.exports = behaviours;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/interpreter.js\n ** module id = 4\n ** module chunks = 0\n **/","/**\n * LEXER\n *\n * The lexer class is an iterator that takes a String as input in Lexer.input\n * and returns a token each time Lexer.next is called, or null otherwise.\n * Characters used for multi character operators can be configured on instantiation.\n */\n\n// PUBLIC\n\nfunction Lexer(prefix, suffix) {\n    // Current reading position\n    this.from = 0;\n    this.row = 0;\n    this.prefix = prefix || '!=-<>:|&';\n    this.suffix = suffix || '=|&>';\n\n    this.punctuators = '+-*.:%|!?#&;,()<>{}[]=';\n\n    // Look ahead position\n    this.i = 0;\n\n    this.buf = null;\n    this.buflen = 0;\n}\n\nLexer.prototype.hasNext = function () {\n    this._skipNonTokens();\n    return this.from < this.buflen;\n};\n\nLexer.prototype.input = function (buf) {\n    this.from = 0;\n    this.i = 0;\n    this.row = 0;\n    this.buf = buf;\n    this.buflen = buf.length;\n    this.current = null;\n    this.nextChar = null;\n};\n\nvar TokenTypes = {\n    IDENTIFIER: 'name',\n    OPERATOR: 'operator',\n    EOF: 'eof',\n    COMMENT: 'comment',\n    NUMBER: 'number',\n    NEWLINE: 'newline'\n};\n\n/**\n * This method is highly procedural for performance reasons.\n * There is no need for the lexer to be too flexible, since the\n * semantics will be associated to identifiers on the parser.\n *\n * @returns Token. The next token on the buffer, or null if the buffer is empty.\n */\nLexer.prototype.next = function () {\n    this._skipNonTokens();\n    this._refreshCurrentAndNextChars();\n\n    if (this.from >= this.buflen) {\n        return null;\n    }\n\n    // Always add cases in descending order of occurrence probability\n    if (this._processIdentifier()) {\n        return this._consume(TokenTypes.IDENTIFIER);\n    } else if (this._processOperator()) {\n        return this._consume(TokenTypes.OPERATOR);\n    } else if (this._processNumber()) {\n        return this._consume(TokenTypes.NUMBER);\n    } else if (this._processComment()) {\n        return this._consume(TokenTypes.COMMENT);\n    }\n\n    return this._processError();\n};\n\n// PRIVATE\n\nfunction error(token, description) {\n    return {error: description, on: token};\n}\n\nLexer.prototype._make = function (type, value) {\n    return {type: type, value: value, from: this.from, to: this.i, row: this.row};\n};\n\nLexer.prototype._consume = function (type) {\n    var text = this.buf.substring(this.from, this.i);\n    var newToken = this._make(type, text);\n    this.from = this.i;\n    return newToken;\n};\n\nLexer.prototype._refreshCurrentAndNextChars = function () {\n    this.current = this.buf.charAt(this.from);\n    this.nextChar = this.buf.charAt(this.from + 1);\n};\n\nLexer.prototype._processOperator = function () {\n    if (this.punctuators.indexOf(this.current) >= 0) {\n        this.i = this.from + 1;\n        this._processMultiCharOperator();\n        return true;\n    }\n    return false;\n};\n\nLexer.prototype._processMultiCharOperator = function () {\n    if (this.prefix.indexOf(this.current) >= 0 && this.suffix.indexOf(this.nextChar) >= 0) {\n        this.i++;\n    }\n};\n\nLexer.prototype._processNumber = function () {\n    if (_isDigit(this.current)) {\n        this.i = this.from + 1;\n        while (this.i < this.buflen && _isDigit(this.buf.charAt(this.i))) {\n            this.i++;\n        }\n        return true;\n    }\n    return false;\n};\n\nLexer.prototype._processError = function () {\n    this.i = this.from + 1;\n    return error('Unmatched token', this._consume('UNMATCHED'));\n};\n\nLexer.prototype._processIdentifier = function () {\n    if (_isAlpha(this.current)) {\n        this.i = this.from + 1;\n        while (this.i < this.buflen && _isAlphanum(this.buf.charAt(this.i))) {\n            this.i++;\n        }\n        return true;\n    }\n    return false;\n};\n\nLexer.prototype._skipNonTokens = function () {\n    while (this.from < this.buflen) {\n        var c = this.buf.charAt(this.from);\n        if (c === ' ' || c === '\\t' || c === '\\r' || c === '\\n') {\n            if (c === '\\n') {\n                this.row += 1;\n            }\n            this.from++;\n            this.i = this.from;\n        } else {\n            break;\n        }\n    }\n};\n\nLexer.prototype._processComment = function () {\n    var chars = this.current + this.nextChar;\n    return this._processSingleLineComment(chars) || this._processMultiLineComment(chars);\n};\n\nLexer.prototype._processSingleLineComment = function (chars) {\n    if (chars === '//') {\n        while (this.i < this.buflen && !_isNewline(this.buf.charAt(this.i))) {\n            this.i++;\n        }\n        return true;\n    }\n};\n\nLexer.prototype._processMultiLineComment = function (chars) {\n    if (chars === '/*') {\n        this.i = this.i + 2;\n        while (this.i < this.buflen && this.buf.charAt(this.i) !== '*' && this.buf.charAt(this.i + 1) !== '/') {\n            this.i++;\n        }\n        this.i = this.i + 2;\n        return true;\n    }\n    return false;\n};\n\nfunction _isNewline(c) {\n    return c === '\\r' || c === '\\n';\n}\n\nfunction _isDigit(c) {\n    return c >= '0' && c <= '9';\n}\n\nfunction _isAlpha(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '_' || c === '$';\n}\n\nfunction _isAlphanum(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c === '_' || c === '$';\n}\n\nmodule.exports = Lexer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/lexer.js\n ** module id = 5\n ** module chunks = 0\n **/","function Board(sizeX, sizeY) {\n    this.x = 0;\n    this.y = 0;\n\n    this.sizeX = sizeX;\n    this.sizeY = sizeY;\n}\n\nBoard.blue = 0;\nBoard.red = 1;\nBoard.black = 2;\nBoard.green = 3;\n\nBoard.prototype.init = function () {\n    this.table = [[], [], [], []];\n    for (var i = 0; i < this.sizeX; i++) {\n        this.table[0][i] = [];\n        this.table[1][i] = [];\n        this.table[2][i] = [];\n        this.table[3][i] = [];\n        for (var j = 0; j < this.sizeY; j++) {\n            this.table[0][i][j] = 0;\n            this.table[1][i][j] = 0;\n            this.table[2][i][j] = 0;\n            this.table[3][i][j] = 0;\n        }\n    }\n};\n\nBoard.prototype.clone = function () {\n    var c = new Board(this.sizeX, this.sizeY);\n    c.init();\n    for (var i = 0; i < this.table.length; i++) {\n        c.table[i] = this.table[i].slice();\n    }\n    c.x = this.x;\n    c.y = this.y;\n    return c;\n};\n\nBoard.prototype.putStone = function (color) {\n    this.table[color][this.x][this.y] += 1;\n};\n\nBoard.prototype.removeStone = function (color) {\n    this.table[color][this.x][this.y] -= 1;\n};\n\nBoard.prototype.hasStone = function (color) {\n    return this.table[color][this.x][this.y];\n};\n\nBoard.prototype.canMove = function (vec) {\n    var nextX = this.x + vec[0];\n    var nextY = this.y + vec[1];\n    return nextX < this.sizeX && nextX >= 0 && nextY < this.sizeY && nextY >= 0;\n};\n\nBoard.prototype.move = function (vec) {\n    this.x += vec[0];\n    this.y += vec[1];\n};\n\nBoard.prototype.printAscii = function () {\n    var out = this.sizeX + 'x' + this.sizeY + '\\n';\n    var az = this.table[0];\n    var ro = this.table[1];\n    var ne = this.table[2];\n    var ve = this.table[3];\n    for (var j = this.sizeY - 1; j >= 0; j--) {\n        for (var i = 0; i < this.sizeX; i++) {\n            out += (az[i][j] || ro[i][j] || ne[i][j] || ve[i][j]) ? '#' : '.';\n        }\n        out += '\\n';\n    }\n    return out;\n};\n\nmodule.exports = Board;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/model.js\n ** module id = 6\n ** module chunks = 0\n **/","function Parser(lexer) {\n    this.scope = null;\n    this.token = null;\n    this.tokens = lexer;\n    var self = this;\n\n    var symbolTable = {};\n\n    this.error = function (token, description) {\n        var someError = {error: description, on: token};\n        throw someError;\n    };\n\n    var OriginalSymbol = {\n        nud: function () {\n            self.error(this, 'Undefined.');\n        },\n        led: function () {\n            self.error(this, 'Missing operator.');\n        }\n    };\n\n    var itself = function () {\n        return this;\n    };\n\n    var originalScope = {\n        define: function (name) {\n            var t = this.def[name.value];\n            if (typeof t === 'object') {\n                self.error(name, t.reserved ? 'Already reserved.' : 'Already defined.');\n            }\n            this.def[name.value] = name;\n            name.reserved = false;\n            name.nud = itself;\n            name.led = null;\n            name.std = null;\n            name.lbp = 0;\n            name.scope = self.scope;\n            return name;\n        },\n        find: function (name) {\n            var e = this;\n            var targetToken;\n            for (; ;) {\n                targetToken = e.def[name];\n                if (targetToken && typeof targetToken !== 'function') {\n                    return e.def[name];\n                }\n                e = e.parent;\n                if (!e) {\n                    targetToken = symbolTable[name];\n                    return targetToken && typeof targetToken !== 'function' ? targetToken : symbolTable['(name)'];\n                }\n            }\n        },\n        pop: function () {\n            this.scope = this.parent;\n        },\n        reserve: function (name) {\n            if (name.arity !== 'name' || name.reserved) {\n                return;\n            }\n            var t = this.def[name.value];\n            if (t) {\n                if (t.reserved) {\n                    return;\n                }\n                if (t.arity === 'name') {\n                    name.error('Already defined.');\n                }\n            }\n            this.def[name.value] = name;\n            name.reserved = true;\n        }\n    };\n\n    this.newScope = function () {\n        var s = self.scope;\n        self.scope = Object.create(originalScope);\n        self.scope.def = {};\n        self.scope.parent = s;\n        return self.scope;\n    };\n\n    this.symbol = function (id, bindingPower) {\n        var s = symbolTable[id];\n        bindingPower = bindingPower || 0;\n        if (s) {\n            if (bindingPower >= s.lbp) {\n                s.lbp = bindingPower;\n            }\n        } else {\n            s = Object.create(OriginalSymbol);\n            s.id = s.value = id;\n            s.lbp = bindingPower;\n            symbolTable[id] = s;\n        }\n        return s;\n    };\n\n    this.expression = function (rightBindingPower) {\n        var left;\n        var t = self.token;\n        this.advance();\n        left = t.nud();\n        while (rightBindingPower < self.token.lbp) {\n            t = self.token;\n            this.advance();\n            left = t.led(left);\n        }\n        return left;\n    };\n\n    this.constant = function (symbol, value) {\n        var x = this.symbol(symbol);\n        x.nud = function () {\n            self.scope.reserve(this);\n            this.value = symbolTable[this.id].value;\n            this.arity = 'literal';\n            this.eval = function () {\n                return value;\n            };\n            return this;\n        };\n        x.value = value;\n        return x;\n    };\n\n    this.infix = function (id, bp, led) {\n        var s = this.symbol(id, bp);\n        s.led = led || function (left) {\n            this.left = left;\n            this.right = self.expression(bp);\n            this.arity = 'binary';\n            return this;\n        };\n        return s;\n    };\n\n    this.infixr = function (id, bp, led) {\n        var s = this.symbol(id, bp);\n        s.led = led || function (left) {\n            this.left = left;\n            this.right = self.expression(bp - 1);\n            this.arity = 'binary';\n            return this;\n        };\n        return s;\n    };\n\n    this.prefix = function (id, nud) {\n        var s = this.symbol(id);\n        s.nud = nud || function () {\n            scope.reserve(this);\n            this.left = self.expression(70);\n            this.arity = 'unary';\n            return this;\n        };\n        return s;\n    };\n\n    this.stmt = function (symbol, f) {\n        var x = this.symbol(symbol);\n        x.std = f;\n        return x;\n    };\n\n    this.root = function (symbol, f) {\n        var x = this.symbol(symbol);\n        x.root = f;\n        return x;\n    };\n\n    /**\n     * The advance function fetches the next token,\n     * generating the corresponding symbol from the definitions on symbolTable\n     *\n     * @param id. Token ID\n     * @returns Token\n     */\n    this.advance = function (id) {\n        var a;\n        var o;\n        var t;\n        var v;\n        var tokens = this.tokens;\n        if (id && this.token.id !== id) {\n            this.error(this.token, 'Se esperaba \"' + id + '\" pero se encontró ' + this.token.value);\n        }\n        if (!tokens.hasNext()) {\n            this.token = symbolTable['(end)'];\n            return this.token;\n        }\n        t = tokens.next();\n        v = t.value;\n        a = t.type;\n        if (a === 'name') {\n            o = this.scope.find(v);\n        } else if (a === 'operator') {\n            o = symbolTable[v];\n            if (!o) {\n                this.error(t, 'Unknown operator.');\n            }\n        } else if (a === 'number') {\n            o = symbolTable['(literal)'];\n            a = 'literal';\n            v = parseInt(v, 10);\n        } else {\n            this.error(t, 'Unexpected token.');\n        }\n\n        var token = Object.create(o);\n        token.from = t.from;\n        token.row = t.row;\n        token.to = t.to;\n        token.value = v;\n        token.arity = a;\n        this.token = token;\n        return token;\n    };\n\n    this.block = function () {\n        var t = this.token;\n        this.advance('{');\n        return t.std();\n    };\n\n    this.statement = function () {\n        var n = this.token;\n        var v;\n\n        if (n.std) {\n            this.advance();\n            self.scope.reserve(n);\n            return n.std();\n        }\n        v = this.expression(0);\n        if (!v.assignment && v.id !== '(' && v.arity !== 'routine') {\n            this.error(v, 'Bad expression statement.');\n        }\n        return v;\n    };\n\n    this.rootDeclaration = function () {\n        var n = this.token;\n        var v;\n\n        if (n.root) {\n            this.advance();\n            self.scope.reserve(n);\n            return n.root();\n        }\n        v = this.expression(0);\n        if (!v.assignment && v.id !== '(' && v.arity !== 'routine') {\n            this.error(v, 'Bad expression statement.');\n        }\n        return v;\n    };\n\n    this.statements = function () {\n        var statementsList = [];\n        var symbol;\n        for (; ;) {\n            if (this.token.id === '}' || this.token.id === '(end)') {\n                break;\n            }\n            var from = this.token.from;\n            symbol = this.statement();\n            if (symbol) {\n                symbol.from = from;\n                if (this.token.from) {\n                    symbol.to = this.token.from;\n                }\n                statementsList.push(symbol);\n            }\n        }\n        if (statementsList.length === 0) {\n            return null;\n        }\n        return statementsList;\n    };\n\n    this.roots = function () {\n        var roots = [];\n        var symbol;\n        for (; ;) {\n            if (this.token.id === '(end)') {\n                break;\n            }\n            var from = this.token.from;\n            symbol = this.rootDeclaration();\n            if (symbol) {\n                symbol.from = from;\n                if (this.token.from) {\n                    symbol.to = this.token.from;\n                }\n                roots.push(symbol);\n            }\n        }\n        if (roots.length === 0) {\n            return null;\n        }\n        return roots;\n    };\n\n    this.parseProgram = function (input) {\n        this.tokens.input(input);\n        this.newScope();\n        this.advance();\n        var s = this.roots();\n        this.advance('(end)');\n        this.scope.pop();\n        return s;\n    };\n\n    this.parse = function (input) {\n        this.tokens.input(input);\n        this.newScope();\n        this.advance();\n        var s = this.statements();\n        this.advance('(end)');\n        this.scope.pop();\n        return s;\n    };\n\n    this.parseExpression = function (input) {\n        this.tokens.input(input);\n        this.newScope();\n        this.advance();\n        var s = this.expression(0);\n        this.advance('(end)');\n        this.scope.pop();\n        return s;\n    };\n}\n\nmodule.exports = Parser;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/parser.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}